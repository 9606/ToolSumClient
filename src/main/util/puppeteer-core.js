import require$$1 from 'debug';
import require$$10 from 'stream';
import require$$0 from 'cross-fetch';
import require$$0$1 from './ws';
import require$$0$5 from 'fs/promises';
import require$$2 from 'path';
import require$$3 from './puppeteerBrowsers';
import require$$0$4 from 'fs';
import require$$1$1 from 'os';
import require$$0$3 from 'chromium-bidi/lib/cjs/bidiMapper/bidiMapper.js';
import require$$0$2 from 'chromium-bidi/lib/cjs/protocol/protocol.js';

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var puppeteerCore$1 = {};

var api = {};

var Browser$3 = {};

var disposablestack = {};

var t$1="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof commonjsGlobal?commonjsGlobal:"undefined"!=typeof self?self:{};function e$1(t){if(t.__esModule)return t;var e=t.default;if("function"==typeof e){var r=function t(){return this instanceof t?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};r.prototype=e.prototype;}else r={};return Object.defineProperty(r,"__esModule",{value:!0}),Object.keys(t).forEach((function(e){var n=Object.getOwnPropertyDescriptor(t,e);Object.defineProperty(r,e,n.get?n:{enumerable:!0,get:function(){return t[e]}});})),r}var r$1,n$1,o$1=Object.prototype.toString,i$1=function(t){var e=o$1.call(t),r="[object Arguments]"===e;return r||(r="[object Array]"!==e&&null!==t&&"object"==typeof t&&"number"==typeof t.length&&t.length>=0&&"[object Function]"===o$1.call(t.callee)),r};var a$1=Array.prototype.slice,u$1=i$1,c$1=Object.keys,s$1=c$1?function(t){return c$1(t)}:function(){if(n$1)return r$1;var t;if(n$1=1,!Object.keys){var e=Object.prototype.hasOwnProperty,o=Object.prototype.toString,a=i$1,u=Object.prototype.propertyIsEnumerable,c=!u.call({toString:null},"toString"),s=u.call((function(){}),"prototype"),f=["toString","toLocaleString","valueOf","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","constructor"],p=function(t){var e=t.constructor;return e&&e.prototype===t},l={$applicationCache:!0,$console:!0,$external:!0,$frame:!0,$frameElement:!0,$frames:!0,$innerHeight:!0,$innerWidth:!0,$onmozfullscreenchange:!0,$onmozfullscreenerror:!0,$outerHeight:!0,$outerWidth:!0,$pageXOffset:!0,$pageYOffset:!0,$parent:!0,$scrollLeft:!0,$scrollTop:!0,$scrollX:!0,$scrollY:!0,$self:!0,$webkitIndexedDB:!0,$webkitStorageInfo:!0,$window:!0},y=function(){if("undefined"==typeof window)return !1;for(var t in window)try{if(!l["$"+t]&&e.call(window,t)&&null!==window[t]&&"object"==typeof window[t])try{p(window[t]);}catch(t){return !0}}catch(t){return !0}return !1}();t=function(t){var r=null!==t&&"object"==typeof t,n="[object Function]"===o.call(t),i=a(t),u=r&&"[object String]"===o.call(t),l=[];if(!r&&!n&&!i)throw new TypeError("Object.keys called on a non-object");var b=s&&n;if(u&&t.length>0&&!e.call(t,0))for(var d=0;d<t.length;++d)l.push(String(d));if(i&&t.length>0)for(var h=0;h<t.length;++h)l.push(String(h));else for(var g in t)b&&"prototype"===g||!e.call(t,g)||l.push(String(g));if(c)for(var m=function(t){if("undefined"==typeof window||!y)return p(t);try{return p(t)}catch(t){return !1}}(t),v=0;v<f.length;++v)m&&"constructor"===f[v]||!e.call(t,f[v])||l.push(f[v]);return l};}return r$1=t}(),f$1=Object.keys;s$1.shim=function(){if(Object.keys){var t=function(){var t=Object.keys(arguments);return t&&t.length===arguments.length}(1,2);t||(Object.keys=function(t){return u$1(t)?f$1(a$1.call(t)):f$1(t)});}else Object.keys=s$1;return Object.keys||s$1};var p$1,l$1=s$1,y$1=function(){if("function"!=typeof Symbol||"function"!=typeof Object.getOwnPropertySymbols)return !1;if("symbol"==typeof Symbol.iterator)return !0;var t={},e=Symbol("test"),r=Object(e);if("string"==typeof e)return !1;if("[object Symbol]"!==Object.prototype.toString.call(e))return !1;if("[object Symbol]"!==Object.prototype.toString.call(r))return !1;for(e in t[e]=42,t)return !1;if("function"==typeof Object.keys&&0!==Object.keys(t).length)return !1;if("function"==typeof Object.getOwnPropertyNames&&0!==Object.getOwnPropertyNames(t).length)return !1;var n=Object.getOwnPropertySymbols(t);if(1!==n.length||n[0]!==e)return !1;if(!Object.prototype.propertyIsEnumerable.call(t,e))return !1;if("function"==typeof Object.getOwnPropertyDescriptor){var o=Object.getOwnPropertyDescriptor(t,e);if(42!==o.value||!0!==o.enumerable)return !1}return !0},b$1="undefined"!=typeof Symbol&&Symbol,d$1=y$1,h$1=function(){return "function"==typeof b$1&&("function"==typeof Symbol&&("symbol"==typeof b$1("foo")&&("symbol"==typeof Symbol("bar")&&d$1())))},g$1={foo:{}},m$1=Object,v$1=function(){return {__proto__:g$1}.foo===g$1.foo&&!({__proto__:null}instanceof m$1)},w$1=Array.prototype.slice,S$1=Object.prototype.toString,j$1=function(t){var e=this;if("function"!=typeof e||"[object Function]"!==S$1.call(e))throw new TypeError("Function.prototype.bind called on incompatible "+e);for(var r,n=w$1.call(arguments,1),o=Math.max(0,e.length-n.length),i=[],a=0;a<o;a++)i.push("$"+a);if(r=Function("binder","return function ("+i.join(",")+"){ return binder.apply(this,arguments); }")((function(){if(this instanceof r){var o=e.apply(this,n.concat(w$1.call(arguments)));return Object(o)===o?o:this}return e.apply(t,n.concat(w$1.call(arguments)))})),e.prototype){var u=function(){};u.prototype=e.prototype,r.prototype=new u,u.prototype=null;}return r},O$1=Function.prototype.bind||j$1,A$1=O$1.call(Function.call,Object.prototype.hasOwnProperty),P$1=SyntaxError,E$1=Function,D$1=TypeError,T$1=function(t){try{return E$1('"use strict"; return ('+t+").constructor;")()}catch(t){}},x$1=Object.getOwnPropertyDescriptor;if(x$1)try{x$1({},"");}catch(t){x$1=null;}var I$1=function(){throw new D$1},k$1=x$1?function(){try{return I$1}catch(t){try{return x$1(arguments,"callee").get}catch(t){return I$1}}}():I$1,R$1=h$1(),C$1=v$1(),F$1=Object.getPrototypeOf||(C$1?function(t){return t.__proto__}:null),M$1={},_$1="undefined"!=typeof Uint8Array&&F$1?F$1(Uint8Array):p$1,N$1={"%AggregateError%":"undefined"==typeof AggregateError?p$1:AggregateError,"%Array%":Array,"%ArrayBuffer%":"undefined"==typeof ArrayBuffer?p$1:ArrayBuffer,"%ArrayIteratorPrototype%":R$1&&F$1?F$1([][Symbol.iterator]()):p$1,"%AsyncFromSyncIteratorPrototype%":p$1,"%AsyncFunction%":M$1,"%AsyncGenerator%":M$1,"%AsyncGeneratorFunction%":M$1,"%AsyncIteratorPrototype%":M$1,"%Atomics%":"undefined"==typeof Atomics?p$1:Atomics,"%BigInt%":"undefined"==typeof BigInt?p$1:BigInt,"%BigInt64Array%":"undefined"==typeof BigInt64Array?p$1:BigInt64Array,"%BigUint64Array%":"undefined"==typeof BigUint64Array?p$1:BigUint64Array,"%Boolean%":Boolean,"%DataView%":"undefined"==typeof DataView?p$1:DataView,"%Date%":Date,"%decodeURI%":decodeURI,"%decodeURIComponent%":decodeURIComponent,"%encodeURI%":encodeURI,"%encodeURIComponent%":encodeURIComponent,"%Error%":Error,"%eval%":eval,"%EvalError%":EvalError,"%Float32Array%":"undefined"==typeof Float32Array?p$1:Float32Array,"%Float64Array%":"undefined"==typeof Float64Array?p$1:Float64Array,"%FinalizationRegistry%":"undefined"==typeof FinalizationRegistry?p$1:FinalizationRegistry,"%Function%":E$1,"%GeneratorFunction%":M$1,"%Int8Array%":"undefined"==typeof Int8Array?p$1:Int8Array,"%Int16Array%":"undefined"==typeof Int16Array?p$1:Int16Array,"%Int32Array%":"undefined"==typeof Int32Array?p$1:Int32Array,"%isFinite%":isFinite,"%isNaN%":isNaN,"%IteratorPrototype%":R$1&&F$1?F$1(F$1([][Symbol.iterator]())):p$1,"%JSON%":"object"==typeof JSON?JSON:p$1,"%Map%":"undefined"==typeof Map?p$1:Map,"%MapIteratorPrototype%":"undefined"!=typeof Map&&R$1&&F$1?F$1((new Map)[Symbol.iterator]()):p$1,"%Math%":Math,"%Number%":Number,"%Object%":Object,"%parseFloat%":parseFloat,"%parseInt%":parseInt,"%Promise%":"undefined"==typeof Promise?p$1:Promise,"%Proxy%":"undefined"==typeof Proxy?p$1:Proxy,"%RangeError%":RangeError,"%ReferenceError%":ReferenceError,"%Reflect%":"undefined"==typeof Reflect?p$1:Reflect,"%RegExp%":RegExp,"%Set%":"undefined"==typeof Set?p$1:Set,"%SetIteratorPrototype%":"undefined"!=typeof Set&&R$1&&F$1?F$1((new Set)[Symbol.iterator]()):p$1,"%SharedArrayBuffer%":"undefined"==typeof SharedArrayBuffer?p$1:SharedArrayBuffer,"%String%":String,"%StringIteratorPrototype%":R$1&&F$1?F$1(""[Symbol.iterator]()):p$1,"%Symbol%":R$1?Symbol:p$1,"%SyntaxError%":P$1,"%ThrowTypeError%":k$1,"%TypedArray%":_$1,"%TypeError%":D$1,"%Uint8Array%":"undefined"==typeof Uint8Array?p$1:Uint8Array,"%Uint8ClampedArray%":"undefined"==typeof Uint8ClampedArray?p$1:Uint8ClampedArray,"%Uint16Array%":"undefined"==typeof Uint16Array?p$1:Uint16Array,"%Uint32Array%":"undefined"==typeof Uint32Array?p$1:Uint32Array,"%URIError%":URIError,"%WeakMap%":"undefined"==typeof WeakMap?p$1:WeakMap,"%WeakRef%":"undefined"==typeof WeakRef?p$1:WeakRef,"%WeakSet%":"undefined"==typeof WeakSet?p$1:WeakSet};if(F$1)try{null.error;}catch(t){var W$1=F$1(F$1(t));N$1["%Error.prototype%"]=W$1;}var U$1=function t(e){var r;if("%AsyncFunction%"===e)r=T$1("async function () {}");else if("%GeneratorFunction%"===e)r=T$1("function* () {}");else if("%AsyncGeneratorFunction%"===e)r=T$1("async function* () {}");else if("%AsyncGenerator%"===e){var n=t("%AsyncGeneratorFunction%");n&&(r=n.prototype);}else if("%AsyncIteratorPrototype%"===e){var o=t("%AsyncGenerator%");o&&F$1&&(r=F$1(o.prototype));}return N$1[e]=r,r},$$1={"%ArrayBufferPrototype%":["ArrayBuffer","prototype"],"%ArrayPrototype%":["Array","prototype"],"%ArrayProto_entries%":["Array","prototype","entries"],"%ArrayProto_forEach%":["Array","prototype","forEach"],"%ArrayProto_keys%":["Array","prototype","keys"],"%ArrayProto_values%":["Array","prototype","values"],"%AsyncFunctionPrototype%":["AsyncFunction","prototype"],"%AsyncGenerator%":["AsyncGeneratorFunction","prototype"],"%AsyncGeneratorPrototype%":["AsyncGeneratorFunction","prototype","prototype"],"%BooleanPrototype%":["Boolean","prototype"],"%DataViewPrototype%":["DataView","prototype"],"%DatePrototype%":["Date","prototype"],"%ErrorPrototype%":["Error","prototype"],"%EvalErrorPrototype%":["EvalError","prototype"],"%Float32ArrayPrototype%":["Float32Array","prototype"],"%Float64ArrayPrototype%":["Float64Array","prototype"],"%FunctionPrototype%":["Function","prototype"],"%Generator%":["GeneratorFunction","prototype"],"%GeneratorPrototype%":["GeneratorFunction","prototype","prototype"],"%Int8ArrayPrototype%":["Int8Array","prototype"],"%Int16ArrayPrototype%":["Int16Array","prototype"],"%Int32ArrayPrototype%":["Int32Array","prototype"],"%JSONParse%":["JSON","parse"],"%JSONStringify%":["JSON","stringify"],"%MapPrototype%":["Map","prototype"],"%NumberPrototype%":["Number","prototype"],"%ObjectPrototype%":["Object","prototype"],"%ObjProto_toString%":["Object","prototype","toString"],"%ObjProto_valueOf%":["Object","prototype","valueOf"],"%PromisePrototype%":["Promise","prototype"],"%PromiseProto_then%":["Promise","prototype","then"],"%Promise_all%":["Promise","all"],"%Promise_reject%":["Promise","reject"],"%Promise_resolve%":["Promise","resolve"],"%RangeErrorPrototype%":["RangeError","prototype"],"%ReferenceErrorPrototype%":["ReferenceError","prototype"],"%RegExpPrototype%":["RegExp","prototype"],"%SetPrototype%":["Set","prototype"],"%SharedArrayBufferPrototype%":["SharedArrayBuffer","prototype"],"%StringPrototype%":["String","prototype"],"%SymbolPrototype%":["Symbol","prototype"],"%SyntaxErrorPrototype%":["SyntaxError","prototype"],"%TypedArrayPrototype%":["TypedArray","prototype"],"%TypeErrorPrototype%":["TypeError","prototype"],"%Uint8ArrayPrototype%":["Uint8Array","prototype"],"%Uint8ClampedArrayPrototype%":["Uint8ClampedArray","prototype"],"%Uint16ArrayPrototype%":["Uint16Array","prototype"],"%Uint32ArrayPrototype%":["Uint32Array","prototype"],"%URIErrorPrototype%":["URIError","prototype"],"%WeakMapPrototype%":["WeakMap","prototype"],"%WeakSetPrototype%":["WeakSet","prototype"]},V$1=O$1,B$1=A$1,G$1=V$1.call(Function.call,Array.prototype.concat),z$1=V$1.call(Function.apply,Array.prototype.splice),L$1=V$1.call(Function.call,String.prototype.replace),H$1=V$1.call(Function.call,String.prototype.slice),q$1=V$1.call(Function.call,RegExp.prototype.exec),J$1=/[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,K$1=/\\(\\)?/g,X$1=function(t,e){var r,n=t;if(B$1($$1,n)&&(n="%"+(r=$$1[n])[0]+"%"),B$1(N$1,n)){var o=N$1[n];if(o===M$1&&(o=U$1(n)),void 0===o&&!e)throw new D$1("intrinsic "+t+" exists, but is not available. Please file an issue!");return {alias:r,name:n,value:o}}throw new P$1("intrinsic "+t+" does not exist!")},Y$1=function(t,e){if("string"!=typeof t||0===t.length)throw new D$1("intrinsic name must be a non-empty string");if(arguments.length>1&&"boolean"!=typeof e)throw new D$1('"allowMissing" argument must be a boolean');if(null===q$1(/^%?[^%]*%?$/,t))throw new P$1("`%` may not be present anywhere but at the beginning and end of the intrinsic name");var r=function(t){var e=H$1(t,0,1),r=H$1(t,-1);if("%"===e&&"%"!==r)throw new P$1("invalid intrinsic syntax, expected closing `%`");if("%"===r&&"%"!==e)throw new P$1("invalid intrinsic syntax, expected opening `%`");var n=[];return L$1(t,J$1,(function(t,e,r,o){n[n.length]=r?L$1(o,K$1,"$1"):e||t;})),n}(t),n=r.length>0?r[0]:"",o=X$1("%"+n+"%",e),i=o.name,a=o.value,u=!1,c=o.alias;c&&(n=c[0],z$1(r,G$1([0,1],c)));for(var s=1,f=!0;s<r.length;s+=1){var p=r[s],l=H$1(p,0,1),y=H$1(p,-1);if(('"'===l||"'"===l||"`"===l||'"'===y||"'"===y||"`"===y)&&l!==y)throw new P$1("property names with quotes must have matching quotes");if("constructor"!==p&&f||(u=!0),B$1(N$1,i="%"+(n+="."+p)+"%"))a=N$1[i];else if(null!=a){if(!(p in a)){if(!e)throw new D$1("base intrinsic for "+t+" exists, but the property is not available.");return}if(x$1&&s+1>=r.length){var b=x$1(a,p);a=(f=!!b)&&"get"in b&&!("originalValue"in b.get)?b.get:a[p];}else f=B$1(a,p),a=a[p];f&&!u&&(N$1[i]=a);}}return a},Z$1=Y$1("%Object.defineProperty%",!0),Q$1=function(){if(Z$1)try{return Z$1({},"a",{value:1}),!0}catch(t){return !1}return !1};Q$1.hasArrayLengthDefineBug=function(){if(!Q$1())return null;try{return 1!==Z$1([],"length",{value:1}).length}catch(t){return !0}};var tt=Q$1,et=l$1,rt="function"==typeof Symbol&&"symbol"==typeof Symbol("foo"),nt=Object.prototype.toString,ot=Array.prototype.concat,it=Object.defineProperty,at=tt(),ut=it&&at,ct=function(t,e,r,n){if(e in t)if(!0===n){if(t[e]===r)return}else if("function"!=typeof(o=n)||"[object Function]"!==nt.call(o)||!n())return;var o;ut?it(t,e,{configurable:!0,enumerable:!1,value:r,writable:!0}):t[e]=r;},st=function(t,e){var r=arguments.length>2?arguments[2]:{},n=et(e);rt&&(n=ot.call(n,Object.getOwnPropertySymbols(e)));for(var o=0;o<n.length;o+=1)ct(t,n[o],e[n[o]],r[n[o]]);};st.supportsDescriptors=!!ut;var ft=st,pt=t$1,lt=function(){return "object"==typeof t$1&&t$1&&t$1.Math===Math&&t$1.Array===Array?t$1:pt},yt=ft,bt=lt,dt=ft,ht=t$1,gt=lt,mt=function(){var t=bt();if(yt.supportsDescriptors){var e=Object.getOwnPropertyDescriptor(t,"globalThis");e&&(!e.configurable||!e.enumerable&&e.writable&&globalThis===t)||Object.defineProperty(t,"globalThis",{configurable:!0,enumerable:!1,value:t,writable:!0});}else "object"==typeof globalThis&&globalThis===t||(t.globalThis=t);return t},vt=gt(),wt=function(){return vt};dt(wt,{getPolyfill:gt,implementation:ht,shim:mt});var St,jt,Ot,At,Pt,Et,Dt,Tt,xt,It,kt,Rt,Ct,Ft,Mt,_t,Nt,Wt,Ut,$t,Vt,Bt,Gt,zt,Lt,Ht,qt,Jt,Kt,Xt,Yt,Zt=wt,Qt={exports:{}};function te(){return St||(St=1,function(t){var e=O$1,r=Y$1,n=r("%Function.prototype.apply%"),o=r("%Function.prototype.call%"),i=r("%Reflect.apply%",!0)||e.call(o,n),a=r("%Object.getOwnPropertyDescriptor%",!0),u=r("%Object.defineProperty%",!0),c=r("%Math.max%");if(u)try{u({},"a",{value:1});}catch(t){u=null;}t.exports=function(t){var r=i(e,o,arguments);a&&u&&(a(r,"length").configurable&&u(r,"length",{value:1+c(0,t.length-(arguments.length-1))}));return r};var s=function(){return i(e,n,arguments)};u?u(t.exports,"apply",{value:s}):t.exports.apply=s;}(Qt)),Qt.exports}function ee(){if(Ot)return jt;Ot=1;var t=Y$1,e=te(),r=e(t("String.prototype.indexOf"));return jt=function(n,o){var i=t(n,!!o);return "function"==typeof i&&r(n,".prototype.")>-1?e(i):i}}function re(){if(Pt)return At;Pt=1;var t=Y$1("%Array%"),e=!t.isArray&&ee()("Object.prototype.toString");return At=t.isArray||function(t){return "[object Array]"===e(t)}}function ne(){if(Dt)return Et;Dt=1;var t=tt,e=Y$1,r=t()&&e("%Object.defineProperty%",!0),n=t.hasArrayLengthDefineBug(),o=n&&re(),i=ee()("Object.prototype.propertyIsEnumerable");return Et=function(t,e,a,u,c,s){if(!r){if(!t(s))return !1;if(!s["[[Configurable]]"]||!s["[[Writable]]"])return !1;if(c in u&&i(u,c)!==!!s["[[Enumerable]]"])return !1;var f=s["[[Value]]"];return u[c]=f,e(u[c],f)}return n&&"length"===c&&"[[Value]]"in s&&o(u)&&u.length!==s["[[Value]]"]?(u.length=s["[[Value]]"],u.length===s["[[Value]]"]):(r(u,c,a(s)),!0)},Et}function oe(){return xt?Tt:(xt=1,Tt=Number.isNaN||function(t){return t!=t})}function ie(){if(Ct)return Rt;Ct=1;var t=Y$1,e=t("%Math.abs%"),r=t("%Math.floor%"),n=oe(),o=function(){if(kt)return It;kt=1;var t=oe();return It=function(e){return ("number"==typeof e||"bigint"==typeof e)&&!t(e)&&e!==1/0&&e!==-1/0}}();return Rt=function(t){if("number"!=typeof t||n(t)||!o(t))return !1;var i=e(t);return r(i)===i}}function ae(){if(Mt)return Ft;Mt=1;var t=A$1;return Ft=function(e){return t(e,"[[StartIndex]]")&&t(e,"[[EndIndex]]")&&e["[[StartIndex]]"]>=0&&e["[[EndIndex]]"]>=e["[[StartIndex]]"]&&String(parseInt(e["[[StartIndex]]"],10))===String(e["[[StartIndex]]"])&&String(parseInt(e["[[EndIndex]]"],10))===String(e["[[EndIndex]]"])}}function ue(){if(Nt)return _t;Nt=1;var t=Y$1,e=t("%TypeError%"),r=t("%SyntaxError%"),n=A$1,o=ie(),i={"Property Descriptor":function(t){var r={"[[Configurable]]":!0,"[[Enumerable]]":!0,"[[Get]]":!0,"[[Set]]":!0,"[[Value]]":!0,"[[Writable]]":!0};if(!t)return !1;for(var o in t)if(n(t,o)&&!r[o])return !1;var i=n(t,"[[Value]]"),a=n(t,"[[Get]]")||n(t,"[[Set]]");if(i&&a)throw new e("Property Descriptors may not be both accessor and data descriptors");return !0},"Match Record":ae(),"Iterator Record":function(t){return n(t,"[[Iterator]]")&&n(t,"[[NextMethod]]")&&n(t,"[[Done]]")},"PromiseCapability Record":function(t){return !!t&&n(t,"[[Resolve]]")&&"function"==typeof t["[[Resolve]]"]&&n(t,"[[Reject]]")&&"function"==typeof t["[[Reject]]"]&&n(t,"[[Promise]]")&&t["[[Promise]]"]&&"function"==typeof t["[[Promise]]"].then},"AsyncGeneratorRequest Record":function(t){return !!t&&n(t,"[[Completion]]")&&n(t,"[[Capability]]")&&i["PromiseCapability Record"](t["[[Capability]]"])},"RegExp Record":function(t){return t&&n(t,"[[IgnoreCase]]")&&"boolean"==typeof t["[[IgnoreCase]]"]&&n(t,"[[Multiline]]")&&"boolean"==typeof t["[[Multiline]]"]&&n(t,"[[DotAll]]")&&"boolean"==typeof t["[[DotAll]]"]&&n(t,"[[Unicode]]")&&"boolean"==typeof t["[[Unicode]]"]&&n(t,"[[CapturingGroupsCount]]")&&"number"==typeof t["[[CapturingGroupsCount]]"]&&o(t["[[CapturingGroupsCount]]"])&&t["[[CapturingGroupsCount]]"]>=0}};return _t=function(t,n,o,a){var u=i[n];if("function"!=typeof u)throw new r("unknown record type: "+n);if("Object"!==t(a)||!u(a))throw new e(o+" must be a "+n)},_t}function ce(){return Ut?Wt:(Ut=1,Wt=function(t){if(void 0===t)return t;var e={};return "[[Value]]"in t&&(e.value=t["[[Value]]"]),"[[Writable]]"in t&&(e.writable=!!t["[[Writable]]"]),"[[Get]]"in t&&(e.get=t["[[Get]]"]),"[[Set]]"in t&&(e.set=t["[[Set]]"]),"[[Enumerable]]"in t&&(e.enumerable=!!t["[[Enumerable]]"]),"[[Configurable]]"in t&&(e.configurable=!!t["[[Configurable]]"]),e})}function se(){return Vt?$t:(Vt=1,$t=function(t){return null===t?"Null":void 0===t?"Undefined":"function"==typeof t||"object"==typeof t?"Object":"number"==typeof t?"Number":"boolean"==typeof t?"Boolean":"string"==typeof t?"String":void 0})}function fe(){if(Gt)return Bt;Gt=1;var t=se();return Bt=function(e){return "symbol"==typeof e?"Symbol":"bigint"==typeof e?"BigInt":t(e)}}function pe(){if(Lt)return zt;Lt=1;var t=ue(),e=ce(),r=fe();return zt=function(n){return void 0!==n&&t(r,"Property Descriptor","Desc",n),e(n)}}function le(){if(qt)return Ht;qt=1;var t=A$1,e=fe(),r=ue();return Ht=function(n){return void 0!==n&&(r(e,"Property Descriptor","Desc",n),!(!t(n,"[[Value]]")&&!t(n,"[[Writable]]")))}}function ye(){return Kt?Jt:(Kt=1,Jt=function(t){return "string"==typeof t||"symbol"==typeof t})}function be(){if(Yt)return Xt;Yt=1;var t=oe();return Xt=function(e,r){return e===r?0!==e||1/e==1/r:t(e)&&t(r)}}var de,he,ge,me,ve,we,Se,je,Oe,Ae,Pe,Ee,De,Te,xe=Y$1("%TypeError%"),Ie=ne(),ke=pe(),Re=le(),Ce=ye(),Fe=be(),Me=fe();function _e(){if(he)return de;he=1;var t=A$1,e=Y$1("%TypeError%");return de=function(r,n){if("Object"!==r.Type(n))return !1;var o={"[[Configurable]]":!0,"[[Enumerable]]":!0,"[[Get]]":!0,"[[Set]]":!0,"[[Value]]":!0,"[[Writable]]":!0};for(var i in n)if(t(n,i)&&!o[i])return !1;if(r.IsDataDescriptor(n)&&r.IsAccessorDescriptor(n))throw new e("Property Descriptors may not be both accessor and data descriptors");return !0}}function Ne(){if(je)return Se;je=1;var t,e,r=Function.prototype.toString,n="object"==typeof Reflect&&null!==Reflect&&Reflect.apply;if("function"==typeof n&&"function"==typeof Object.defineProperty)try{t=Object.defineProperty({},"length",{get:function(){throw e}}),e={},n((function(){throw 42}),null,t);}catch(t){t!==e&&(n=null);}else n=null;var o=/^\s*class\b/,i=function(t){try{var e=r.call(t);return o.test(e)}catch(t){return !1}},a=function(t){try{return !i(t)&&(r.call(t),!0)}catch(t){return !1}},u=Object.prototype.toString,c="function"==typeof Symbol&&!!Symbol.toStringTag,s=!(0 in[,]),f=function(){return !1};if("object"==typeof document){var p=document.all;u.call(p)===u.call(document.all)&&(f=function(t){if((s||!t)&&(void 0===t||"object"==typeof t))try{var e=u.call(t);return ("[object HTMLAllCollection]"===e||"[object HTML document.all class]"===e||"[object HTMLCollection]"===e||"[object Object]"===e)&&null==t("")}catch(t){}return !1});}return Se=n?function(r){if(f(r))return !0;if(!r)return !1;if("function"!=typeof r&&"object"!=typeof r)return !1;try{n(r,null,t);}catch(t){if(t!==e)return !1}return !i(r)&&a(r)}:function(t){if(f(t))return !0;if(!t)return !1;if("function"!=typeof t&&"object"!=typeof t)return !1;if(c)return a(t);if(i(t))return !1;var e=u.call(t);return !("[object Function]"!==e&&"[object GeneratorFunction]"!==e&&!/^\[object HTML/.test(e))&&a(t)}}function We(){if(Ee)return Pe;Ee=1;var t=A$1,e=Y$1("%TypeError%"),r=fe(),n=we?ve:(we=1,ve=function(t){return !!t}),o=Ae?Oe:(Ae=1,Oe=Ne());return Pe=function(i){if("Object"!==r(i))throw new e("ToPropertyDescriptor requires an object");var a={};if(t(i,"enumerable")&&(a["[[Enumerable]]"]=n(i.enumerable)),t(i,"configurable")&&(a["[[Configurable]]"]=n(i.configurable)),t(i,"value")&&(a["[[Value]]"]=i.value),t(i,"writable")&&(a["[[Writable]]"]=n(i.writable)),t(i,"get")){var u=i.get;if(void 0!==u&&!o(u))throw new e("getter must be a function");a["[[Get]]"]=u;}if(t(i,"set")){var c=i.set;if(void 0!==c&&!o(c))throw new e("setter must be a function");a["[[Set]]"]=c;}if((t(a,"[[Get]]")||t(a,"[[Set]]"))&&(t(a,"[[Value]]")||t(a,"[[Writable]]")))throw new e("Invalid property descriptor. Cannot both specify accessors and a value or writable attribute");return a}}var Ue,$e,Ve,Be,Ge,ze,Le=Y$1("%TypeError%"),He=function(){if(Te)return De;Te=1;var t=Y$1("%TypeError%"),e=_e(),r=ne(),n=pe(),o=function(){if(me)return ge;me=1;var t=A$1,e=fe(),r=ue();return ge=function(n){return void 0!==n&&(r(e,"Property Descriptor","Desc",n),!(!t(n,"[[Get]]")&&!t(n,"[[Set]]")))}}(),i=le(),a=ye(),u=be(),c=We(),s=fe();return De=function(f,p,l){if("Object"!==s(f))throw new t("Assertion failed: Type(O) is not Object");if(!a(p))throw new t("Assertion failed: IsPropertyKey(P) is not true");var y=e({Type:s,IsDataDescriptor:i,IsAccessorDescriptor:o},l)?l:c(l);if(!e({Type:s,IsDataDescriptor:i,IsAccessorDescriptor:o},y))throw new t("Assertion failed: Desc is not a valid Property Descriptor");return r(i,u,n,f,p,y)}}(),qe=ye(),Je=fe();var Ke=Y$1("%TypeError%"),Xe=function(){if($e)return Ue;$e=1;var t=Y$1("%Object.setPrototypeOf%",!0),e=v$1();return Ue=t||(e?function(t,e){return t.__proto__=e,t}:null),Ue}(),Ye=function(){if(ze)return Ge;ze=1;var t=Y$1("%TypeError%"),e=function(){if(Be)return Ve;Be=1;var t=Y$1("%Object.getPrototypeOf%",!0),e=v$1();return Ve=t||(e?function(t){return t.__proto__}:null)}(),r=fe();return Ge=function(n){if("Object"!==r(n))throw new t("Assertion failed: O must be an Object");if(!e)throw new t("This environment does not support fetching prototypes.");return e(n)}}(),Ze=fe(),Qe=function(t,e,r){if("Object"!==Me(t))throw new xe("Assertion failed: Type(O) is not Object");if(!Ce(e))throw new xe("Assertion failed: IsPropertyKey(P) is not true");return Ie(Re,Fe,ke,t,e,{"[[Configurable]]":!0,"[[Enumerable]]":!1,"[[Value]]":r,"[[Writable]]":!0})},tr=function(t,e,r){if("Object"!==Je(t))throw new Le("Assertion failed: Type(O) is not Object");if(!qe(e))throw new Le("Assertion failed: IsPropertyKey(P) is not true");return He(t,e,{"[[Configurable]]":!0,"[[Enumerable]]":!1,"[[Value]]":r,"[[Writable]]":!0})},er=function(t,e){if("Object"!==Ze(e)&&"Null"!==Ze(e))throw new Ke("Assertion failed: V must be Object or Null");try{Xe(t,e);}catch(t){return !1}return Ye(t)===e},rr=Y$1,nr=tt(),or=rr("%Error%");function ir(t,e,r){var n=new or(r);return er(n,ar),delete n.constructor,tr(n,"error",t),tr(n,"suppressed",e),n}nr&&Object.defineProperty(ir,"prototype",{writable:!1});var ar=ir.prototype;if(!Qe(ar,"constructor",ir)||!Qe(ar,"message","")||!Qe(ar,"name","SuppressedError"))throw new or("unable to install SuppressedError.prototype properties; please report this!");er(ir.prototype,Error.prototype);var ur,cr,sr,fr,pr,lr,yr,br,dr,hr,gr,mr,vr,wr,Sr,jr,Or,Ar,Pr=ir,Er=function(){return "function"==typeof SuppressedError?SuppressedError:Pr},Dr=ft,Tr=Zt(),xr=Er;function Ir(){if(cr)return ur;cr=1;var t=se();return ur=function(e){return "symbol"==typeof e?"Symbol":"bigint"==typeof e?"BigInt":t(e)}}function kr(){if(fr)return sr;fr=1;var t=ue(),e=ce(),r=Ir();return sr=function(n){return void 0!==n&&t(r,"Property Descriptor","Desc",n),e(n)}}function Rr(){if(br)return yr;br=1;var t=A$1,e=Ir(),r=ue();return yr=function(n){return void 0!==n&&(r(e,"Property Descriptor","Desc",n),!(!t(n,"[[Value]]")&&!t(n,"[[Writable]]")))}}function Cr(){return hr?dr:(hr=1,dr=function(t){return "string"==typeof t||"symbol"==typeof t})}function Fr(){if(mr)return gr;mr=1;var t=oe();return gr=function(e,r){return e===r?0!==e||1/e==1/r:t(e)&&t(r)}}function Mr(){return wr?vr:(wr=1,vr=function(t){return !!t})}function _r(){return jr?Sr:(jr=1,Sr=Ne())}!function(){var t=xr();Dr(Tr,{SuppressedError:t},{SuppressedError:function(){return Tr.SuppressedError!==t}});}();var Nr,Wr,Ur,$r,Vr,Br,Gr=Y$1("%TypeError%"),zr=_e(),Lr=ne(),Hr=kr(),qr=function(){if(lr)return pr;lr=1;var t=A$1,e=Ir(),r=ue();return pr=function(n){return void 0!==n&&(r(e,"Property Descriptor","Desc",n),!(!t(n,"[[Get]]")&&!t(n,"[[Set]]")))}}(),Jr=Rr(),Kr=Cr(),Xr=Fr(),Yr=function(){if(Ar)return Or;Ar=1;var t=A$1,e=Y$1("%TypeError%"),r=Ir(),n=Mr(),o=_r();return Or=function(i){if("Object"!==r(i))throw new e("ToPropertyDescriptor requires an object");var a={};if(t(i,"enumerable")&&(a["[[Enumerable]]"]=n(i.enumerable)),t(i,"configurable")&&(a["[[Configurable]]"]=n(i.configurable)),t(i,"value")&&(a["[[Value]]"]=i.value),t(i,"writable")&&(a["[[Writable]]"]=n(i.writable)),t(i,"get")){var u=i.get;if(void 0!==u&&!o(u))throw new e("getter must be a function");a["[[Get]]"]=u;}if(t(i,"set")){var c=i.set;if(void 0!==c&&!o(c))throw new e("setter must be a function");a["[[Set]]"]=c;}if((t(a,"[[Get]]")||t(a,"[[Set]]"))&&(t(a,"[[Value]]")||t(a,"[[Writable]]")))throw new e("Invalid property descriptor. Cannot both specify accessors and a value or writable attribute");return a}}(),Zr=Ir(),Qr=function(t,e,r){if("Object"!==Zr(t))throw new Gr("Assertion failed: Type(O) is not Object");if(!Kr(e))throw new Gr("Assertion failed: IsPropertyKey(P) is not true");var n=zr({Type:Zr,IsDataDescriptor:Jr,IsAccessorDescriptor:qr},r)?r:Yr(r);if(!zr({Type:Zr,IsDataDescriptor:Jr,IsAccessorDescriptor:qr},n))throw new Gr("Assertion failed: Desc is not a valid Property Descriptor");return Lr(Jr,Xr,Hr,t,e,n)},tn$1=y$1()?Symbol.dispose||Symbol("Symbol.dispose"):null,en$1=y$1,rn$1=tn$1,nn$1=function(){return en$1()&&Symbol.dispose||rn$1},on$1=h$1,an$1=Qr,un$1=nn$1,cn$1=y$1()?Symbol.asyncDispose||Symbol("Symbol.asyncDispose"):null,sn$1=y$1,fn$1=cn$1,pn$1=function(){return sn$1()&&Symbol.asyncDispose||fn$1},ln$1=h$1,yn$1=Qr,bn$1=pn$1;function dn$1(){return Wr?Nr:(Wr=1,Nr=re())}function hn$1(){if($r)return Ur;$r=1;var t=Y$1,e=ee(),r=t("%TypeError%"),n=dn$1(),o=t("%Reflect.apply%",!0)||e("Function.prototype.apply");return Ur=function(t,e){var i=arguments.length>2?arguments[2]:[];if(!n(i))throw new r("Assertion failed: optional `argumentsList`, if provided, must be a List");return o(t,e,i)},Ur}function gn$1(){if(Br)return Vr;Br=1;var t=Y$1("%TypeError%"),e=ne(),r=kr(),n=Rr(),o=Cr(),i=Fr(),a=Ir();return Vr=function(u,c,s){if("Object"!==a(u))throw new t("Assertion failed: Type(O) is not Object");if(!o(c))throw new t("Assertion failed: IsPropertyKey(P) is not true");return e(n,i,r,u,c,{"[[Configurable]]":!0,"[[Enumerable]]":!1,"[[Value]]":s,"[[Writable]]":!0})}}function mn$1(){throw new Error("setTimeout has not been defined")}function vn$1(){throw new Error("clearTimeout has not been defined")}var wn$1=mn$1,Sn$1=vn$1;function jn$1(t){if(wn$1===setTimeout)return setTimeout(t,0);if((wn$1===mn$1||!wn$1)&&setTimeout)return wn$1=setTimeout,setTimeout(t,0);try{return wn$1(t,0)}catch(e){try{return wn$1.call(null,t,0)}catch(e){return wn$1.call(this,t,0)}}}"function"==typeof commonjsGlobal.setTimeout&&(wn$1=setTimeout),"function"==typeof commonjsGlobal.clearTimeout&&(Sn$1=clearTimeout);var On$1,An$1=[],Pn$1=!1,En$1=-1;function Dn(){Pn$1&&On$1&&(Pn$1=!1,On$1.length?An$1=On$1.concat(An$1):En$1=-1,An$1.length&&Tn$1());}function Tn$1(){if(!Pn$1){var t=jn$1(Dn);Pn$1=!0;for(var e=An$1.length;e;){for(On$1=An$1,An$1=[];++En$1<e;)On$1&&On$1[En$1].run();En$1=-1,e=An$1.length;}On$1=null,Pn$1=!1,function(t){if(Sn$1===clearTimeout)return clearTimeout(t);if((Sn$1===vn$1||!Sn$1)&&clearTimeout)return Sn$1=clearTimeout,clearTimeout(t);try{return Sn$1(t)}catch(e){try{return Sn$1.call(null,t)}catch(e){return Sn$1.call(this,t)}}}(t);}}function xn$1(t,e){this.fun=t,this.array=e;}xn$1.prototype.run=function(){this.fun.apply(null,this.array);};function In$1(){}var kn$1=In$1,Rn=In$1,Cn=In$1,Fn=In$1,Mn=In$1,_n$1=In$1,Nn=In$1;var Wn=commonjsGlobal.performance||{},Un=Wn.now||Wn.mozNow||Wn.msNow||Wn.oNow||Wn.webkitNow||function(){return (new Date).getTime()};var $n=new Date;var Vn={nextTick:function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)e[r-1]=arguments[r];An$1.push(new xn$1(t,e)),1!==An$1.length||Pn$1||jn$1(Tn$1);},title:"browser",browser:!0,env:{},argv:[],version:"",versions:{},on:kn$1,addListener:Rn,once:Cn,off:Fn,removeListener:Mn,removeAllListeners:_n$1,emit:Nn,binding:function(t){throw new Error("process.binding is not supported")},cwd:function(){return "/"},chdir:function(t){throw new Error("process.chdir is not supported")},umask:function(){return 0},hrtime:function(t){var e=.001*Un.call(Wn),r=Math.floor(e),n=Math.floor(e%1*1e9);return t&&(r-=t[0],(n-=t[1])<0&&(r--,n+=1e9)),[r,n]},platform:"browser",release:{},config:{},uptime:function(){return (new Date-$n)/1e3}},Bn="function"==typeof Object.create?function(t,e){t.super_=e,t.prototype=Object.create(e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}});}:function(t,e){t.super_=e;var r=function(){};r.prototype=e.prototype,t.prototype=new r,t.prototype.constructor=t;},Gn=Object.getOwnPropertyDescriptors||function(t){for(var e=Object.keys(t),r={},n=0;n<e.length;n++)r[e[n]]=Object.getOwnPropertyDescriptor(t,e[n]);return r},zn$1=/%[sdj%]/g;function Ln(t){if(!uo(t)){for(var e=[],r=0;r<arguments.length;r++)e.push(Xn(arguments[r]));return e.join(" ")}r=1;for(var n=arguments,o=n.length,i=String(t).replace(zn$1,(function(t){if("%%"===t)return "%";if(r>=o)return t;switch(t){case"%s":return String(n[r++]);case"%d":return Number(n[r++]);case"%j":try{return JSON.stringify(n[r++])}catch(t){return "[Circular]"}default:return t}})),a=n[r];r<o;a=n[++r])oo(a)||!po(a)?i+=" "+a:i+=" "+Xn(a);return i}function Hn(t,e){if(so(commonjsGlobal.process))return function(){return Hn(t,e).apply(this,arguments)};if(!0===Vn.noDeprecation)return t;var r=!1;return function(){if(!r){if(Vn.throwDeprecation)throw new Error(e);Vn.traceDeprecation?console.trace(e):console.error(e),r=!0;}return t.apply(this,arguments)}}var qn,Jn={};function Kn(t){if(so(qn)&&(qn=Vn.env.NODE_DEBUG||""),t=t.toUpperCase(),!Jn[t])if(new RegExp("\\b"+t+"\\b","i").test(qn)){Jn[t]=function(){var e=Ln.apply(null,arguments);console.error("%s %d: %s",t,0,e);};}else Jn[t]=function(){};return Jn[t]}function Xn(t,e){var r={seen:[],stylize:Zn};return arguments.length>=3&&(r.depth=arguments[2]),arguments.length>=4&&(r.colors=arguments[3]),no(e)?r.showHidden=e:e&&jo(r,e),so(r.showHidden)&&(r.showHidden=!1),so(r.depth)&&(r.depth=2),so(r.colors)&&(r.colors=!1),so(r.customInspect)&&(r.customInspect=!0),r.colors&&(r.stylize=Yn),Qn(r,t,r.depth)}function Yn(t,e){var r=Xn.styles[e];return r?"["+Xn.colors[r][0]+"m"+t+"["+Xn.colors[r][1]+"m":t}function Zn(t,e){return t}function Qn(t,e,r){if(t.customInspect&&e&&bo(e.inspect)&&e.inspect!==Xn&&(!e.constructor||e.constructor.prototype!==e)){var n=e.inspect(r,t);return uo(n)||(n=Qn(t,n,r)),n}var o=function(t,e){if(so(e))return t.stylize("undefined","undefined");if(uo(e)){var r="'"+JSON.stringify(e).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return t.stylize(r,"string")}if(ao(e))return t.stylize(""+e,"number");if(no(e))return t.stylize(""+e,"boolean");if(oo(e))return t.stylize("null","null")}(t,e);if(o)return o;var i=Object.keys(e),a=function(t){var e={};return t.forEach((function(t,r){e[t]=!0;})),e}(i);if(t.showHidden&&(i=Object.getOwnPropertyNames(e)),yo(e)&&(i.indexOf("message")>=0||i.indexOf("description")>=0))return to(e);if(0===i.length){if(bo(e)){var u=e.name?": "+e.name:"";return t.stylize("[Function"+u+"]","special")}if(fo(e))return t.stylize(RegExp.prototype.toString.call(e),"regexp");if(lo(e))return t.stylize(Date.prototype.toString.call(e),"date");if(yo(e))return to(e)}var c,s="",f=!1,p=["{","}"];(ro(e)&&(f=!0,p=["[","]"]),bo(e))&&(s=" [Function"+(e.name?": "+e.name:"")+"]");return fo(e)&&(s=" "+RegExp.prototype.toString.call(e)),lo(e)&&(s=" "+Date.prototype.toUTCString.call(e)),yo(e)&&(s=" "+to(e)),0!==i.length||f&&0!=e.length?r<0?fo(e)?t.stylize(RegExp.prototype.toString.call(e),"regexp"):t.stylize("[Object]","special"):(t.seen.push(e),c=f?function(t,e,r,n,o){for(var i=[],a=0,u=e.length;a<u;++a)Oo(e,String(a))?i.push(eo(t,e,r,n,String(a),!0)):i.push("");return o.forEach((function(o){o.match(/^\d+$/)||i.push(eo(t,e,r,n,o,!0));})),i}(t,e,r,a,i):i.map((function(n){return eo(t,e,r,a,n,f)})),t.seen.pop(),function(t,e,r){var n=t.reduce((function(t,e){return e.indexOf("\n"),t+e.replace(/\u001b\[\d\d?m/g,"").length+1}),0);if(n>60)return r[0]+(""===e?"":e+"\n ")+" "+t.join(",\n  ")+" "+r[1];return r[0]+e+" "+t.join(", ")+" "+r[1]}(c,s,p)):p[0]+s+p[1]}function to(t){return "["+Error.prototype.toString.call(t)+"]"}function eo(t,e,r,n,o,i){var a,u,c;if((c=Object.getOwnPropertyDescriptor(e,o)||{value:e[o]}).get?u=c.set?t.stylize("[Getter/Setter]","special"):t.stylize("[Getter]","special"):c.set&&(u=t.stylize("[Setter]","special")),Oo(n,o)||(a="["+o+"]"),u||(t.seen.indexOf(c.value)<0?(u=oo(r)?Qn(t,c.value,null):Qn(t,c.value,r-1)).indexOf("\n")>-1&&(u=i?u.split("\n").map((function(t){return "  "+t})).join("\n").substr(2):"\n"+u.split("\n").map((function(t){return "   "+t})).join("\n")):u=t.stylize("[Circular]","special")),so(a)){if(i&&o.match(/^\d+$/))return u;(a=JSON.stringify(""+o)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)?(a=a.substr(1,a.length-2),a=t.stylize(a,"name")):(a=a.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'"),a=t.stylize(a,"string"));}return a+": "+u}function ro(t){return Array.isArray(t)}function no(t){return "boolean"==typeof t}function oo(t){return null===t}function io(t){return null==t}function ao(t){return "number"==typeof t}function uo(t){return "string"==typeof t}function co(t){return "symbol"==typeof t}function so(t){return void 0===t}function fo(t){return po(t)&&"[object RegExp]"===mo(t)}function po(t){return "object"==typeof t&&null!==t}function lo(t){return po(t)&&"[object Date]"===mo(t)}function yo(t){return po(t)&&("[object Error]"===mo(t)||t instanceof Error)}function bo(t){return "function"==typeof t}function ho(t){return null===t||"boolean"==typeof t||"number"==typeof t||"string"==typeof t||"symbol"==typeof t||void 0===t}function go(t){return Buffer.isBuffer(t)}function mo(t){return Object.prototype.toString.call(t)}function vo(t){return t<10?"0"+t.toString(10):t.toString(10)}Xn.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},Xn.styles={special:"cyan",number:"yellow",boolean:"yellow",undefined:"grey",null:"bold",string:"green",date:"magenta",regexp:"red"};var wo=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];function So(){var t,e;console.log("%s - %s",(t=new Date,e=[vo(t.getHours()),vo(t.getMinutes()),vo(t.getSeconds())].join(":"),[t.getDate(),wo[t.getMonth()],e].join(" ")),Ln.apply(null,arguments));}function jo(t,e){if(!e||!po(e))return t;for(var r=Object.keys(e),n=r.length;n--;)t[r[n]]=e[r[n]];return t}function Oo(t,e){return Object.prototype.hasOwnProperty.call(t,e)}var Ao="undefined"!=typeof Symbol?Symbol("util.promisify.custom"):void 0;function Po(t){if("function"!=typeof t)throw new TypeError('The "original" argument must be of type Function');if(Ao&&t[Ao]){var e;if("function"!=typeof(e=t[Ao]))throw new TypeError('The "util.promisify.custom" argument must be of type Function');return Object.defineProperty(e,Ao,{value:e,enumerable:!1,writable:!1,configurable:!0}),e}function e(){for(var e,r,n=new Promise((function(t,n){e=t,r=n;})),o=[],i=0;i<arguments.length;i++)o.push(arguments[i]);o.push((function(t,n){t?r(t):e(n);}));try{t.apply(this,o);}catch(t){r(t);}return n}return Object.setPrototypeOf(e,Object.getPrototypeOf(t)),Ao&&Object.defineProperty(e,Ao,{value:e,enumerable:!1,writable:!1,configurable:!0}),Object.defineProperties(e,Gn(t))}function Eo(t,e){if(!t){var r=new Error("Promise was rejected with a falsy value");r.reason=t,t=r;}return e(t)}function Do(t){if("function"!=typeof t)throw new TypeError('The "original" argument must be of type Function');function e(){for(var e=[],r=0;r<arguments.length;r++)e.push(arguments[r]);var n=e.pop();if("function"!=typeof n)throw new TypeError("The last argument must be of type Function");var o=this,i=function(){return n.apply(o,arguments)};t.apply(this,e).then((function(t){Vn.nextTick(i.bind(null,null,t));}),(function(t){Vn.nextTick(Eo.bind(null,t,i));}));}return Object.setPrototypeOf(e,Object.getPrototypeOf(t)),Object.defineProperties(e,Gn(t)),e}Po.custom=Ao;var To,xo,Io,ko,Ro,Co,Fo,Mo,_o,No,Wo,Uo,$o,Vo,Bo,Go,zo,Lo,Ho,qo,Jo,Ko,Xo,Yo,Zo,Qo,ti,ei,ri,ni,oi,ii,ai,ui,ci,si,fi={inherits:Bn,_extend:jo,log:So,isBuffer:go,isPrimitive:ho,isFunction:bo,isError:yo,isDate:lo,isObject:po,isRegExp:fo,isUndefined:so,isSymbol:co,isString:uo,isNumber:ao,isNullOrUndefined:io,isNull:oo,isBoolean:no,isArray:ro,inspect:Xn,deprecate:Hn,format:Ln,debuglog:Kn,promisify:Po,callbackify:Do},pi=e$1(Object.freeze({__proto__:null,_extend:jo,callbackify:Do,debuglog:Kn,default:fi,deprecate:Hn,format:Ln,inherits:Bn,inspect:Xn,isArray:ro,isBoolean:no,isBuffer:go,isDate:lo,isError:yo,isFunction:bo,isNull:oo,isNullOrUndefined:io,isNumber:ao,isObject:po,isPrimitive:ho,isRegExp:fo,isString:uo,isSymbol:co,isUndefined:so,log:So,promisify:Po}));function li(){if(ko)return Io;ko=1;var t="function"==typeof Map&&Map.prototype,e=Object.getOwnPropertyDescriptor&&t?Object.getOwnPropertyDescriptor(Map.prototype,"size"):null,r=t&&e&&"function"==typeof e.get?e.get:null,n=t&&Map.prototype.forEach,o="function"==typeof Set&&Set.prototype,i=Object.getOwnPropertyDescriptor&&o?Object.getOwnPropertyDescriptor(Set.prototype,"size"):null,a=o&&i&&"function"==typeof i.get?i.get:null,u=o&&Set.prototype.forEach,c="function"==typeof WeakMap&&WeakMap.prototype?WeakMap.prototype.has:null,s="function"==typeof WeakSet&&WeakSet.prototype?WeakSet.prototype.has:null,f="function"==typeof WeakRef&&WeakRef.prototype?WeakRef.prototype.deref:null,p=Boolean.prototype.valueOf,l=Object.prototype.toString,y=Function.prototype.toString,b=String.prototype.match,d=String.prototype.slice,h=String.prototype.replace,g=String.prototype.toUpperCase,m=String.prototype.toLowerCase,v=RegExp.prototype.test,w=Array.prototype.concat,S=Array.prototype.join,j=Array.prototype.slice,O=Math.floor,A="function"==typeof BigInt?BigInt.prototype.valueOf:null,P=Object.getOwnPropertySymbols,E="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?Symbol.prototype.toString:null,D="function"==typeof Symbol&&"object"==typeof Symbol.iterator,T="function"==typeof Symbol&&Symbol.toStringTag&&(typeof Symbol.toStringTag===D||"symbol")?Symbol.toStringTag:null,x=Object.prototype.propertyIsEnumerable,I=("function"==typeof Reflect?Reflect.getPrototypeOf:Object.getPrototypeOf)||([].__proto__===Array.prototype?function(t){return t.__proto__}:null);function k(t,e){if(t===1/0||t===-1/0||t!=t||t&&t>-1e3&&t<1e3||v.call(/e/,e))return e;var r=/[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;if("number"==typeof t){var n=t<0?-O(-t):O(t);if(n!==t){var o=String(n),i=d.call(e,o.length+1);return h.call(o,r,"$&_")+"."+h.call(h.call(i,/([0-9]{3})/g,"$&_"),/_$/,"")}}return h.call(e,r,"$&_")}var R=xo?To:(xo=1,To=pi.inspect),C=R.custom,F=U(C)?C:null;function M(t,e,r){var n="double"===(r.quoteStyle||e)?'"':"'";return n+t+n}function _(t){return h.call(String(t),/"/g,"&quot;")}function N(t){return !("[object Array]"!==B(t)||T&&"object"==typeof t&&T in t)}function W(t){return !("[object RegExp]"!==B(t)||T&&"object"==typeof t&&T in t)}function U(t){if(D)return t&&"object"==typeof t&&t instanceof Symbol;if("symbol"==typeof t)return !0;if(!t||"object"!=typeof t||!E)return !1;try{return E.call(t),!0}catch(t){}return !1}Io=function t(e,o,i,l){var g=o||{};if(V(g,"quoteStyle")&&"single"!==g.quoteStyle&&"double"!==g.quoteStyle)throw new TypeError('option "quoteStyle" must be "single" or "double"');if(V(g,"maxStringLength")&&("number"==typeof g.maxStringLength?g.maxStringLength<0&&g.maxStringLength!==1/0:null!==g.maxStringLength))throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');var v=!V(g,"customInspect")||g.customInspect;if("boolean"!=typeof v&&"symbol"!==v)throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");if(V(g,"indent")&&null!==g.indent&&"\t"!==g.indent&&!(parseInt(g.indent,10)===g.indent&&g.indent>0))throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');if(V(g,"numericSeparator")&&"boolean"!=typeof g.numericSeparator)throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');var O=g.numericSeparator;if(void 0===e)return "undefined";if(null===e)return "null";if("boolean"==typeof e)return e?"true":"false";if("string"==typeof e)return z(e,g);if("number"==typeof e){if(0===e)return 1/0/e>0?"0":"-0";var P=String(e);return O?k(e,P):P}if("bigint"==typeof e){var C=String(e)+"n";return O?k(e,C):C}var $=void 0===g.depth?5:g.depth;if(void 0===i&&(i=0),i>=$&&$>0&&"object"==typeof e)return N(e)?"[Array]":"[Object]";var L=function(t,e){var r;if("\t"===t.indent)r="\t";else {if(!("number"==typeof t.indent&&t.indent>0))return null;r=S.call(Array(t.indent+1)," ");}return {base:r,prev:S.call(Array(e+1),r)}}(g,i);if(void 0===l)l=[];else if(G(l,e)>=0)return "[Circular]";function Y(e,r,n){if(r&&(l=j.call(l)).push(r),n){var o={depth:g.depth};return V(g,"quoteStyle")&&(o.quoteStyle=g.quoteStyle),t(e,o,i+1,l)}return t(e,g,i+1,l)}if("function"==typeof e&&!W(e)){var Z=function(t){if(t.name)return t.name;var e=b.call(y.call(t),/^function\s*([\w$]+)/);if(e)return e[1];return null}(e),Q=X(e,Y);return "[Function"+(Z?": "+Z:" (anonymous)")+"]"+(Q.length>0?" { "+S.call(Q,", ")+" }":"")}if(U(e)){var tt=D?h.call(String(e),/^(Symbol\(.*\))_[^)]*$/,"$1"):E.call(e);return "object"!=typeof e||D?tt:H(tt)}if(function(t){if(!t||"object"!=typeof t)return !1;if("undefined"!=typeof HTMLElement&&t instanceof HTMLElement)return !0;return "string"==typeof t.nodeName&&"function"==typeof t.getAttribute}(e)){for(var et="<"+m.call(String(e.nodeName)),rt=e.attributes||[],nt=0;nt<rt.length;nt++)et+=" "+rt[nt].name+"="+M(_(rt[nt].value),"double",g);return et+=">",e.childNodes&&e.childNodes.length&&(et+="..."),et+="</"+m.call(String(e.nodeName))+">"}if(N(e)){if(0===e.length)return "[]";var ot=X(e,Y);return L&&!function(t){for(var e=0;e<t.length;e++)if(G(t[e],"\n")>=0)return !1;return !0}(ot)?"["+K(ot,L)+"]":"[ "+S.call(ot,", ")+" ]"}if(function(t){return !("[object Error]"!==B(t)||T&&"object"==typeof t&&T in t)}(e)){var it=X(e,Y);return "cause"in Error.prototype||!("cause"in e)||x.call(e,"cause")?0===it.length?"["+String(e)+"]":"{ ["+String(e)+"] "+S.call(it,", ")+" }":"{ ["+String(e)+"] "+S.call(w.call("[cause]: "+Y(e.cause),it),", ")+" }"}if("object"==typeof e&&v){if(F&&"function"==typeof e[F]&&R)return R(e,{depth:$-i});if("symbol"!==v&&"function"==typeof e.inspect)return e.inspect()}if(function(t){if(!r||!t||"object"!=typeof t)return !1;try{r.call(t);try{a.call(t);}catch(t){return !0}return t instanceof Map}catch(t){}return !1}(e)){var at=[];return n&&n.call(e,(function(t,r){at.push(Y(r,e,!0)+" => "+Y(t,e));})),J("Map",r.call(e),at,L)}if(function(t){if(!a||!t||"object"!=typeof t)return !1;try{a.call(t);try{r.call(t);}catch(t){return !0}return t instanceof Set}catch(t){}return !1}(e)){var ut=[];return u&&u.call(e,(function(t){ut.push(Y(t,e));})),J("Set",a.call(e),ut,L)}if(function(t){if(!c||!t||"object"!=typeof t)return !1;try{c.call(t,c);try{s.call(t,s);}catch(t){return !0}return t instanceof WeakMap}catch(t){}return !1}(e))return q("WeakMap");if(function(t){if(!s||!t||"object"!=typeof t)return !1;try{s.call(t,s);try{c.call(t,c);}catch(t){return !0}return t instanceof WeakSet}catch(t){}return !1}(e))return q("WeakSet");if(function(t){if(!f||!t||"object"!=typeof t)return !1;try{return f.call(t),!0}catch(t){}return !1}(e))return q("WeakRef");if(function(t){return !("[object Number]"!==B(t)||T&&"object"==typeof t&&T in t)}(e))return H(Y(Number(e)));if(function(t){if(!t||"object"!=typeof t||!A)return !1;try{return A.call(t),!0}catch(t){}return !1}(e))return H(Y(A.call(e)));if(function(t){return !("[object Boolean]"!==B(t)||T&&"object"==typeof t&&T in t)}(e))return H(p.call(e));if(function(t){return !("[object String]"!==B(t)||T&&"object"==typeof t&&T in t)}(e))return H(Y(String(e)));if(!function(t){return !("[object Date]"!==B(t)||T&&"object"==typeof t&&T in t)}(e)&&!W(e)){var ct=X(e,Y),st=I?I(e)===Object.prototype:e instanceof Object||e.constructor===Object,ft=e instanceof Object?"":"null prototype",pt=!st&&T&&Object(e)===e&&T in e?d.call(B(e),8,-1):ft?"Object":"",lt=(st||"function"!=typeof e.constructor?"":e.constructor.name?e.constructor.name+" ":"")+(pt||ft?"["+S.call(w.call([],pt||[],ft||[]),": ")+"] ":"");return 0===ct.length?lt+"{}":L?lt+"{"+K(ct,L)+"}":lt+"{ "+S.call(ct,", ")+" }"}return String(e)};var $=Object.prototype.hasOwnProperty||function(t){return t in this};function V(t,e){return $.call(t,e)}function B(t){return l.call(t)}function G(t,e){if(t.indexOf)return t.indexOf(e);for(var r=0,n=t.length;r<n;r++)if(t[r]===e)return r;return -1}function z(t,e){if(t.length>e.maxStringLength){var r=t.length-e.maxStringLength,n="... "+r+" more character"+(r>1?"s":"");return z(d.call(t,0,e.maxStringLength),e)+n}return M(h.call(h.call(t,/(['\\])/g,"\\$1"),/[\x00-\x1f]/g,L),"single",e)}function L(t){var e=t.charCodeAt(0),r={8:"b",9:"t",10:"n",12:"f",13:"r"}[e];return r?"\\"+r:"\\x"+(e<16?"0":"")+g.call(e.toString(16))}function H(t){return "Object("+t+")"}function q(t){return t+" { ? }"}function J(t,e,r,n){return t+" ("+e+") {"+(n?K(r,n):S.call(r,", "))+"}"}function K(t,e){if(0===t.length)return "";var r="\n"+e.prev+e.base;return r+S.call(t,","+r)+"\n"+e.prev}function X(t,e){var r=N(t),n=[];if(r){n.length=t.length;for(var o=0;o<t.length;o++)n[o]=V(t,o)?e(t[o],t):"";}var i,a="function"==typeof P?P(t):[];if(D){i={};for(var u=0;u<a.length;u++)i["$"+a[u]]=a[u];}for(var c in t)V(t,c)&&(r&&String(Number(c))===c&&c<t.length||D&&i["$"+c]instanceof Symbol||(v.call(/[^\w$]/,c)?n.push(e(c,t)+": "+e(t[c],t)):n.push(c+": "+e(t[c],t))));if("function"==typeof P)for(var s=0;s<a.length;s++)x.call(t,a[s])&&n.push("["+e(a[s])+"]: "+e(t[a[s]],t));return n}return Io}function yi(){if(Co)return Ro;Co=1;var t=Y$1,e=ee(),r=li(),n=t("%TypeError%"),o=t("%WeakMap%",!0),i=t("%Map%",!0),a=e("WeakMap.prototype.get",!0),u=e("WeakMap.prototype.set",!0),c=e("WeakMap.prototype.has",!0),s=e("Map.prototype.get",!0),f=e("Map.prototype.set",!0),p=e("Map.prototype.has",!0),l=function(t,e){for(var r,n=t;null!==(r=n.next);n=r)if(r.key===e)return n.next=r.next,r.next=t.next,t.next=r,r};return Ro=function(){var t,e,y,b={assert:function(t){if(!b.has(t))throw new n("Side channel does not contain "+r(t))},get:function(r){if(o&&r&&("object"==typeof r||"function"==typeof r)){if(t)return a(t,r)}else if(i){if(e)return s(e,r)}else if(y)return function(t,e){var r=l(t,e);return r&&r.value}(y,r)},has:function(r){if(o&&r&&("object"==typeof r||"function"==typeof r)){if(t)return c(t,r)}else if(i){if(e)return p(e,r)}else if(y)return function(t,e){return !!l(t,e)}(y,r);return !1},set:function(r,n){o&&r&&("object"==typeof r||"function"==typeof r)?(t||(t=new o),u(t,r,n)):i?(e||(e=new i),f(e,r,n)):(y||(y={key:{},next:null}),function(t,e,r){var n=l(t,e);n?n.value=r:t.next={key:e,next:t.next,value:r};}(y,r,n));}};return b}}function bi(){if(Mo)return Fo;Mo=1;var t=Y$1,e=A$1,r=yi()(),n=t("%TypeError%"),o={assert:function(t,e){if(!t||"object"!=typeof t&&"function"!=typeof t)throw new n("`O` is not an object");if("string"!=typeof e)throw new n("`slot` must be a string");if(r.assert(t),!o.has(t,e))throw new n("`"+e+"` is not present on `O`")},get:function(t,e){if(!t||"object"!=typeof t&&"function"!=typeof t)throw new n("`O` is not an object");if("string"!=typeof e)throw new n("`slot` must be a string");var o=r.get(t);return o&&o["$"+e]},has:function(t,o){if(!t||"object"!=typeof t&&"function"!=typeof t)throw new n("`O` is not an object");if("string"!=typeof o)throw new n("`slot` must be a string");var i=r.get(t);return !!i&&e(i,"$"+o)},set:function(t,e,o){if(!t||"object"!=typeof t&&"function"!=typeof t)throw new n("`O` is not an object");if("string"!=typeof e)throw new n("`slot` must be a string");var i=r.get(t);i||(i={},r.set(t,i)),i["$"+e]=o;}};return Object.freeze&&Object.freeze(o),Fo=o}function di(){if(No)return _o;No=1;var t=Y$1("%SyntaxError%"),e=bi(),r=function r(n,o){if(!(this instanceof r))return new r(n,o);if("normal"!==n&&"break"!==n&&"continue"!==n&&"return"!==n&&"throw"!==n)throw new t('Assertion failed: `type` must be one of "normal", "break", "continue", "return", or "throw"');e.set(this,"[[Type]]",n),e.set(this,"[[Value]]",o);};return r.prototype.type=function(){return e.get(this,"[[Type]]")},r.prototype.value=function(){return e.get(this,"[[Value]]")},r.prototype["?"]=function(){var r=e.get(this,"[[Type]]"),n=e.get(this,"[[Value]]");if("normal"===r)return n;if("throw"===r)throw n;throw new t('Completion Record is not of type "normal" or "throw": other types not supported')},r.prototype["!"]=function(){if("normal"!==e.get(this,"[[Type]]"))throw new t('Assertion failed: Completion Record is not of type "normal"');return e.get(this,"[[Value]]")},_o=r}function hi(){if(Uo)return Wo;Uo=1;var t=di();return Wo=function(e){return new t("normal",e)}}function gi(){if(Go)return Bo;Go=1;var t=Y$1("%Object.defineProperty%",!0),e=function(){if(Vo)return $o;Vo=1;var t=y$1;return $o=function(){return t()&&!!Symbol.toStringTag}}()(),r=A$1,n=e?Symbol.toStringTag:null;return Bo=function(e,o){var i=arguments.length>2&&arguments[2]&&arguments[2].force;!n||!i&&r(e,n)||(t?t(e,n,{configurable:!0,enumerable:!1,value:o,writable:!1}):e[n]=o);},Bo}function mi(){if(Lo)return zo;Lo=1;var t=Y$1("%TypeError%"),e=li(),r=Cr();return zo=function(n,o){if(!r(o))throw new t("Assertion failed: IsPropertyKey(P) is not true, got "+e(o));return n[o]}}function vi(){if(qo)return Ho;qo=1;var t=Y$1("%TypeError%"),e=mi(),r=_r(),n=Cr(),o=li();return Ho=function(i,a){if(!n(a))throw new t("Assertion failed: IsPropertyKey(P) is not true");var u=e(i,a);if(null!=u){if(!r(u))throw new t(o(a)+" is not a function: "+o(u));return u}}}function wi(){if(Ko)return Jo;Ko=1;var t=Y$1,e=t("%SyntaxError%"),r=t("%TypeError%"),n=vi(),o=Ir(),i=nn$1(),a=pn$1();return Jo=function(t,u){if("Object"!==o(t))throw new r("`V` must be an Object");if("sync-dispose"!==u&&"async-dispose"!==u)throw new e("Assertion failed: `hint` must be `'sync-dispose'` or `'async-dispose'`");var c;if("async-dispose"===u&&a&&(c=n(t,a)),!c){if(!i)throw new e("`Symbol.dispose` is not supported");c=n(t,i);}return c}}function Si(){if(Yo)return Xo;Yo=1;var t=Y$1,e=t("%SyntaxError%"),r=t("%TypeError%"),n=_r(),o=Ir(),i=wi();return Xo=function(t,a){if("sync-dispose"!==a&&"async-dispose"!==a)throw new e("Assertion failed: `hint` must be `'sync-dispose'` or `'async-dispose'`");if(void 0!==t&&"Object"!==o(t))throw new r("`V` must be an Object");var u;if(arguments.length<3){if(void 0===t)throw new r("`V` must not be `undefined` when `method` is not provided");if(void 0===(u=i(t,a)))throw new r("dispose method must not be `undefined` on `V` when an object `V` is provided")}else if(!n(u=arguments[2]))throw new r("`method`, when provided, must be a function");return {"[[ResourceValue]]":t,"[[Hint]]":a,"[[DisposeMethod]]":u}},Xo}function ji(){if(Qo)return Zo;Qo=1;var t=Y$1,e=t("%SyntaxError%"),r=t("%TypeError%"),n=Ir(),o=Si(),i=ee()("Array.prototype.push");return Zo=function(t,a,u){if("sync-dispose"!==u&&"async-dispose"!==u)throw new e("Assertion failed: `hint` must be `'sync-dispose'` or `'async-dispose'`");var c,s=arguments.length>3?arguments[3]:void 0;if(arguments.length>3&&"function"!=typeof s)throw new r("Assertion failed: `method`, when present, must be a function");if(!t["[[DisposableResourceStack]]"])throw new r("Assertion failed: `disposeCapability.[[DisposableResourceStack]]` must not be ~empty~");if(arguments.length<4){if(null==a)return "unused";if("Object"!==n(a))throw new r("`V` must be an Object");c=o(a,u);}else {if(void 0!==a)throw new r("Assertion failed: `V` must be undefined when `method` is present");c=o(void 0,u,s);}return i(t["[[DisposableResourceStack]]"],c),"unused"},Zo}function Oi(){if(ei)return ti;ei=1;var t=Y$1,e=te(),r=t("%Promise.resolve%",!0),n=r&&e(r);return ti=function(t,e){if(!n)throw new SyntaxError("This environment does not support Promises.");return n(t,e)}}function Ai(){if(ni)return ri;ni=1;var t=Y$1,e=t("%SyntaxError%"),r=t("%Promise%",!0),n=hn$1(),o=Oi(),i=Ir();return ri=function(t,a,u){if(void 0!==t&&"Object"!==i(t))throw new e("Assertion failed: `V` must be `undefined` or an Object");if("sync-dispose"!==a&&"async-dispose"!==a)throw new e("Assertion failed: `hint` must be `'sync-dispose'` or `'async-dispose'`");if(void 0!==u&&"function"!=typeof u)throw new e("Assertion failed: `method` must be `undefined` or a function");var c=n(u,t);if("async-dispose"===a)return o(r,c)}}function Pi(){if(ii)return oi;ii=1;var t=di();return oi=function(e){return new t("throw",e)}}function Ei(){if(ui)return ai;ui=1;var t=Y$1,e=t("%SyntaxError%"),r=t("%TypeError%"),n=t("%Promise%",!0),o=ee()("Promise.prototype.then",!0),i=di(),a=Ai(),u=hi(),c=Oi(),s=Pi(),f=Er();return ai=function(t,p){if(!(p instanceof i))throw new r("`completion` must be a Completion Record");var l,y=t["[[DisposableResourceStack]]"];if(!y)throw new r("Assertion failed: `disposeCapability.[[DisposableResourceStack]]` must not be ~empty~");for(var b=y.length-1;b>=0;b-=1)if(l){if(l!==y[b]["[[Hint]]"])throw new e("mixed hint stacks are not supported")}else l=y[b]["[[Hint]]"];for(var d="async-dispose"===l&&c(n,p),h=function(t){if("throw"===p.type()){var e=p.value(),r=new f(t,e);p=s(r);}else p=s(t);},g="async-dispose"===l&&function(t){return o(d,(function(){var r=a(t["[[ResourceValue]]"],t["[[Hint]]"],t["[[DisposeMethod]]"]);if(!r)throw new e("Assertion failed: non-`async-dispose` resource returned a promise from Dispose");return o(r,u)}),h)},m=y.length-1;m>=0;m-=1)if("async-dispose"===l)d=g(y[m]);else {var v=y[m];try{if(a(v["[[ResourceValue]]"],v["[[Hint]]"],v["[[DisposeMethod]]"]))throw new e("Assertion failed: `sync-dispose` resource returned something from Dispose")}catch(t){h(t);}}return t["[[DisposableResourceStack]]"]=null,"async-dispose"===l?d:p}}function Di(){return si?ci:(si=1,ci=function(){return {"[[DisposableResourceStack]]":[]}})}var Ti=Y$1,xi=Ti("%ReferenceError%"),Ii=Ti("%TypeError%"),ki=hn$1(),Ri=gn$1(),Ci=Qr,Fi=_r(),Mi=hi(),_i=bi(),Ni=gi(),Wi=ft.supportsDescriptors,Ui=te(),$i=ji(),Vi=Ei(),Bi=Di(),Gi=nn$1(),zi=function t(){if(!(this instanceof t)||_i.has(this,"[[DisposableState]]")||_i.has(this,"[[DisposeCapability]]"))throw new Ii("can only be used with new");_i.set(this,"[[DisposableState]]","pending"),_i.set(this,"[[DisposeCapability]]",Bi());},Li=function(){return _i.assert(this,"[[DisposableState]]"),"disposed"===_i.get(this,"[[DisposableState]]")},Hi=Ui(Li);Wi?Ci(zi.prototype,"disposed",{"[[Configurable]]":!0,"[[Enumerable]]":!0,"[[Get]]":Li}):zi.prototype.disposed=!1;var qi=function(t){_i.set(t,"[[DisposableState]]","disposed"),Wi||(t.disposed=!0);};Ri(zi.prototype,"dispose",(function(){var t=this;if(!Hi(t))return qi(t),Vi(_i.get(t,"[[DisposeCapability]]"),Mi())["?"]()})),Ri(zi.prototype,"use",(function(t){if(Hi(this))throw new xi("a disposed stack can not use anything new");return $i(_i.get(this,"[[DisposeCapability]]"),t,"sync-dispose"),t})),Ri(zi.prototype,"adopt",(function(t,e){if(Hi(this))throw new xi("a disposed stack can not use anything new");if(!Fi(e))throw new Ii("`onDispose` must be a function");return $i(_i.get(this,"[[DisposeCapability]]"),void 0,"sync-dispose",(function(){return ki(e,void 0,[t])})),t})),Ri(zi.prototype,"defer",(function(t){if(Hi(this))throw new xi("a disposed stack can not defer anything new");if(!Fi(t))throw new Ii("`onDispose` must be a function");$i(_i.get(this,"[[DisposeCapability]]"),void 0,"sync-dispose",t);})),Ri(zi.prototype,"move",(function(){var t=this;if(Hi(t))throw new xi("a disposed stack can not use anything new");var e=new zi;return _i.set(e,"[[DisposeCapability]]",_i.get(t,"[[DisposeCapability]]")),_i.set(t,"[[DisposeCapability]]",Bi()),qi(t),e})),Gi&&Ri(zi.prototype,Gi,zi.prototype.dispose),Ni(zi.prototype,"DisposableStack");var Ji=zi,Ki=ft,Xi=Zt(),Yi=function(){return "function"==typeof DisposableStack?DisposableStack:Ji},Zi=Y$1,Qi=Zi("%ReferenceError%"),ta=Zi("%TypeError%"),ea=Zi("%Promise%",!0),ra=ji(),na=hn$1(),oa=gn$1(),ia=Qr,aa=Ei(),ua=_r(),ca=Di(),sa=hi(),fa=Oi(),pa=bi(),la=gi(),ya=ft.supportsDescriptors,ba=te(),da=ee()("Promise.prototype.then",!0),ha=pn$1(),ga=function t(){if(!(this instanceof t)||pa.has(this,"[[AsyncDisposableState]]")||pa.has(this,"[[DisposeCapability]]"))throw new ta("can only be used with new");pa.set(this,"[[AsyncDisposableState]]","pending"),pa.set(this,"[[DisposeCapability]]",ca());},ma=function(){return pa.assert(this,"[[AsyncDisposableState]]"),"disposed"===pa.get(this,"[[AsyncDisposableState]]")},va=ba(ma);ya?ia(ga.prototype,"disposed",{"[[Configurable]]":!0,"[[Enumerable]]":!0,"[[Get]]":ma}):ga.prototype.disposed=!1;var wa=function(t){pa.set(t,"[[AsyncDisposableState]]","disposed"),ya||(t.disposed=!0);};oa(ga.prototype,"disposeAsync",(function(){var t=this;return va(t)?fa(ea):(wa(t),da(fa(ea,aa(pa.get(t,"[[DisposeCapability]]"),sa())),(function(t){return t["?"]()})))})),oa(ga.prototype,"use",(function(t){if(va(this))throw new Qi("a disposed stack can not use anything new");return ra(pa.get(this,"[[DisposeCapability]]"),t,"async-dispose"),t})),oa(ga.prototype,"adopt",(function(t,e){if(va(this))throw new Qi("a disposed stack can not use anything new");if(!ua(e))throw new ta("`onDisposeAsync` must be a function");var r=function(){return na(e,void 0,[t])};return r.value=t,ra(pa.get(this,"[[DisposeCapability]]"),void 0,"async-dispose",r),t})),oa(ga.prototype,"defer",(function(t){if(va(this))throw new Qi("a disposed stack can not defer anything new");if(!ua(t))throw new ta("`onDispose` must be a function");ra(pa.get(this,"[[DisposeCapability]]"),void 0,"async-dispose",t);})),oa(ga.prototype,"move",(function(){var t=this;if(va(t))throw new Qi("a disposed stack can not use anything new");var e=new ga;return pa.set(e,"[[DisposeCapability]]",pa.get(t,"[[DisposeCapability]]")),pa.set(t,"[[DisposeCapability]]",ca()),wa(t),e})),ha&&oa(ga.prototype,ha,ga.prototype.disposeAsync),la(ga.prototype,"AsyncDisposableStack");var Sa=ga,ja=ft,Oa=Zt(),Aa=function(){return "function"==typeof AsyncDisposableStack?AsyncDisposableStack:Sa},Pa=function(){var t=bn$1();return ln$1()&&yn$1(Symbol,"asyncDispose",{"[[Configurable]]":!1,"[[Enumerable]]":!1,"[[Writable]]":!1,"[[Value]]":t}),t},Ea=function(){var t=Yi();return Ki(Xi,{DisposableStack:t},{DisposableStack:!0}),t},Da=function(){var t=Aa();return ja(Oa,{AsyncDisposableStack:t},{AsyncDisposableStack:!0}),t};((function(){var t=un$1();on$1()&&an$1(Symbol,"dispose",{"[[Configurable]]":!1,"[[Enumerable]]":!1,"[[Writable]]":!1,"[[Value]]":t});}))(),Pa(),Ea(),Da();const Ta=globalThis.Symbol,xa=globalThis.DisposableStack,Ia=globalThis.AsyncDisposableStack;disposablestack.AsyncDisposableStack=Ia,disposablestack.DisposableStack=xa,disposablestack.Symbol=Ta;

var EventEmitter$1 = {};

var mitt=function(t){return {all:t=t||new Map,on:function(e,n){var i=t.get(e);i?i.push(n):t.set(e,[n]);},off:function(e,n){var i=t.get(e);i&&(n?i.splice(i.indexOf(n)>>>0,1):t.set(e,[]));},emit:function(e,n){var i=t.get(e);i&&i.slice().map((function(t){t(n);})),(i=t.get("*"))&&i.slice().map((function(t){t(e,n);}));}}};

/**
 * Copyright 2022 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault$4 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(EventEmitter$1, "__esModule", { value: true });
EventEmitter$1.EventEmitter = void 0;
const index_js_1 = __importDefault$4(mitt);
/**
 * The EventEmitter class that many Puppeteer classes extend.
 *
 * @remarks
 *
 * This allows you to listen to events that Puppeteer classes fire and act
 * accordingly. Therefore you'll mostly use {@link EventEmitter.on | on} and
 * {@link EventEmitter.off | off} to bind
 * and unbind to event listeners.
 *
 * @public
 */
class EventEmitter {
    emitter;
    eventsMap = new Map();
    /**
     * @internal
     */
    constructor() {
        this.emitter = (0, index_js_1.default)(this.eventsMap);
    }
    /**
     * Bind an event listener to fire when an event occurs.
     * @param event - the event type you'd like to listen to. Can be a string or symbol.
     * @param handler - the function to be called when the event occurs.
     * @returns `this` to enable you to chain method calls.
     */
    on(event, handler) {
        this.emitter.on(event, handler);
        return this;
    }
    /**
     * Remove an event listener from firing.
     * @param event - the event type you'd like to stop listening to.
     * @param handler - the function that should be removed.
     * @returns `this` to enable you to chain method calls.
     */
    off(event, handler) {
        this.emitter.off(event, handler);
        return this;
    }
    /**
     * Remove an event listener.
     * @deprecated please use {@link EventEmitter.off} instead.
     */
    removeListener(event, handler) {
        this.off(event, handler);
        return this;
    }
    /**
     * Add an event listener.
     * @deprecated please use {@link EventEmitter.on} instead.
     */
    addListener(event, handler) {
        this.on(event, handler);
        return this;
    }
    /**
     * Emit an event and call any associated listeners.
     *
     * @param event - the event you'd like to emit
     * @param eventData - any data you'd like to emit with the event
     * @returns `true` if there are any listeners, `false` if there are not.
     */
    emit(event, eventData) {
        this.emitter.emit(event, eventData);
        return this.eventListenersCount(event) > 0;
    }
    /**
     * Like `on` but the listener will only be fired once and then it will be removed.
     * @param event - the event you'd like to listen to
     * @param handler - the handler function to run when the event occurs
     * @returns `this` to enable you to chain method calls.
     */
    once(event, handler) {
        const onceHandler = eventData => {
            handler(eventData);
            this.off(event, onceHandler);
        };
        return this.on(event, onceHandler);
    }
    /**
     * Gets the number of listeners for a given event.
     *
     * @param event - the event to get the listener count for
     * @returns the number of listeners bound to the given event
     */
    listenerCount(event) {
        return this.eventListenersCount(event);
    }
    /**
     * Removes all listeners. If given an event argument, it will remove only
     * listeners for that event.
     * @param event - the event to remove listeners for.
     * @returns `this` to enable you to chain method calls.
     */
    removeAllListeners(event) {
        if (event) {
            this.eventsMap.delete(event);
        }
        else {
            this.eventsMap.clear();
        }
        return this;
    }
    eventListenersCount(event) {
        return this.eventsMap.get(event)?.length || 0;
    }
}
EventEmitter$1.EventEmitter = EventEmitter;

var util$1 = {};

var rxjs = {};

var n=function(t,r){return n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,t){n.__proto__=t;}||function(n,t){for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r]);},n(t,r)};function t(t,r){if("function"!=typeof r&&null!==r)throw new TypeError("Class extends value "+String(r)+" is not a constructor or null");function e(){this.constructor=t;}n(t,r),t.prototype=null===r?Object.create(r):(e.prototype=r.prototype,new e);}function r(n,t,r,e){return new(r||(r=Promise))((function(o,i){function u(n){try{s(e.next(n));}catch(n){i(n);}}function c(n){try{s(e.throw(n));}catch(n){i(n);}}function s(n){var t;n.done?o(n.value):(t=n.value,t instanceof r?t:new r((function(n){n(t);}))).then(u,c);}s((e=e.apply(n,t||[])).next());}))}function e(n,t){var r,e,o,i,u={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return i={next:c(0),throw:c(1),return:c(2)},"function"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function c(c){return function(s){return function(c){if(r)throw new TypeError("Generator is already executing.");for(;i&&(i=0,c[0]&&(u=0)),u;)try{if(r=1,e&&(o=2&c[0]?e.return:c[0]?e.throw||((o=e.return)&&o.call(e),0):e.next)&&!(o=o.call(e,c[1])).done)return o;switch(e=0,o&&(c=[2&c[0],o.value]),c[0]){case 0:case 1:o=c;break;case 4:return u.label++,{value:c[1],done:!1};case 5:u.label++,e=c[1],c=[0];continue;case 7:c=u.ops.pop(),u.trys.pop();continue;default:if(!(o=u.trys,(o=o.length>0&&o[o.length-1])||6!==c[0]&&2!==c[0])){u=0;continue}if(3===c[0]&&(!o||c[1]>o[0]&&c[1]<o[3])){u.label=c[1];break}if(6===c[0]&&u.label<o[1]){u.label=o[1],o=c;break}if(o&&u.label<o[2]){u.label=o[2],u.ops.push(c);break}o[2]&&u.ops.pop(),u.trys.pop();continue}c=t.call(n,u);}catch(n){c=[6,n],e=0;}finally{r=o=0;}if(5&c[0])throw c[1];return {value:c[0]?c[1]:void 0,done:!0}}([c,s])}}}function o(n){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&n[t],e=0;if(r)return r.call(n);if(n&&"number"==typeof n.length)return {next:function(){return n&&e>=n.length&&(n=void 0),{value:n&&n[e++],done:!n}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")}function i(n,t){var r="function"==typeof Symbol&&n[Symbol.iterator];if(!r)return n;var e,o,i=r.call(n),u=[];try{for(;(void 0===t||t-- >0)&&!(e=i.next()).done;)u.push(e.value);}catch(n){o={error:n};}finally{try{e&&!e.done&&(r=i.return)&&r.call(i);}finally{if(o)throw o.error}}return u}function u(n,t,r){if(r||2===arguments.length)for(var e,o=0,i=t.length;o<i;o++)!e&&o in t||(e||(e=Array.prototype.slice.call(t,0,o)),e[o]=t[o]);return n.concat(e||Array.prototype.slice.call(t))}function c(n){return this instanceof c?(this.v=n,this):new c(n)}function s(n,t,r){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var e,o=r.apply(n,t||[]),i=[];return e={},u("next"),u("throw"),u("return"),e[Symbol.asyncIterator]=function(){return this},e;function u(n){o[n]&&(e[n]=function(t){return new Promise((function(r,e){i.push([n,t,r,e])>1||s(n,t);}))});}function s(n,t){try{(r=o[n](t)).value instanceof c?Promise.resolve(r.value.v).then(l,a):f(i[0][2],r);}catch(n){f(i[0][3],n);}var r;}function l(n){s("next",n);}function a(n){s("throw",n);}function f(n,t){n(t),i.shift(),i.length&&s(i[0][0],i[0][1]);}}function l(n){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var t,r=n[Symbol.asyncIterator];return r?r.call(n):(n=o(n),t={},e("next"),e("throw"),e("return"),t[Symbol.asyncIterator]=function(){return this},t);function e(r){t[r]=n[r]&&function(t){return new Promise((function(e,o){(function(n,t,r,e){Promise.resolve(e).then((function(t){n({value:t,done:r});}),t);})(e,o,(t=n[r](t)).done,t.value);}))};}}function a(n){return "function"==typeof n}function f(n){var t=n((function(n){Error.call(n),n.stack=(new Error).stack;}));return t.prototype=Object.create(Error.prototype),t.prototype.constructor=t,t}"function"==typeof SuppressedError&&SuppressedError;var p=f((function(n){return function(t){n(this),this.message=t?t.length+" errors occurred during unsubscription:\n"+t.map((function(n,t){return t+1+") "+n.toString()})).join("\n  "):"",this.name="UnsubscriptionError",this.errors=t;}}));function h(n,t){if(n){var r=n.indexOf(t);0<=r&&n.splice(r,1);}}var v=function(){function n(n){this.initialTeardown=n,this.closed=!1,this._parentage=null,this._finalizers=null;}var t;return n.prototype.unsubscribe=function(){var n,t,r,e,c;if(!this.closed){this.closed=!0;var s=this._parentage;if(s)if(this._parentage=null,Array.isArray(s))try{for(var l=o(s),f=l.next();!f.done;f=l.next()){f.value.remove(this);}}catch(t){n={error:t};}finally{try{f&&!f.done&&(t=l.return)&&t.call(l);}finally{if(n)throw n.error}}else s.remove(this);var h=this.initialTeardown;if(a(h))try{h();}catch(n){c=n instanceof p?n.errors:[n];}var v=this._finalizers;if(v){this._finalizers=null;try{for(var d=o(v),y=d.next();!y.done;y=d.next()){var m=y.value;try{b(m);}catch(n){c=null!=c?c:[],n instanceof p?c=u(u([],i(c)),i(n.errors)):c.push(n);}}}catch(n){r={error:n};}finally{try{y&&!y.done&&(e=d.return)&&e.call(d);}finally{if(r)throw r.error}}}if(c)throw new p(c)}},n.prototype.add=function(t){var r;if(t&&t!==this)if(this.closed)b(t);else {if(t instanceof n){if(t.closed||t._hasParent(this))return;t._addParent(this);}(this._finalizers=null!==(r=this._finalizers)&&void 0!==r?r:[]).push(t);}},n.prototype._hasParent=function(n){var t=this._parentage;return t===n||Array.isArray(t)&&t.includes(n)},n.prototype._addParent=function(n){var t=this._parentage;this._parentage=Array.isArray(t)?(t.push(n),t):t?[t,n]:n;},n.prototype._removeParent=function(n){var t=this._parentage;t===n?this._parentage=null:Array.isArray(t)&&h(t,n);},n.prototype.remove=function(t){var r=this._finalizers;r&&h(r,t),t instanceof n&&t._removeParent(this);},n.EMPTY=((t=new n).closed=!0,t),n}();function d(n){return n instanceof v||n&&"closed"in n&&a(n.remove)&&a(n.add)&&a(n.unsubscribe)}function b(n){a(n)?n():n.unsubscribe();}v.EMPTY;var y={onUnhandledError:null,onStoppedNotification:null,Promise:void 0,useDeprecatedSynchronousErrorHandling:!1,useDeprecatedNextContext:!1},m={setTimeout:function(n,t){for(var r=[],e=2;e<arguments.length;e++)r[e-2]=arguments[e];return setTimeout.apply(void 0,u([n,t],i(r)))},clearTimeout:function(n){return (clearTimeout)(n)},delegate:void 0};function w(n){m.setTimeout((function(){throw n}));}function x(){}var g=function(n){function r(t){var r=n.call(this)||this;return r.isStopped=!1,t?(r.destination=t,d(t)&&t.add(r)):r.destination=P,r}return t(r,n),r.create=function(n,t,r){return new I(n,t,r)},r.prototype.next=function(n){this.isStopped||this._next(n);},r.prototype.error=function(n){this.isStopped||(this.isStopped=!0,this._error(n));},r.prototype.complete=function(){this.isStopped||(this.isStopped=!0,this._complete());},r.prototype.unsubscribe=function(){this.closed||(this.isStopped=!0,n.prototype.unsubscribe.call(this),this.destination=null);},r.prototype._next=function(n){this.destination.next(n);},r.prototype._error=function(n){try{this.destination.error(n);}finally{this.unsubscribe();}},r.prototype._complete=function(){try{this.destination.complete();}finally{this.unsubscribe();}},r}(v),_=Function.prototype.bind;function S(n,t){return _.call(n,t)}var E=function(){function n(n){this.partialObserver=n;}return n.prototype.next=function(n){var t=this.partialObserver;if(t.next)try{t.next(n);}catch(n){A(n);}},n.prototype.error=function(n){var t=this.partialObserver;if(t.error)try{t.error(n);}catch(n){A(n);}else A(n);},n.prototype.complete=function(){var n=this.partialObserver;if(n.complete)try{n.complete();}catch(n){A(n);}},n}(),I=function(n){function r(t,r,e){var o,i,u=n.call(this)||this;a(t)||!t?o={next:null!=t?t:void 0,error:null!=r?r:void 0,complete:null!=e?e:void 0}:u&&y.useDeprecatedNextContext?((i=Object.create(t)).unsubscribe=function(){return u.unsubscribe()},o={next:t.next&&S(t.next,i),error:t.error&&S(t.error,i),complete:t.complete&&S(t.complete,i)}):o=t;return u.destination=new E(o),u}return t(r,n),r}(g);function A(n){w(n);}var P={closed:!0,next:x,error:function(n){throw n},complete:x},T="function"==typeof Symbol&&Symbol.observable||"@@observable";function O(n){return n}function j(n){return 0===n.length?O:1===n.length?n[0]:function(t){return n.reduce((function(n,t){return t(n)}),t)}}var k=function(){function n(n){n&&(this._subscribe=n);}return n.prototype.lift=function(t){var r=new n;return r.source=this,r.operator=t,r},n.prototype.subscribe=function(n,t,r){var e,o=this,i=(e=n)&&e instanceof g||function(n){return n&&a(n.next)&&a(n.error)&&a(n.complete)}(e)&&d(e)?n:new I(n,t,r);return function(){var n=o,t=n.operator,r=n.source;i.add(t?t.call(i,r):r?o._subscribe(i):o._trySubscribe(i));}(),i},n.prototype._trySubscribe=function(n){try{return this._subscribe(n)}catch(t){n.error(t);}},n.prototype.forEach=function(n,t){var r=this;return new(t=z(t))((function(t,e){var o=new I({next:function(t){try{n(t);}catch(n){e(n),o.unsubscribe();}},error:e,complete:t});r.subscribe(o);}))},n.prototype._subscribe=function(n){var t;return null===(t=this.source)||void 0===t?void 0:t.subscribe(n)},n.prototype[T]=function(){return this},n.prototype.pipe=function(){for(var n=[],t=0;t<arguments.length;t++)n[t]=arguments[t];return j(n)(this)},n.prototype.toPromise=function(n){var t=this;return new(n=z(n))((function(n,r){var e;t.subscribe((function(n){return e=n}),(function(n){return r(n)}),(function(){return n(e)}));}))},n.create=function(t){return new n(t)},n}();function z(n){var t;return null!==(t=null!=n?n:y.Promise)&&void 0!==t?t:Promise}function L(n){return function(t){if(function(n){return a(null==n?void 0:n.lift)}(t))return t.lift((function(t){try{return n(t,this)}catch(n){this.error(n);}}));throw new TypeError("Unable to lift unknown Observable type")}}function N(n,t,r,e,o){return new U(n,t,r,e,o)}var U=function(n){function r(t,r,e,o,i,u){var c=n.call(this,t)||this;return c.onFinalize=i,c.shouldUnsubscribe=u,c._next=r?function(n){try{r(n);}catch(n){t.error(n);}}:n.prototype._next,c._error=o?function(n){try{o(n);}catch(n){t.error(n);}finally{this.unsubscribe();}}:n.prototype._error,c._complete=e?function(){try{e();}catch(n){t.error(n);}finally{this.unsubscribe();}}:n.prototype._complete,c}return t(r,n),r.prototype.unsubscribe=function(){var t;if(!this.shouldUnsubscribe||this.shouldUnsubscribe()){var r=this.closed;n.prototype.unsubscribe.call(this),!r&&(null===(t=this.onFinalize)||void 0===t||t.call(this));}},r}(g),C={now:function(){return (Date).now()},delegate:void 0},D=function(n){function r(t,r){return n.call(this)||this}return t(r,n),r.prototype.schedule=function(n,t){return this},r}(v),M={setInterval:function(n,t){for(var r=[],e=2;e<arguments.length;e++)r[e-2]=arguments[e];var o=M.delegate;return (null==o?void 0:o.setInterval)?o.setInterval.apply(o,u([n,t],i(r))):setInterval.apply(void 0,u([n,t],i(r)))},clearInterval:function(n){return (clearInterval)(n)},delegate:void 0},Y=function(n){function r(t,r){var e=n.call(this,t,r)||this;return e.scheduler=t,e.work=r,e.pending=!1,e}return t(r,n),r.prototype.schedule=function(n,t){var r;if(void 0===t&&(t=0),this.closed)return this;this.state=n;var e=this.id,o=this.scheduler;return null!=e&&(this.id=this.recycleAsyncId(o,e,t)),this.pending=!0,this.delay=t,this.id=null!==(r=this.id)&&void 0!==r?r:this.requestAsyncId(o,this.id,t),this},r.prototype.requestAsyncId=function(n,t,r){return void 0===r&&(r=0),M.setInterval(n.flush.bind(n,this),r)},r.prototype.recycleAsyncId=function(n,t,r){if(void 0===r&&(r=0),null!=r&&this.delay===r&&!1===this.pending)return t;null!=t&&M.clearInterval(t);},r.prototype.execute=function(n,t){if(this.closed)return new Error("executing a cancelled action");this.pending=!1;var r=this._execute(n,t);if(r)return r;!1===this.pending&&null!=this.id&&(this.id=this.recycleAsyncId(this.scheduler,this.id,null));},r.prototype._execute=function(n,t){var r,e=!1;try{this.work(n);}catch(n){e=!0,r=n||new Error("Scheduled action threw falsy error");}if(e)return this.unsubscribe(),r},r.prototype.unsubscribe=function(){if(!this.closed){var t=this.id,r=this.scheduler,e=r.actions;this.work=this.state=this.scheduler=null,this.pending=!1,h(e,this),null!=t&&(this.id=this.recycleAsyncId(r,t,null)),this.delay=null,n.prototype.unsubscribe.call(this);}},r}(D),F=function(){function n(t,r){void 0===r&&(r=n.now),this.schedulerActionCtor=t,this.now=r;}return n.prototype.schedule=function(n,t,r){return void 0===t&&(t=0),new this.schedulerActionCtor(this,n).schedule(r,t)},n.now=C.now,n}(),R=new(function(n){function r(t,r){void 0===r&&(r=F.now);var e=n.call(this,t,r)||this;return e.actions=[],e._active=!1,e}return t(r,n),r.prototype.flush=function(n){var t=this.actions;if(this._active)t.push(n);else {var r;this._active=!0;do{if(r=n.execute(n.state,n.delay))break}while(n=t.shift());if(this._active=!1,r){for(;n=t.shift();)n.unsubscribe();throw r}}},r}(F))(Y),q=R,V=new k((function(n){return n.complete()}));function W(n){return n&&a(n.schedule)}function G(n){return n[n.length-1]}function H(n){return W(G(n))?n.pop():void 0}var B=function(n){return n&&"number"==typeof n.length&&"function"!=typeof n};function J(n){return a(null==n?void 0:n.then)}function K(n){return a(n[T])}function Q(n){return Symbol.asyncIterator&&a(null==n?void 0:n[Symbol.asyncIterator])}function X(n){return new TypeError("You provided "+(null!==n&&"object"==typeof n?"an invalid object":"'"+n+"'")+" where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.")}var Z="function"==typeof Symbol&&Symbol.iterator?Symbol.iterator:"@@iterator";function $(n){return a(null==n?void 0:n[Z])}function nn(n){return s(this,arguments,(function(){var t,r,o;return e(this,(function(e){switch(e.label){case 0:t=n.getReader(),e.label=1;case 1:e.trys.push([1,,9,10]),e.label=2;case 2:return [4,c(t.read())];case 3:return r=e.sent(),o=r.value,r.done?[4,c(void 0)]:[3,5];case 4:return [2,e.sent()];case 5:return [4,c(o)];case 6:return [4,e.sent()];case 7:return e.sent(),[3,2];case 8:return [3,10];case 9:return t.releaseLock(),[7];case 10:return [2]}}))}))}function tn(n){return a(null==n?void 0:n.getReader)}function rn(n){if(n instanceof k)return n;if(null!=n){if(K(n))return i=n,new k((function(n){var t=i[T]();if(a(t.subscribe))return t.subscribe(n);throw new TypeError("Provided object does not correctly implement Symbol.observable")}));if(B(n))return e=n,new k((function(n){for(var t=0;t<e.length&&!n.closed;t++)n.next(e[t]);n.complete();}));if(J(n))return r=n,new k((function(n){r.then((function(t){n.closed||(n.next(t),n.complete());}),(function(t){return n.error(t)})).then(null,w);}));if(Q(n))return en(n);if($(n))return t=n,new k((function(n){var r,e;try{for(var i=o(t),u=i.next();!u.done;u=i.next()){var c=u.value;if(n.next(c),n.closed)return}}catch(n){r={error:n};}finally{try{u&&!u.done&&(e=i.return)&&e.call(i);}finally{if(r)throw r.error}}n.complete();}));if(tn(n))return en(nn(n))}var t,r,e,i;throw X(n)}function en(n){return new k((function(t){(function(n,t){var o,i,u,c;return r(this,void 0,void 0,(function(){var r,s;return e(this,(function(e){switch(e.label){case 0:e.trys.push([0,5,6,11]),o=l(n),e.label=1;case 1:return [4,o.next()];case 2:if((i=e.sent()).done)return [3,4];if(r=i.value,t.next(r),t.closed)return [2];e.label=3;case 3:return [3,1];case 4:return [3,11];case 5:return s=e.sent(),u={error:s},[3,11];case 6:return e.trys.push([6,,9,10]),i&&!i.done&&(c=o.return)?[4,c.call(o)]:[3,8];case 7:e.sent(),e.label=8;case 8:return [3,10];case 9:if(u)throw u.error;return [7];case 10:return [7];case 11:return t.complete(),[2]}}))}))})(n,t).catch((function(n){return t.error(n)}));}))}function on(n,t,r,e,o){void 0===e&&(e=0),void 0===o&&(o=!1);var i=t.schedule((function(){r(),o?n.add(this.schedule(null,e)):this.unsubscribe();}),e);if(n.add(i),!o)return i}function un(n,t){return void 0===t&&(t=0),L((function(r,e){r.subscribe(N(e,(function(r){return on(e,n,(function(){return e.next(r)}),t)}),(function(){return on(e,n,(function(){return e.complete()}),t)}),(function(r){return on(e,n,(function(){return e.error(r)}),t)})));}))}function cn(n,t){return void 0===t&&(t=0),L((function(r,e){e.add(n.schedule((function(){return r.subscribe(e)}),t));}))}function sn(n,t){if(!n)throw new Error("Iterable cannot be null");return new k((function(r){on(r,t,(function(){var e=n[Symbol.asyncIterator]();on(r,t,(function(){e.next().then((function(n){n.done?r.complete():r.next(n.value);}));}),0,!0);}));}))}function ln(n,t){if(null!=n){if(K(n))return function(n,t){return rn(n).pipe(cn(t),un(t))}(n,t);if(B(n))return function(n,t){return new k((function(r){var e=0;return t.schedule((function(){e===n.length?r.complete():(r.next(n[e++]),r.closed||this.schedule());}))}))}(n,t);if(J(n))return function(n,t){return rn(n).pipe(cn(t),un(t))}(n,t);if(Q(n))return sn(n,t);if($(n))return function(n,t){return new k((function(r){var e;return on(r,t,(function(){e=n[Z](),on(r,t,(function(){var n,t,o;try{t=(n=e.next()).value,o=n.done;}catch(n){return void r.error(n)}o?r.complete():r.next(t);}),0,!0);})),function(){return a(null==e?void 0:e.return)&&e.return()}}))}(n,t);if(tn(n))return function(n,t){return sn(nn(n),t)}(n,t)}throw X(n)}function an(n,t){return t?ln(n,t):rn(n)}var fn=f((function(n){return function(){n(this),this.name="EmptyError",this.message="no elements in sequence";}}));function pn(n,t){return L((function(r,e){var o=0;r.subscribe(N(e,(function(r){e.next(n.call(t,r,o++));})));}))}var hn=Array.isArray;function vn(n){return pn((function(t){return function(n,t){return hn(t)?n.apply(void 0,u([],i(t))):n(t)}(n,t)}))}function dn(n,t,r){return void 0===r&&(r=1/0),a(t)?dn((function(r,e){return pn((function(n,o){return t(r,n,e,o)}))(rn(n(r,e)))}),r):("number"==typeof t&&(r=t),L((function(t,e){return function(n,t,r,e,o,i,u,c){var s=[],l=0,a=0,f=!1,p=function(){!f||s.length||l||t.complete();},h=function(n){return l<e?v(n):s.push(n)},v=function(n){i&&t.next(n),l++;var c=!1;rn(r(n,a++)).subscribe(N(t,(function(n){null==o||o(n),i?h(n):t.next(n);}),(function(){c=!0;}),void 0,(function(){if(c)try{l--;for(var n=function(){var n=s.shift();u?on(t,u,(function(){return v(n)})):v(n);};s.length&&l<e;)n();p();}catch(n){t.error(n);}})));};return n.subscribe(N(t,h,(function(){f=!0,p();}))),function(){null==c||c();}}(t,e,n,r)})))}function bn(n){return void 0===n&&(n=1/0),dn(O,n)}function yn(){for(var n=[],t=0;t<arguments.length;t++)n[t]=arguments[t];return bn(1)(an(n,H(n)))}var mn=["addListener","removeListener"],wn=["addEventListener","removeEventListener"],xn=["on","off"];function gn(n,t){return function(r){return function(e){return n[r](t,e)}}}function _n(n,t,r){void 0===n&&(n=0),void 0===r&&(r=q);var e=-1;return null!=t&&(W(t)?r=t:e=t),new k((function(t){var o,i=(o=n)instanceof Date&&!isNaN(o)?+n-r.now():n;i<0&&(i=0);var u=0;return r.schedule((function(){t.closed||(t.next(u++),0<=e?this.schedule(void 0,e):t.complete());}),i)}))}var Sn=new k(x),En=Array.isArray;function In(n,t){return L((function(r,e){var o=0;r.subscribe(N(e,(function(r){return n.call(t,r,o++)&&e.next(r)})));}))}function An(n){return function(t){for(var r=[],e=function(e){r.push(rn(n[e]).subscribe(N(t,(function(n){if(r){for(var o=0;o<r.length;o++)o!==e&&r[o].unsubscribe();r=null;}t.next(n);}))));},o=0;r&&!t.closed&&o<n.length;o++)e(o);}}function Pn(n){return L((function(t,r){var e=!1;t.subscribe(N(r,(function(n){e=!0,r.next(n);}),(function(){e||r.next(n),r.complete();})));}))}function Tn(n){return n<=0?function(){return V}:L((function(t,r){var e=0;t.subscribe(N(r,(function(t){++e<=n&&(r.next(t),n<=e&&r.complete());})));}))}function On(){return L((function(n,t){n.subscribe(N(t,x));}))}function jn(n,t){return t?function(r){return yn(t.pipe(Tn(1),On()),r.pipe(jn(n)))}:dn((function(t,r){return rn(n(t,r)).pipe(Tn(1),function(n){return pn((function(){return n}))}(t))}))}function kn(n){return void 0===n&&(n=zn),L((function(t,r){var e=!1;t.subscribe(N(r,(function(n){e=!0,r.next(n);}),(function(){return e?r.complete():r.error(n())})));}))}function zn(){return new fn}rxjs.EMPTY=V,rxjs.NEVER=Sn,rxjs.Observable=k,rxjs.catchError=function n(t){return L((function(r,e){var o,i=null,u=!1;i=r.subscribe(N(e,void 0,void 0,(function(c){o=rn(t(c,n(t)(r))),i?(i.unsubscribe(),i=null,o.subscribe(e)):u=!0;}))),u&&(i.unsubscribe(),i=null,o.subscribe(e));}))},rxjs.defaultIfEmpty=Pn,rxjs.defer=function(n){return new k((function(t){rn(n()).subscribe(t);}))},rxjs.delay=function(n,t){void 0===t&&(t=R);var r=_n(n,t);return jn((function(){return r}))},rxjs.filter=In,rxjs.filterAsync=function(n){return dn((t=>an(Promise.resolve(n(t))).pipe(In((n=>n)),pn((()=>t)))))},rxjs.first=function(n,t){var r=arguments.length>=2;return function(e){return e.pipe(n?In((function(t,r){return n(t,r,e)})):O,Tn(1),r?Pn(t):kn((function(){return new fn})))}},rxjs.firstValueFrom=function(n,t){var r="object"==typeof t;return new Promise((function(e,o){var i=new I({next:function(n){e(n),i.unsubscribe();},error:o,complete:function(){r?e(t.defaultValue):o(new fn);}});n.subscribe(i);}))},rxjs.from=an,rxjs.fromEvent=function n(t,r,e,o){if(a(e)&&(o=e,e=void 0),o)return n(t,r,e).pipe(vn(o));var u=i(function(n){return a(n.addEventListener)&&a(n.removeEventListener)}(t)?wn.map((function(n){return function(o){return t[n](r,o,e)}})):function(n){return a(n.addListener)&&a(n.removeListener)}(t)?mn.map(gn(t,r)):function(n){return a(n.on)&&a(n.off)}(t)?xn.map(gn(t,r)):[],2),c=u[0],s=u[1];if(!c&&B(t))return dn((function(t){return n(t,r,e)}))(rn(t));if(!c)throw new TypeError("Invalid event target");return new k((function(n){var t=function(){for(var t=[],r=0;r<arguments.length;r++)t[r]=arguments[r];return n.next(1<t.length?t:t[0])};return c(t),function(){return s(t)}}))},rxjs.identity=O,rxjs.ignoreElements=On,rxjs.map=pn,rxjs.merge=function(){for(var n=[],t=0;t<arguments.length;t++)n[t]=arguments[t];var r=H(n),e=function(n,t){return "number"==typeof G(n)?n.pop():t}(n,1/0),o=n;return o.length?1===o.length?rn(o[0]):bn(e)(an(o,r)):V},rxjs.mergeMap=dn,rxjs.noop=x,rxjs.of=function(){for(var n=[],t=0;t<arguments.length;t++)n[t]=arguments[t];return an(n,H(n))},rxjs.pipe=function(){for(var n=[],t=0;t<arguments.length;t++)n[t]=arguments[t];return j(n)},rxjs.race=function(){for(var n,t=[],r=0;r<arguments.length;r++)t[r]=arguments[r];return 1===(t=1===(n=t).length&&En(n[0])?n[0]:n).length?rn(t[0]):new k(An(t))},rxjs.raceWith=function(){for(var n=[],t=0;t<arguments.length;t++)n[t]=arguments[t];return n.length?L((function(t,r){An(u([t],i(n)))(r);})):O},rxjs.retry=function(n){var t;void 0===n&&(n=1/0);var r=(t=n&&"object"==typeof n?n:{count:n}).count,e=void 0===r?1/0:r,o=t.delay,i=t.resetOnSuccess,u=void 0!==i&&i;return e<=0?O:L((function(n,t){var r,i=0,c=function(){var s=!1;r=n.subscribe(N(t,(function(n){u&&(i=0),t.next(n);}),void 0,(function(n){if(i++<e){var u=function(){r?(r.unsubscribe(),r=null,c()):s=!0;};if(null!=o){var l="number"==typeof o?_n(o):rn(o(n,i)),a=N(t,(function(){a.unsubscribe(),u();}),(function(){t.complete();}));l.subscribe(a);}else u();}else t.error(n);}))),s&&(r.unsubscribe(),r=null,c());};c();}))},rxjs.startWith=function(){for(var n=[],t=0;t<arguments.length;t++)n[t]=arguments[t];var r=H(n);return L((function(t,e){(r?yn(n,t,r):yn(n,t)).subscribe(e);}))},rxjs.switchMap=function(n,t){return L((function(r,e){var o=null,i=0,u=!1,c=function(){return u&&!o&&e.complete()};r.subscribe(N(e,(function(r){null==o||o.unsubscribe();var u=0,s=i++;rn(n(r,s)).subscribe(o=N(e,(function(n){return e.next(t?t(r,n,s,u++):n)}),(function(){o=null,c();})));}),(function(){u=!0,c();})));}))},rxjs.tap=function(n,t,r){var e=a(n)||t||r?{next:n,error:t,complete:r}:n;return e?L((function(n,t){var r;null===(r=e.subscribe)||void 0===r||r.call(e);var o=!0;n.subscribe(N(t,(function(n){var r;null===(r=e.next)||void 0===r||r.call(e,n),t.next(n);}),(function(){var n;o=!1,null===(n=e.complete)||void 0===n||n.call(e),t.complete();}),(function(n){var r;o=!1,null===(r=e.error)||void 0===r||r.call(e,n),t.error(n);}),(function(){var n,t;o&&(null===(n=e.unsubscribe)||void 0===n||n.call(e)),null===(t=e.finalize)||void 0===t||t.call(e);})));})):O},rxjs.throwIfEmpty=kn,rxjs.timer=_n;

var environment = {};

/**
 * Copyright 2020 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(environment, "__esModule", { value: true });
environment.USE_TAB_TARGET = environment.DEFERRED_PROMISE_DEBUG_TIMEOUT = environment.isNode = void 0;
/**
 * @internal
 */
environment.isNode = !!(typeof process !== 'undefined' && process.version);
/**
 * @internal
 */
environment.DEFERRED_PROMISE_DEBUG_TIMEOUT = typeof process !== 'undefined' &&
    typeof process.env['PUPPETEER_DEFERRED_PROMISE_DEBUG_TIMEOUT'] !== 'undefined'
    ? Number(process.env['PUPPETEER_DEFERRED_PROMISE_DEBUG_TIMEOUT'])
    : -1;
/**
 * Only used for internal testing.
 *
 * @internal
 */
environment.USE_TAB_TARGET = typeof process !== 'undefined'
    ? process.env['PUPPETEER_INTERNAL_TAB_TARGET'] === 'true'
    : false;

var assert$1 = {};

/**
 * Copyright 2020 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(assert$1, "__esModule", { value: true });
assert$1.assert = void 0;
/**
 * Asserts that the given value is truthy.
 * @param value - some conditional statement
 * @param message - the error message to throw if the value is not truthy.
 *
 * @internal
 */
const assert = (value, message) => {
    if (!value) {
        throw new Error(message);
    }
};
assert$1.assert = assert;

var Deferred$1 = {};

var Errors = {};

/**
 * Copyright 2018 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(Errors, "__esModule", { value: true });
Errors.errors = Errors.TargetCloseError = Errors.ProtocolError = Errors.TimeoutError = Errors.CustomError = void 0;
/**
 * @deprecated Do not use.
 *
 * @public
 */
class CustomError extends Error {
    /**
     * @internal
     */
    constructor(message) {
        super(message);
        this.name = this.constructor.name;
        Error.captureStackTrace(this, this.constructor);
    }
}
Errors.CustomError = CustomError;
/**
 * TimeoutError is emitted whenever certain operations are terminated due to
 * timeout.
 *
 * @remarks
 * Example operations are {@link Page.waitForSelector | page.waitForSelector} or
 * {@link PuppeteerNode.launch | puppeteer.launch}.
 *
 * @public
 */
class TimeoutError extends CustomError {
}
Errors.TimeoutError = TimeoutError;
/**
 * ProtocolError is emitted whenever there is an error from the protocol.
 *
 * @public
 */
class ProtocolError extends CustomError {
    #code;
    #originalMessage = '';
    set code(code) {
        this.#code = code;
    }
    /**
     * @readonly
     * @public
     */
    get code() {
        return this.#code;
    }
    set originalMessage(originalMessage) {
        this.#originalMessage = originalMessage;
    }
    /**
     * @readonly
     * @public
     */
    get originalMessage() {
        return this.#originalMessage;
    }
}
Errors.ProtocolError = ProtocolError;
/**
 * @internal
 */
class TargetCloseError extends ProtocolError {
}
Errors.TargetCloseError = TargetCloseError;
/**
 * @deprecated Import error classes directly.
 *
 * Puppeteer methods might throw errors if they are unable to fulfill a request.
 * For example, `page.waitForSelector(selector[, options])` might fail if the
 * selector doesn't match any nodes during the given timeframe.
 *
 * For certain types of errors Puppeteer uses specific error classes. These
 * classes are available via `puppeteer.errors`.
 *
 * @example
 * An example of handling a timeout error:
 *
 * ```ts
 * try {
 *   await page.waitForSelector('.foo');
 * } catch (e) {
 *   if (e instanceof TimeoutError) {
 *     // Do something if this is a timeout.
 *   }
 * }
 * ```
 *
 * @public
 */
Errors.errors = Object.freeze({
    TimeoutError,
    ProtocolError,
});

Object.defineProperty(Deferred$1, "__esModule", { value: true });
Deferred$1.Deferred = void 0;
const Errors_js_1$4 = Errors;
/**
 * Creates and returns a deferred object along with the resolve/reject functions.
 *
 * If the deferred has not been resolved/rejected within the `timeout` period,
 * the deferred gets resolves with a timeout error. `timeout` has to be greater than 0 or
 * it is ignored.
 *
 * @internal
 */
class Deferred {
    #isResolved = false;
    #isRejected = false;
    #value;
    #resolver = () => { };
    #taskPromise = new Promise(resolve => {
        this.#resolver = resolve;
    });
    #timeoutId;
    constructor(opts) {
        this.#timeoutId =
            opts && opts.timeout > 0
                ? setTimeout(() => {
                    this.reject(new Errors_js_1$4.TimeoutError(opts.message));
                }, opts.timeout)
                : undefined;
    }
    #finish(value) {
        clearTimeout(this.#timeoutId);
        this.#value = value;
        this.#resolver();
    }
    resolve(value) {
        if (this.#isRejected || this.#isResolved) {
            return;
        }
        this.#isResolved = true;
        this.#finish(value);
    }
    reject(error) {
        if (this.#isRejected || this.#isResolved) {
            return;
        }
        this.#isRejected = true;
        this.#finish(error);
    }
    resolved() {
        return this.#isResolved;
    }
    finished() {
        return this.#isResolved || this.#isRejected;
    }
    value() {
        return this.#value;
    }
    async valueOrThrow() {
        await this.#taskPromise;
        if (this.#isRejected) {
            throw this.#value;
        }
        return this.#value;
    }
    static create(opts) {
        return new Deferred(opts);
    }
    static async race(awaitables) {
        const deferredWithTimeout = new Set();
        try {
            const promises = awaitables.map(value => {
                if (value instanceof Deferred) {
                    if (value.#timeoutId) {
                        deferredWithTimeout.add(value);
                    }
                    return value.valueOrThrow();
                }
                return value;
            });
            // eslint-disable-next-line no-restricted-syntax
            return await Promise.race(promises);
        }
        finally {
            for (const deferred of deferredWithTimeout) {
                // We need to stop the timeout else
                // Node.JS will keep running the event loop till the
                // timer executes
                deferred.reject(new Error('Timeout cleared'));
            }
        }
    }
}
Deferred$1.Deferred = Deferred;

var ErrorLike = {};

/**
 * @internal
 */
Object.defineProperty(ErrorLike, "__esModule", { value: true });
ErrorLike.isErrnoException = ErrorLike.isErrorLike = void 0;
/**
 * @internal
 */
function isErrorLike(obj) {
    return (typeof obj === 'object' && obj !== null && 'name' in obj && 'message' in obj);
}
ErrorLike.isErrorLike = isErrorLike;
/**
 * @internal
 */
function isErrnoException(obj) {
    return (isErrorLike(obj) &&
        ('errno' in obj || 'code' in obj || 'path' in obj || 'syscall' in obj));
}
ErrorLike.isErrnoException = isErrnoException;

var Debug = {};

/**
 * Copyright 2020 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding$3 = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault$3 = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar$3 = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$3(result, mod, k);
    __setModuleDefault$3(result, mod);
    return result;
};
Object.defineProperty(Debug, "__esModule", { value: true });
Debug.getCapturedLogs = Debug.setLogCapture = Debug.debug = Debug.importDebug = void 0;
const environment_js_1$4 = environment;
/**
 * @internal
 */
let debugModule = null;
/**
 * @internal
 */
async function importDebug() {
    if (!debugModule) {
        debugModule = (await Promise.resolve().then(() => __importStar$3(require$$1))).default;
    }
    return debugModule;
}
Debug.importDebug = importDebug;
/**
 * A debug function that can be used in any environment.
 *
 * @remarks
 * If used in Node, it falls back to the
 * {@link https://www.npmjs.com/package/debug | debug module}. In the browser it
 * uses `console.log`.
 *
 * In Node, use the `DEBUG` environment variable to control logging:
 *
 * ```
 * DEBUG=* // logs all channels
 * DEBUG=foo // logs the `foo` channel
 * DEBUG=foo* // logs any channels starting with `foo`
 * ```
 *
 * In the browser, set `window.__PUPPETEER_DEBUG` to a string:
 *
 * ```
 * window.__PUPPETEER_DEBUG='*'; // logs all channels
 * window.__PUPPETEER_DEBUG='foo'; // logs the `foo` channel
 * window.__PUPPETEER_DEBUG='foo*'; // logs any channels starting with `foo`
 * ```
 *
 * @example
 *
 * ```
 * const log = debug('Page');
 *
 * log('new page created')
 * // logs "Page: new page created"
 * ```
 *
 * @param prefix - this will be prefixed to each log.
 * @returns a function that can be called to log to that debug channel.
 *
 * @internal
 */
const debug = (prefix) => {
    if (environment_js_1$4.isNode) {
        return async (...logArgs) => {
            if (captureLogs) {
                capturedLogs.push(prefix + logArgs);
            }
            (await importDebug())(prefix)(logArgs);
        };
    }
    return (...logArgs) => {
        const debugLevel = globalThis.__PUPPETEER_DEBUG;
        if (!debugLevel) {
            return;
        }
        const everythingShouldBeLogged = debugLevel === '*';
        const prefixMatchesDebugLevel = everythingShouldBeLogged ||
            /**
             * If the debug level is `foo*`, that means we match any prefix that
             * starts with `foo`. If the level is `foo`, we match only the prefix
             * `foo`.
             */
            (debugLevel.endsWith('*')
                ? prefix.startsWith(debugLevel)
                : prefix === debugLevel);
        if (!prefixMatchesDebugLevel) {
            return;
        }
        // eslint-disable-next-line no-console
        console.log(`${prefix}:`, ...logArgs);
    };
};
Debug.debug = debug;
/**
 * @internal
 */
let capturedLogs = [];
/**
 * @internal
 */
let captureLogs = false;
/**
 * @internal
 */
function setLogCapture(value) {
    capturedLogs = [];
    captureLogs = value;
}
Debug.setLogCapture = setLogCapture;
/**
 * @internal
 */
function getCapturedLogs() {
    return capturedLogs;
}
Debug.getCapturedLogs = getCapturedLogs;

var ElementHandle$2 = {};

var ElementHandle$1 = {};

var GetQueryHandler = {};

var AriaQueryHandler = {};

var AsyncIterableUtil$1 = {};

Object.defineProperty(AsyncIterableUtil$1, "__esModule", { value: true });
AsyncIterableUtil$1.AsyncIterableUtil = void 0;
/**
 * @internal
 */
class AsyncIterableUtil {
    static async *map(iterable, map) {
        for await (const value of iterable) {
            yield await map(value);
        }
    }
    static async *flatMap(iterable, map) {
        for await (const value of iterable) {
            yield* map(value);
        }
    }
    static async collect(iterable) {
        const result = [];
        for await (const value of iterable) {
            result.push(value);
        }
        return result;
    }
    static async first(iterable) {
        for await (const value of iterable) {
            return value;
        }
        return;
    }
}
AsyncIterableUtil$1.AsyncIterableUtil = AsyncIterableUtil;

var QueryHandler = {};

var _Function = {};

(function (exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.interpolateFunction = exports.stringifyFunction = exports.createFunction = void 0;
	/**
	 * Copyright 2023 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	const createdFunctions = new Map();
	/**
	 * Creates a function from a string.
	 *
	 * @internal
	 */
	const createFunction = (functionValue) => {
	    let fn = createdFunctions.get(functionValue);
	    if (fn) {
	        return fn;
	    }
	    fn = new Function(`return ${functionValue}`)();
	    createdFunctions.set(functionValue, fn);
	    return fn;
	};
	exports.createFunction = createFunction;
	/**
	 * @internal
	 */
	function stringifyFunction(fn) {
	    let value = fn.toString();
	    try {
	        new Function(`(${value})`);
	    }
	    catch {
	        // This means we might have a function shorthand (e.g. `test(){}`). Let's
	        // try prefixing.
	        let prefix = 'function ';
	        if (value.startsWith('async ')) {
	            prefix = `async ${prefix}`;
	            value = value.substring('async '.length);
	        }
	        value = `${prefix}${value}`;
	        try {
	            new Function(`(${value})`);
	        }
	        catch {
	            // We tried hard to serialize, but there's a weird beast here.
	            throw new Error('Passed function cannot be serialized!');
	        }
	    }
	    return value;
	}
	exports.stringifyFunction = stringifyFunction;
	/**
	 * Replaces `PLACEHOLDER`s with the given replacements.
	 *
	 * All replacements must be valid JS code.
	 *
	 * @example
	 *
	 * ```ts
	 * interpolateFunction(() => PLACEHOLDER('test'), {test: 'void 0'});
	 * // Equivalent to () => void 0
	 * ```
	 *
	 * @internal
	 */
	const interpolateFunction = (fn, replacements) => {
	    let value = stringifyFunction(fn);
	    for (const [name, jsValue] of Object.entries(replacements)) {
	        value = value.replace(new RegExp(`PLACEHOLDER\\(\\s*(?:'${name}'|"${name}")\\s*\\)`, 'g'), 
	        // Wrapping this ensures tersers that accidently inline PLACEHOLDER calls
	        // are still valid. Without, we may get calls like ()=>{...}() which is
	        // not valid.
	        `(${jsValue})`);
	    }
	    return (0, exports.createFunction)(value);
	};
	exports.interpolateFunction = interpolateFunction;
	
} (_Function));

var HandleIterator = {};

/**
 * Copyright 2023 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __addDisposableResource$2 = (commonjsGlobal && commonjsGlobal.__addDisposableResource) || function (env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        env.stack.push({ value: value, dispose: dispose, async: async });
    }
    else if (async) {
        env.stack.push({ async: true });
    }
    return value;
};
var __disposeResources$2 = (commonjsGlobal && commonjsGlobal.__disposeResources) || (function (SuppressedError) {
    return function (env) {
        function fail(e) {
            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        function next() {
            while (env.stack.length) {
                var rec = env.stack.pop();
                try {
                    var result = rec.dispose && rec.dispose.call(rec.value);
                    if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
                }
                catch (e) {
                    fail(e);
                }
            }
            if (env.hasError) throw env.error;
        }
        return next();
    };
})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
Object.defineProperty(HandleIterator, "__esModule", { value: true });
HandleIterator.transposeIterableHandle = void 0;
const DEFAULT_BATCH_SIZE = 20;
/**
 * This will transpose an iterator JSHandle into a fast, Puppeteer-side iterator
 * of JSHandles.
 *
 * @param size - The number of elements to transpose. This should be something
 * reasonable.
 */
async function* fastTransposeIteratorHandle(iterator, size) {
    const env_1 = { stack: [], error: void 0, hasError: false };
    try {
        const array = __addDisposableResource$2(env_1, await iterator.evaluateHandle(async (iterator, size) => {
            const results = [];
            while (results.length < size) {
                const result = await iterator.next();
                if (result.done) {
                    break;
                }
                results.push(result.value);
            }
            return results;
        }, size), false);
        const properties = (await array.getProperties());
        const handles = properties.values();
        const stack = __addDisposableResource$2(env_1, new DisposableStack(), false);
        stack.defer(() => {
            for (const handle_1 of handles) {
                const env_2 = { stack: [], error: void 0, hasError: false };
                try {
                    const handle = __addDisposableResource$2(env_2, handle_1, false);
                    handle[Symbol.dispose]();
                }
                catch (e_2) {
                    env_2.error = e_2;
                    env_2.hasError = true;
                }
                finally {
                    __disposeResources$2(env_2);
                }
            }
        });
        yield* handles;
        return properties.size === 0;
    }
    catch (e_1) {
        env_1.error = e_1;
        env_1.hasError = true;
    }
    finally {
        __disposeResources$2(env_1);
    }
}
/**
 * This will transpose an iterator JSHandle in batches based on the default size
 * of {@link fastTransposeIteratorHandle}.
 */
async function* transposeIteratorHandle(iterator) {
    let size = DEFAULT_BATCH_SIZE;
    while (!(yield* fastTransposeIteratorHandle(iterator, size))) {
        size <<= 1;
    }
}
/**
 * @internal
 */
async function* transposeIterableHandle(handle) {
    const env_3 = { stack: [], error: void 0, hasError: false };
    try {
        const generatorHandle = __addDisposableResource$2(env_3, await handle.evaluateHandle(iterable => {
            return (async function* () {
                yield* iterable;
            })();
        }), false);
        yield* transposeIteratorHandle(generatorHandle);
    }
    catch (e_3) {
        env_3.error = e_3;
        env_3.hasError = true;
    }
    finally {
        __disposeResources$2(env_3);
    }
}
HandleIterator.transposeIterableHandle = transposeIterableHandle;

var LazyArg$1 = {};

/**
 * Copyright 2022 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(LazyArg$1, "__esModule", { value: true });
LazyArg$1.LazyArg = void 0;
/**
 * @internal
 */
class LazyArg {
    static create = (get) => {
        // We don't want to introduce LazyArg to the type system, otherwise we would
        // have to make it public.
        return new LazyArg(get);
    };
    #get;
    constructor(get) {
        this.#get = get;
    }
    async get(context) {
        return await this.#get(context);
    }
}
LazyArg$1.LazyArg = LazyArg;

var hasRequiredQueryHandler;

function requireQueryHandler () {
	if (hasRequiredQueryHandler) return QueryHandler;
	hasRequiredQueryHandler = 1;
	/**
	 * Copyright 2023 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var __addDisposableResource = (commonjsGlobal && commonjsGlobal.__addDisposableResource) || function (env, value, async) {
	    if (value !== null && value !== void 0) {
	        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
	        var dispose;
	        if (async) {
	            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
	            dispose = value[Symbol.asyncDispose];
	        }
	        if (dispose === void 0) {
	            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
	            dispose = value[Symbol.dispose];
	        }
	        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
	        env.stack.push({ value: value, dispose: dispose, async: async });
	    }
	    else if (async) {
	        env.stack.push({ async: true });
	    }
	    return value;
	};
	var __disposeResources = (commonjsGlobal && commonjsGlobal.__disposeResources) || (function (SuppressedError) {
	    return function (env) {
	        function fail(e) {
	            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
	            env.hasError = true;
	        }
	        function next() {
	            while (env.stack.length) {
	                var rec = env.stack.pop();
	                try {
	                    var result = rec.dispose && rec.dispose.call(rec.value);
	                    if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
	                }
	                catch (e) {
	                    fail(e);
	                }
	            }
	            if (env.hasError) throw env.error;
	        }
	        return next();
	    };
	})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
	    var e = new Error(message);
	    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
	});
	Object.defineProperty(QueryHandler, "__esModule", { value: true });
	QueryHandler.QueryHandler = void 0;
	const ElementHandle_js_1 = requireElementHandle$2();
	const ErrorLike_js_1 = ErrorLike;
	const Function_js_1 = _Function;
	const HandleIterator_js_1 = HandleIterator;
	const LazyArg_js_1 = LazyArg$1;
	/**
	 * @internal
	 */
	let QueryHandler$1 = class QueryHandler {
	    // Either one of these may be implemented, but at least one must be.
	    static querySelectorAll;
	    static querySelector;
	    static get _querySelector() {
	        if (this.querySelector) {
	            return this.querySelector;
	        }
	        if (!this.querySelectorAll) {
	            throw new Error('Cannot create default `querySelector`.');
	        }
	        return (this.querySelector = (0, Function_js_1.interpolateFunction)(async (node, selector, PuppeteerUtil) => {
	            const querySelectorAll = PLACEHOLDER('querySelectorAll');
	            const results = querySelectorAll(node, selector, PuppeteerUtil);
	            for await (const result of results) {
	                return result;
	            }
	            return null;
	        }, {
	            querySelectorAll: (0, Function_js_1.stringifyFunction)(this.querySelectorAll),
	        }));
	    }
	    static get _querySelectorAll() {
	        if (this.querySelectorAll) {
	            return this.querySelectorAll;
	        }
	        if (!this.querySelector) {
	            throw new Error('Cannot create default `querySelectorAll`.');
	        }
	        return (this.querySelectorAll = (0, Function_js_1.interpolateFunction)(async function* (node, selector, PuppeteerUtil) {
	            const querySelector = PLACEHOLDER('querySelector');
	            const result = await querySelector(node, selector, PuppeteerUtil);
	            if (result) {
	                yield result;
	            }
	        }, {
	            querySelector: (0, Function_js_1.stringifyFunction)(this.querySelector),
	        }));
	    }
	    /**
	     * Queries for multiple nodes given a selector and {@link ElementHandle}.
	     *
	     * Akin to {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll | Document.querySelectorAll()}.
	     */
	    static async *queryAll(element, selector) {
	        const env_1 = { stack: [], error: void 0, hasError: false };
	        try {
	            const handle = __addDisposableResource(env_1, await element.evaluateHandle(this._querySelectorAll, selector, LazyArg_js_1.LazyArg.create(context => {
	                return context.puppeteerUtil;
	            })), false);
	            yield* (0, HandleIterator_js_1.transposeIterableHandle)(handle);
	        }
	        catch (e_1) {
	            env_1.error = e_1;
	            env_1.hasError = true;
	        }
	        finally {
	            __disposeResources(env_1);
	        }
	    }
	    /**
	     * Queries for a single node given a selector and {@link ElementHandle}.
	     *
	     * Akin to {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector}.
	     */
	    static async queryOne(element, selector) {
	        const env_2 = { stack: [], error: void 0, hasError: false };
	        try {
	            const result = __addDisposableResource(env_2, await element.evaluateHandle(this._querySelector, selector, LazyArg_js_1.LazyArg.create(context => {
	                return context.puppeteerUtil;
	            })), false);
	            if (!(result instanceof ElementHandle_js_1.ElementHandle)) {
	                return null;
	            }
	            return result.move();
	        }
	        catch (e_2) {
	            env_2.error = e_2;
	            env_2.hasError = true;
	        }
	        finally {
	            __disposeResources(env_2);
	        }
	    }
	    /**
	     * Waits until a single node appears for a given selector and
	     * {@link ElementHandle}.
	     *
	     * This will always query the handle in the Puppeteer world and migrate the
	     * result to the main world.
	     */
	    static async waitFor(elementOrFrame, selector, options) {
	        const env_3 = { stack: [], error: void 0, hasError: false };
	        try {
	            let frame;
	            const element = __addDisposableResource(env_3, await (async () => {
	                if (!(elementOrFrame instanceof ElementHandle_js_1.ElementHandle)) {
	                    frame = elementOrFrame;
	                    return;
	                }
	                frame = elementOrFrame.frame;
	                return await frame.isolatedRealm().adoptHandle(elementOrFrame);
	            })(), false);
	            const { visible = false, hidden = false, timeout, signal } = options;
	            try {
	                const env_4 = { stack: [], error: void 0, hasError: false };
	                try {
	                    signal?.throwIfAborted();
	                    const handle = __addDisposableResource(env_4, await frame.isolatedRealm().waitForFunction(async (PuppeteerUtil, query, selector, root, visible) => {
	                        const querySelector = PuppeteerUtil.createFunction(query);
	                        const node = await querySelector(root ?? document, selector, PuppeteerUtil);
	                        return PuppeteerUtil.checkVisibility(node, visible);
	                    }, {
	                        polling: visible || hidden ? 'raf' : 'mutation',
	                        root: element,
	                        timeout,
	                        signal,
	                    }, LazyArg_js_1.LazyArg.create(context => {
	                        return context.puppeteerUtil;
	                    }), (0, Function_js_1.stringifyFunction)(this._querySelector), selector, element, visible ? true : hidden ? false : undefined), false);
	                    if (signal?.aborted) {
	                        throw signal.reason;
	                    }
	                    if (!(handle instanceof ElementHandle_js_1.ElementHandle)) {
	                        return null;
	                    }
	                    return await frame.mainRealm().transferHandle(handle);
	                }
	                catch (e_3) {
	                    env_4.error = e_3;
	                    env_4.hasError = true;
	                }
	                finally {
	                    __disposeResources(env_4);
	                }
	            }
	            catch (error) {
	                if (!(0, ErrorLike_js_1.isErrorLike)(error)) {
	                    throw error;
	                }
	                if (error.name === 'AbortError') {
	                    throw error;
	                }
	                error.message = `Waiting for selector \`${selector}\` failed: ${error.message}`;
	                throw error;
	            }
	        }
	        catch (e_4) {
	            env_3.error = e_4;
	            env_3.hasError = true;
	        }
	        finally {
	            __disposeResources(env_3);
	        }
	    }
	};
	QueryHandler.QueryHandler = QueryHandler$1;
	
	return QueryHandler;
}

var hasRequiredAriaQueryHandler;

function requireAriaQueryHandler () {
	if (hasRequiredAriaQueryHandler) return AriaQueryHandler;
	hasRequiredAriaQueryHandler = 1;
	/**
	 * Copyright 2020 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(AriaQueryHandler, "__esModule", { value: true });
	AriaQueryHandler.ARIAQueryHandler = void 0;
	const assert_js_1 = assert$1;
	const AsyncIterableUtil_js_1 = AsyncIterableUtil$1;
	const QueryHandler_js_1 = requireQueryHandler();
	const queryAXTree = async (client, element, accessibleName, role) => {
	    const { nodes } = await client.send('Accessibility.queryAXTree', {
	        objectId: element.id,
	        accessibleName,
	        role,
	    });
	    return nodes.filter((node) => {
	        return !node.role || node.role.value !== 'StaticText';
	    });
	};
	const KNOWN_ATTRIBUTES = Object.freeze(['name', 'role']);
	const isKnownAttribute = (attribute) => {
	    return KNOWN_ATTRIBUTES.includes(attribute);
	};
	const normalizeValue = (value) => {
	    return value.replace(/ +/g, ' ').trim();
	};
	/**
	 * The selectors consist of an accessible name to query for and optionally
	 * further aria attributes on the form `[<attribute>=<value>]`.
	 * Currently, we only support the `name` and `role` attribute.
	 * The following examples showcase how the syntax works wrt. querying:
	 *
	 * - 'title[role="heading"]' queries for elements with name 'title' and role 'heading'.
	 * - '[role="img"]' queries for elements with role 'img' and any name.
	 * - 'label' queries for elements with name 'label' and any role.
	 * - '[name=""][role="button"]' queries for elements with no name and role 'button'.
	 */
	const ATTRIBUTE_REGEXP = /\[\s*(?<attribute>\w+)\s*=\s*(?<quote>"|')(?<value>\\.|.*?(?=\k<quote>))\k<quote>\s*\]/g;
	const parseARIASelector = (selector) => {
	    const queryOptions = {};
	    const defaultName = selector.replace(ATTRIBUTE_REGEXP, (_, attribute, __, value) => {
	        attribute = attribute.trim();
	        (0, assert_js_1.assert)(isKnownAttribute(attribute), `Unknown aria attribute "${attribute}" in selector`);
	        queryOptions[attribute] = normalizeValue(value);
	        return '';
	    });
	    if (defaultName && !queryOptions.name) {
	        queryOptions.name = normalizeValue(defaultName);
	    }
	    return queryOptions;
	};
	/**
	 * @internal
	 */
	class ARIAQueryHandler extends QueryHandler_js_1.QueryHandler {
	    static querySelector = async (node, selector, { ariaQuerySelector }) => {
	        return await ariaQuerySelector(node, selector);
	    };
	    static async *queryAll(element, selector) {
	        const { name, role } = parseARIASelector(selector);
	        const results = await queryAXTree(element.realm.environment.client, element, name, role);
	        yield* AsyncIterableUtil_js_1.AsyncIterableUtil.map(results, node => {
	            return element.realm.adoptBackendNode(node.backendDOMNodeId);
	        });
	    }
	    static queryOne = async (element, selector) => {
	        return ((await AsyncIterableUtil_js_1.AsyncIterableUtil.first(this.queryAll(element, selector))) ?? null);
	    };
	}
	AriaQueryHandler.ARIAQueryHandler = ARIAQueryHandler;
	
	return AriaQueryHandler;
}

var CustomQueryHandler = {};

var ScriptInjector$1 = {};

var injected = {};

Object.defineProperty(injected, "__esModule", { value: true });
injected.source = void 0;
/**
 * JavaScript code that provides the puppeteer utilities. See the
 * [README](https://github.com/puppeteer/puppeteer/blob/main/src/injected/README.md)
 * for injection for more information.
 *
 * @internal
 */
injected.source = "\"use strict\";var C=Object.defineProperty;var ne=Object.getOwnPropertyDescriptor;var oe=Object.getOwnPropertyNames;var se=Object.prototype.hasOwnProperty;var u=(t,e)=>{for(var n in e)C(t,n,{get:e[n],enumerable:!0})},ie=(t,e,n,r)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of oe(e))!se.call(t,o)&&o!==n&&C(t,o,{get:()=>e[o],enumerable:!(r=ne(e,o))||r.enumerable});return t};var le=t=>ie(C({},\"__esModule\",{value:!0}),t);var Oe={};u(Oe,{default:()=>Re});module.exports=le(Oe);var T=class extends Error{constructor(e){super(e),this.name=this.constructor.name,Error.captureStackTrace(this,this.constructor)}},S=class extends T{},I=class extends T{#e;#t=\"\";set code(e){this.#e=e}get code(){return this.#e}set originalMessage(e){this.#t=e}get originalMessage(){return this.#t}};var qe=Object.freeze({TimeoutError:S,ProtocolError:I});var f=class t{#e=!1;#t=!1;#n;#r=()=>{};#o=new Promise(e=>{this.#r=e});#s;constructor(e){this.#s=e&&e.timeout>0?setTimeout(()=>{this.reject(new S(e.message))},e.timeout):void 0}#i(e){clearTimeout(this.#s),this.#n=e,this.#r()}resolve(e){this.#t||this.#e||(this.#e=!0,this.#i(e))}reject(e){this.#t||this.#e||(this.#t=!0,this.#i(e))}resolved(){return this.#e}finished(){return this.#e||this.#t}value(){return this.#n}async valueOrThrow(){if(await this.#o,this.#t)throw this.#n;return this.#n}static create(e){return new t(e)}static async race(e){let n=new Set;try{let r=e.map(o=>o instanceof t?(o.#s&&n.add(o),o.valueOrThrow()):o);return await Promise.race(r)}finally{for(let r of n)r.reject(new Error(\"Timeout cleared\"))}}};var G=new Map,X=t=>{let e=G.get(t);return e||(e=new Function(`return ${t}`)(),G.set(t,e),e)};var R={};u(R,{ariaQuerySelector:()=>ae,ariaQuerySelectorAll:()=>k});var ae=(t,e)=>window.__ariaQuerySelector(t,e),k=async function*(t,e){yield*await window.__ariaQuerySelectorAll(t,e)};var q={};u(q,{customQuerySelectors:()=>M});var O=class{#e=new Map;register(e,n){if(!n.queryOne&&n.queryAll){let r=n.queryAll;n.queryOne=(o,i)=>{for(let s of r(o,i))return s;return null}}else if(n.queryOne&&!n.queryAll){let r=n.queryOne;n.queryAll=(o,i)=>{let s=r(o,i);return s?[s]:[]}}else if(!n.queryOne||!n.queryAll)throw new Error(\"At least one query method must be defined.\");this.#e.set(e,{querySelector:n.queryOne,querySelectorAll:n.queryAll})}unregister(e){this.#e.delete(e)}get(e){return this.#e.get(e)}clear(){this.#e.clear()}},M=new O;var D={};u(D,{pierceQuerySelector:()=>ce,pierceQuerySelectorAll:()=>ue});var ce=(t,e)=>{let n=null,r=o=>{let i=document.createTreeWalker(o,NodeFilter.SHOW_ELEMENT);do{let s=i.currentNode;s.shadowRoot&&r(s.shadowRoot),!(s instanceof ShadowRoot)&&s!==o&&!n&&s.matches(e)&&(n=s)}while(!n&&i.nextNode())};return t instanceof Document&&(t=t.documentElement),r(t),n},ue=(t,e)=>{let n=[],r=o=>{let i=document.createTreeWalker(o,NodeFilter.SHOW_ELEMENT);do{let s=i.currentNode;s.shadowRoot&&r(s.shadowRoot),!(s instanceof ShadowRoot)&&s!==o&&s.matches(e)&&n.push(s)}while(i.nextNode())};return t instanceof Document&&(t=t.documentElement),r(t),n};var m=(t,e)=>{if(!t)throw new Error(e)};var P=class{#e;#t;#n;#r;constructor(e,n){this.#e=e,this.#t=n}async start(){let e=this.#r=f.create(),n=await this.#e();if(n){e.resolve(n);return}this.#n=new MutationObserver(async()=>{let r=await this.#e();r&&(e.resolve(r),await this.stop())}),this.#n.observe(this.#t,{childList:!0,subtree:!0,attributes:!0})}async stop(){m(this.#r,\"Polling never started.\"),this.#r.finished()||this.#r.reject(new Error(\"Polling stopped\")),this.#n&&(this.#n.disconnect(),this.#n=void 0)}result(){return m(this.#r,\"Polling never started.\"),this.#r.valueOrThrow()}},E=class{#e;#t;constructor(e){this.#e=e}async start(){let e=this.#t=f.create(),n=await this.#e();if(n){e.resolve(n);return}let r=async()=>{if(e.finished())return;let o=await this.#e();if(!o){window.requestAnimationFrame(r);return}e.resolve(o),await this.stop()};window.requestAnimationFrame(r)}async stop(){m(this.#t,\"Polling never started.\"),this.#t.finished()||this.#t.reject(new Error(\"Polling stopped\"))}result(){return m(this.#t,\"Polling never started.\"),this.#t.valueOrThrow()}},x=class{#e;#t;#n;#r;constructor(e,n){this.#e=e,this.#t=n}async start(){let e=this.#r=f.create(),n=await this.#e();if(n){e.resolve(n);return}this.#n=setInterval(async()=>{let r=await this.#e();r&&(e.resolve(r),await this.stop())},this.#t)}async stop(){m(this.#r,\"Polling never started.\"),this.#r.finished()||this.#r.reject(new Error(\"Polling stopped\")),this.#n&&(clearInterval(this.#n),this.#n=void 0)}result(){return m(this.#r,\"Polling never started.\"),this.#r.valueOrThrow()}};var H={};u(H,{pQuerySelector:()=>Ie,pQuerySelectorAll:()=>re});var c=class{static async*map(e,n){for await(let r of e)yield await n(r)}static async*flatMap(e,n){for await(let r of e)yield*n(r)}static async collect(e){let n=[];for await(let r of e)n.push(r);return n}static async first(e){for await(let n of e)return n}};var p={attribute:/\\[\\s*(?:(?<namespace>\\*|[-\\w\\P{ASCII}]*)\\|)?(?<name>[-\\w\\P{ASCII}]+)\\s*(?:(?<operator>\\W?=)\\s*(?<value>.+?)\\s*(\\s(?<caseSensitive>[iIsS]))?\\s*)?\\]/gu,id:/#(?<name>[-\\w\\P{ASCII}]+)/gu,class:/\\.(?<name>[-\\w\\P{ASCII}]+)/gu,comma:/\\s*,\\s*/g,combinator:/\\s*[\\s>+~]\\s*/g,\"pseudo-element\":/::(?<name>[-\\w\\P{ASCII}]+)(?:\\((?<argument>¶*)\\))?/gu,\"pseudo-class\":/:(?<name>[-\\w\\P{ASCII}]+)(?:\\((?<argument>¶*)\\))?/gu,universal:/(?:(?<namespace>\\*|[-\\w\\P{ASCII}]*)\\|)?\\*/gu,type:/(?:(?<namespace>\\*|[-\\w\\P{ASCII}]*)\\|)?(?<name>[-\\w\\P{ASCII}]+)/gu},fe=new Set([\"combinator\",\"comma\"]);var de=t=>{switch(t){case\"pseudo-element\":case\"pseudo-class\":return new RegExp(p[t].source.replace(\"(?<argument>\\xB6*)\",\"(?<argument>.*)\"),\"gu\");default:return p[t]}};function me(t,e){let n=0,r=\"\";for(;e<t.length;e++){let o=t[e];switch(o){case\"(\":++n;break;case\")\":--n;break}if(r+=o,n===0)return r}return r}function he(t,e=p){if(!t)return[];let n=[t];for(let[o,i]of Object.entries(e))for(let s=0;s<n.length;s++){let l=n[s];if(typeof l!=\"string\")continue;i.lastIndex=0;let a=i.exec(l);if(!a)continue;let h=a.index-1,d=[],V=a[0],B=l.slice(0,h+1);B&&d.push(B),d.push({...a.groups,type:o,content:V});let z=l.slice(h+V.length+1);z&&d.push(z),n.splice(s,1,...d)}let r=0;for(let o of n)switch(typeof o){case\"string\":throw new Error(`Unexpected sequence ${o} found at index ${r}`);case\"object\":r+=o.content.length,o.pos=[r-o.content.length,r],fe.has(o.type)&&(o.content=o.content.trim()||\" \");break}return n}var pe=/(['\"])([^\\\\\\n]+?)\\1/g,ye=/\\\\./g;function K(t,e=p){if(t=t.trim(),t===\"\")return[];let n=[];t=t.replace(ye,(i,s)=>(n.push({value:i,offset:s}),\"\\uE000\".repeat(i.length))),t=t.replace(pe,(i,s,l,a)=>(n.push({value:i,offset:a}),`${s}${\"\\uE001\".repeat(l.length)}${s}`));{let i=0,s;for(;(s=t.indexOf(\"(\",i))>-1;){let l=me(t,s);n.push({value:l,offset:s}),t=`${t.substring(0,s)}(${\"\\xB6\".repeat(l.length-2)})${t.substring(s+l.length)}`,i=s+l.length}}let r=he(t,e),o=new Set;for(let i of n.reverse())for(let s of r){let{offset:l,value:a}=i;if(!(s.pos[0]<=l&&l+a.length<=s.pos[1]))continue;let{content:h}=s,d=l-s.pos[0];s.content=h.slice(0,d)+a+h.slice(d+a.length),s.content!==h&&o.add(s)}for(let i of o){let s=de(i.type);if(!s)throw new Error(`Unknown token type: ${i.type}`);s.lastIndex=0;let l=s.exec(i.content);if(!l)throw new Error(`Unable to parse content for ${i.type}: ${i.content}`);Object.assign(i,l.groups)}return r}function*N(t,e){switch(t.type){case\"list\":for(let n of t.list)yield*N(n,t);break;case\"complex\":yield*N(t.left,t),yield*N(t.right,t);break;case\"compound\":yield*t.list.map(n=>[n,t]);break;default:yield[t,e]}}function y(t){let e;return Array.isArray(t)?e=t:e=[...N(t)].map(([n])=>n),e.map(n=>n.content).join(\"\")}p.combinator=/\\s*(>>>>?|[\\s>+~])\\s*/g;var ge=/\\\\[\\s\\S]/g,we=t=>t.length<=1?t:((t[0]==='\"'||t[0]===\"'\")&&t.endsWith(t[0])&&(t=t.slice(1,-1)),t.replace(ge,e=>e[1]));function Y(t){let e=!0,n=K(t);if(n.length===0)return[[],e];let r=[],o=[r],i=[o],s=[];for(let l of n){switch(l.type){case\"combinator\":switch(l.content){case\">>>\":e=!1,s.length&&(r.push(y(s)),s.splice(0)),r=[],o.push(\">>>\"),o.push(r);continue;case\">>>>\":e=!1,s.length&&(r.push(y(s)),s.splice(0)),r=[],o.push(\">>>>\"),o.push(r);continue}break;case\"pseudo-element\":if(!l.name.startsWith(\"-p-\"))break;e=!1,s.length&&(r.push(y(s)),s.splice(0)),r.push({name:l.name.slice(3),value:we(l.argument??\"\")});continue;case\"comma\":s.length&&(r.push(y(s)),s.splice(0)),r=[],o=[r],i.push(o);continue}s.push(l)}return s.length&&r.push(y(s)),[i,e]}var Q={};u(Q,{textQuerySelectorAll:()=>b});var Se=new Set([\"checkbox\",\"image\",\"radio\"]),be=t=>t instanceof HTMLSelectElement||t instanceof HTMLTextAreaElement||t instanceof HTMLInputElement&&!Se.has(t.type),Te=new Set([\"SCRIPT\",\"STYLE\"]),w=t=>!Te.has(t.nodeName)&&!document.head?.contains(t),_=new WeakMap,Z=t=>{for(;t;)_.delete(t),t instanceof ShadowRoot?t=t.host:t=t.parentNode},J=new WeakSet,Pe=new MutationObserver(t=>{for(let e of t)Z(e.target)}),g=t=>{let e=_.get(t);if(e||(e={full:\"\",immediate:[]},!w(t)))return e;let n=\"\";if(be(t))e.full=t.value,e.immediate.push(t.value),t.addEventListener(\"input\",r=>{Z(r.target)},{once:!0,capture:!0});else{for(let r=t.firstChild;r;r=r.nextSibling){if(r.nodeType===Node.TEXT_NODE){e.full+=r.nodeValue??\"\",n+=r.nodeValue??\"\";continue}n&&e.immediate.push(n),n=\"\",r.nodeType===Node.ELEMENT_NODE&&(e.full+=g(r).full)}n&&e.immediate.push(n),t instanceof Element&&t.shadowRoot&&(e.full+=g(t.shadowRoot).full),J.has(t)||(Pe.observe(t,{childList:!0,characterData:!0}),J.add(t))}return _.set(t,e),e};var b=function*(t,e){let n=!1;for(let r of t.childNodes)if(r instanceof Element&&w(r)){let o;r.shadowRoot?o=b(r.shadowRoot,e):o=b(r,e);for(let i of o)yield i,n=!0}n||t instanceof Element&&w(t)&&g(t).full.includes(e)&&(yield t)};var $={};u($,{checkVisibility:()=>xe,pierce:()=>A,pierceAll:()=>L});var Ee=[\"hidden\",\"collapse\"],xe=(t,e)=>{if(!t)return e===!1;if(e===void 0)return t;let n=t.nodeType===Node.TEXT_NODE?t.parentElement:t,r=window.getComputedStyle(n),o=r&&!Ee.includes(r.visibility)&&!Ne(n);return e===o?t:!1};function Ne(t){let e=t.getBoundingClientRect();return e.width===0||e.height===0}var Ae=t=>\"shadowRoot\"in t&&t.shadowRoot instanceof ShadowRoot;function*A(t){Ae(t)?yield t.shadowRoot:yield t}function*L(t){t=A(t).next().value,yield t;let e=[document.createTreeWalker(t,NodeFilter.SHOW_ELEMENT)];for(let n of e){let r;for(;r=n.nextNode();)r.shadowRoot&&(yield r.shadowRoot,e.push(document.createTreeWalker(r.shadowRoot,NodeFilter.SHOW_ELEMENT)))}}var j={};u(j,{xpathQuerySelectorAll:()=>U});var U=function*(t,e){let r=(t.ownerDocument||document).evaluate(e,t,null,XPathResult.ORDERED_NODE_ITERATOR_TYPE),o;for(;o=r.iterateNext();)yield o};var ve=/[-\\w\\P{ASCII}*]/,ee=t=>\"querySelectorAll\"in t,v=class extends Error{constructor(e,n){super(`${e} is not a valid selector: ${n}`)}},F=class{#e;#t;#n=[];#r=void 0;elements;constructor(e,n,r){this.elements=[e],this.#e=n,this.#t=r,this.#o()}async run(){if(typeof this.#r==\"string\")switch(this.#r.trimStart()){case\":scope\":this.#o();break}for(;this.#r!==void 0;this.#o()){let e=this.#r,n=this.#e;typeof e==\"string\"?e[0]&&ve.test(e[0])?this.elements=c.flatMap(this.elements,async function*(r){ee(r)&&(yield*r.querySelectorAll(e))}):this.elements=c.flatMap(this.elements,async function*(r){if(!r.parentElement){if(!ee(r))return;yield*r.querySelectorAll(e);return}let o=0;for(let i of r.parentElement.children)if(++o,i===r)break;yield*r.parentElement.querySelectorAll(`:scope>:nth-child(${o})${e}`)}):this.elements=c.flatMap(this.elements,async function*(r){switch(e.name){case\"text\":yield*b(r,e.value);break;case\"xpath\":yield*U(r,e.value);break;case\"aria\":yield*k(r,e.value);break;default:let o=M.get(e.name);if(!o)throw new v(n,`Unknown selector type: ${e.name}`);yield*o.querySelectorAll(r,e.value)}})}}#o(){if(this.#n.length!==0){this.#r=this.#n.shift();return}if(this.#t.length===0){this.#r=void 0;return}let e=this.#t.shift();switch(e){case\">>>>\":{this.elements=c.flatMap(this.elements,A),this.#o();break}case\">>>\":{this.elements=c.flatMap(this.elements,L),this.#o();break}default:this.#n=e,this.#o();break}}},W=class{#e=new WeakMap;calculate(e,n=[]){if(e===null)return n;e instanceof ShadowRoot&&(e=e.host);let r=this.#e.get(e);if(r)return[...r,...n];let o=0;for(let s=e.previousSibling;s;s=s.previousSibling)++o;let i=this.calculate(e.parentNode,[o]);return this.#e.set(e,i),[...i,...n]}},te=(t,e)=>{if(t.length+e.length===0)return 0;let[n=-1,...r]=t,[o=-1,...i]=e;return n===o?te(r,i):n<o?-1:1},Ce=async function*(t){let e=new Set;for await(let r of t)e.add(r);let n=new W;yield*[...e.values()].map(r=>[r,n.calculate(r)]).sort(([,r],[,o])=>te(r,o)).map(([r])=>r)},re=function(t,e){let n,r;try{[n,r]=Y(e)}catch{return t.querySelectorAll(e)}if(r)return t.querySelectorAll(e);if(n.some(o=>{let i=0;return o.some(s=>(typeof s==\"string\"?++i:i=0,i>1))}))throw new v(e,\"Multiple deep combinators found in sequence.\");return Ce(c.flatMap(n,o=>{let i=new F(t,e,o);return i.run(),i.elements}))},Ie=async function(t,e){for await(let n of re(t,e))return n;return null};var ke=Object.freeze({...R,...q,...D,...H,...Q,...$,...j,Deferred:f,createFunction:X,createTextContent:g,IntervalPoller:x,isSuitableNodeForTextMatching:w,MutationPoller:P,RAFPoller:E}),Re=ke;\n";

Object.defineProperty(ScriptInjector$1, "__esModule", { value: true });
ScriptInjector$1.scriptInjector = void 0;
const injected_js_1 = injected;
class ScriptInjector {
    #updated = false;
    #amendments = new Set();
    // Appends a statement of the form `(PuppeteerUtil) => {...}`.
    append(statement) {
        this.#update(() => {
            this.#amendments.add(statement);
        });
    }
    pop(statement) {
        this.#update(() => {
            this.#amendments.delete(statement);
        });
    }
    inject(inject, force = false) {
        if (this.#updated || force) {
            inject(this.#get());
        }
        this.#updated = false;
    }
    #update(callback) {
        callback();
        this.#updated = true;
    }
    #get() {
        return `(() => {
      const module = {};
      ${injected_js_1.source}
      ${[...this.#amendments]
            .map(statement => {
            return `(${statement})(module.exports.default);`;
        })
            .join('')}
      return module.exports.default;
    })()`;
    }
}
/**
 * @internal
 */
ScriptInjector$1.scriptInjector = new ScriptInjector();

var hasRequiredCustomQueryHandler;

function requireCustomQueryHandler () {
	if (hasRequiredCustomQueryHandler) return CustomQueryHandler;
	hasRequiredCustomQueryHandler = 1;
	(function (exports) {
		/**
		 * Copyright 2023 Google Inc. All rights reserved.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *     http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.clearCustomQueryHandlers = exports.customQueryHandlerNames = exports.unregisterCustomQueryHandler = exports.registerCustomQueryHandler = exports.customQueryHandlers = exports.CustomQueryHandlerRegistry = void 0;
		const assert_js_1 = assert$1;
		const Function_js_1 = _Function;
		const QueryHandler_js_1 = requireQueryHandler();
		const ScriptInjector_js_1 = ScriptInjector$1;
		/**
		 * The registry of {@link CustomQueryHandler | custom query handlers}.
		 *
		 * @example
		 *
		 * ```ts
		 * Puppeteer.customQueryHandlers.register('lit', { … });
		 * const aHandle = await page.$('lit/…');
		 * ```
		 *
		 * @internal
		 */
		class CustomQueryHandlerRegistry {
		    #handlers = new Map();
		    get(name) {
		        const handler = this.#handlers.get(name);
		        return handler ? handler[1] : undefined;
		    }
		    /**
		     * Registers a {@link CustomQueryHandler | custom query handler}.
		     *
		     * @remarks
		     * After registration, the handler can be used everywhere where a selector is
		     * expected by prepending the selection string with `<name>/`. The name is
		     * only allowed to consist of lower- and upper case latin letters.
		     *
		     * @example
		     *
		     * ```ts
		     * Puppeteer.customQueryHandlers.register('lit', { … });
		     * const aHandle = await page.$('lit/…');
		     * ```
		     *
		     * @param name - Name to register under.
		     * @param queryHandler - {@link CustomQueryHandler | Custom query handler} to
		     * register.
		     */
		    register(name, handler) {
		        (0, assert_js_1.assert)(!this.#handlers.has(name), `Cannot register over existing handler: ${name}`);
		        (0, assert_js_1.assert)(/^[a-zA-Z]+$/.test(name), `Custom query handler names may only contain [a-zA-Z]`);
		        (0, assert_js_1.assert)(handler.queryAll || handler.queryOne, `At least one query method must be implemented.`);
		        const Handler = class extends QueryHandler_js_1.QueryHandler {
		            static querySelectorAll = (0, Function_js_1.interpolateFunction)((node, selector, PuppeteerUtil) => {
		                return PuppeteerUtil.customQuerySelectors
		                    .get(PLACEHOLDER('name'))
		                    .querySelectorAll(node, selector);
		            }, { name: JSON.stringify(name) });
		            static querySelector = (0, Function_js_1.interpolateFunction)((node, selector, PuppeteerUtil) => {
		                return PuppeteerUtil.customQuerySelectors
		                    .get(PLACEHOLDER('name'))
		                    .querySelector(node, selector);
		            }, { name: JSON.stringify(name) });
		        };
		        const registerScript = (0, Function_js_1.interpolateFunction)((PuppeteerUtil) => {
		            PuppeteerUtil.customQuerySelectors.register(PLACEHOLDER('name'), {
		                queryAll: PLACEHOLDER('queryAll'),
		                queryOne: PLACEHOLDER('queryOne'),
		            });
		        }, {
		            name: JSON.stringify(name),
		            queryAll: handler.queryAll
		                ? (0, Function_js_1.stringifyFunction)(handler.queryAll)
		                : String(undefined),
		            queryOne: handler.queryOne
		                ? (0, Function_js_1.stringifyFunction)(handler.queryOne)
		                : String(undefined),
		        }).toString();
		        this.#handlers.set(name, [registerScript, Handler]);
		        ScriptInjector_js_1.scriptInjector.append(registerScript);
		    }
		    /**
		     * Unregisters the {@link CustomQueryHandler | custom query handler} for the
		     * given name.
		     *
		     * @throws `Error` if there is no handler under the given name.
		     */
		    unregister(name) {
		        const handler = this.#handlers.get(name);
		        if (!handler) {
		            throw new Error(`Cannot unregister unknown handler: ${name}`);
		        }
		        ScriptInjector_js_1.scriptInjector.pop(handler[0]);
		        this.#handlers.delete(name);
		    }
		    /**
		     * Gets the names of all {@link CustomQueryHandler | custom query handlers}.
		     */
		    names() {
		        return [...this.#handlers.keys()];
		    }
		    /**
		     * Unregisters all custom query handlers.
		     */
		    clear() {
		        for (const [registerScript] of this.#handlers) {
		            ScriptInjector_js_1.scriptInjector.pop(registerScript);
		        }
		        this.#handlers.clear();
		    }
		}
		exports.CustomQueryHandlerRegistry = CustomQueryHandlerRegistry;
		/**
		 * @internal
		 */
		exports.customQueryHandlers = new CustomQueryHandlerRegistry();
		/**
		 * @deprecated Import {@link Puppeteer} and use the static method
		 * {@link Puppeteer.registerCustomQueryHandler}
		 *
		 * @public
		 */
		function registerCustomQueryHandler(name, handler) {
		    exports.customQueryHandlers.register(name, handler);
		}
		exports.registerCustomQueryHandler = registerCustomQueryHandler;
		/**
		 * @deprecated Import {@link Puppeteer} and use the static method
		 * {@link Puppeteer.unregisterCustomQueryHandler}
		 *
		 * @public
		 */
		function unregisterCustomQueryHandler(name) {
		    exports.customQueryHandlers.unregister(name);
		}
		exports.unregisterCustomQueryHandler = unregisterCustomQueryHandler;
		/**
		 * @deprecated Import {@link Puppeteer} and use the static method
		 * {@link Puppeteer.customQueryHandlerNames}
		 *
		 * @public
		 */
		function customQueryHandlerNames() {
		    return exports.customQueryHandlers.names();
		}
		exports.customQueryHandlerNames = customQueryHandlerNames;
		/**
		 * @deprecated Import {@link Puppeteer} and use the static method
		 * {@link Puppeteer.clearCustomQueryHandlers}
		 *
		 * @public
		 */
		function clearCustomQueryHandlers() {
		    exports.customQueryHandlers.clear();
		}
		exports.clearCustomQueryHandlers = clearCustomQueryHandlers;
		
	} (CustomQueryHandler));
	return CustomQueryHandler;
}

var PierceQueryHandler = {};

var hasRequiredPierceQueryHandler;

function requirePierceQueryHandler () {
	if (hasRequiredPierceQueryHandler) return PierceQueryHandler;
	hasRequiredPierceQueryHandler = 1;
	/**
	 * Copyright 2023 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(PierceQueryHandler, "__esModule", { value: true });
	PierceQueryHandler.PierceQueryHandler = void 0;
	const QueryHandler_js_1 = requireQueryHandler();
	/**
	 * @internal
	 */
	let PierceQueryHandler$1 = class PierceQueryHandler extends QueryHandler_js_1.QueryHandler {
	    static querySelector = (element, selector, { pierceQuerySelector }) => {
	        return pierceQuerySelector(element, selector);
	    };
	    static querySelectorAll = (element, selector, { pierceQuerySelectorAll }) => {
	        return pierceQuerySelectorAll(element, selector);
	    };
	};
	PierceQueryHandler.PierceQueryHandler = PierceQueryHandler$1;
	
	return PierceQueryHandler;
}

var PQueryHandler = {};

var hasRequiredPQueryHandler;

function requirePQueryHandler () {
	if (hasRequiredPQueryHandler) return PQueryHandler;
	hasRequiredPQueryHandler = 1;
	/**
	 * Copyright 2023 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(PQueryHandler, "__esModule", { value: true });
	PQueryHandler.PQueryHandler = void 0;
	const QueryHandler_js_1 = requireQueryHandler();
	/**
	 * @internal
	 */
	let PQueryHandler$1 = class PQueryHandler extends QueryHandler_js_1.QueryHandler {
	    static querySelectorAll = (element, selector, { pQuerySelectorAll }) => {
	        return pQuerySelectorAll(element, selector);
	    };
	    static querySelector = (element, selector, { pQuerySelector }) => {
	        return pQuerySelector(element, selector);
	    };
	};
	PQueryHandler.PQueryHandler = PQueryHandler$1;
	
	return PQueryHandler;
}

var TextQueryHandler = {};

var hasRequiredTextQueryHandler;

function requireTextQueryHandler () {
	if (hasRequiredTextQueryHandler) return TextQueryHandler;
	hasRequiredTextQueryHandler = 1;
	/**
	 * Copyright 2023 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(TextQueryHandler, "__esModule", { value: true });
	TextQueryHandler.TextQueryHandler = void 0;
	const QueryHandler_js_1 = requireQueryHandler();
	/**
	 * @internal
	 */
	let TextQueryHandler$1 = class TextQueryHandler extends QueryHandler_js_1.QueryHandler {
	    static querySelectorAll = (element, selector, { textQuerySelectorAll }) => {
	        return textQuerySelectorAll(element, selector);
	    };
	};
	TextQueryHandler.TextQueryHandler = TextQueryHandler$1;
	
	return TextQueryHandler;
}

var XPathQueryHandler = {};

var hasRequiredXPathQueryHandler;

function requireXPathQueryHandler () {
	if (hasRequiredXPathQueryHandler) return XPathQueryHandler;
	hasRequiredXPathQueryHandler = 1;
	/**
	 * Copyright 2023 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(XPathQueryHandler, "__esModule", { value: true });
	XPathQueryHandler.XPathQueryHandler = void 0;
	const QueryHandler_js_1 = requireQueryHandler();
	/**
	 * @internal
	 */
	let XPathQueryHandler$1 = class XPathQueryHandler extends QueryHandler_js_1.QueryHandler {
	    static querySelectorAll = (element, selector, { xpathQuerySelectorAll }) => {
	        return xpathQuerySelectorAll(element, selector);
	    };
	};
	XPathQueryHandler.XPathQueryHandler = XPathQueryHandler$1;
	
	return XPathQueryHandler;
}

var hasRequiredGetQueryHandler;

function requireGetQueryHandler () {
	if (hasRequiredGetQueryHandler) return GetQueryHandler;
	hasRequiredGetQueryHandler = 1;
	(function (exports) {
		/**
		 * Copyright 2023 Google Inc. All rights reserved.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *     http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.getQueryHandlerAndSelector = exports.getQueryHandlerByName = exports.BUILTIN_QUERY_HANDLERS = void 0;
		const AriaQueryHandler_js_1 = requireAriaQueryHandler();
		const CustomQueryHandler_js_1 = requireCustomQueryHandler();
		const PierceQueryHandler_js_1 = requirePierceQueryHandler();
		const PQueryHandler_js_1 = requirePQueryHandler();
		const TextQueryHandler_js_1 = requireTextQueryHandler();
		const XPathQueryHandler_js_1 = requireXPathQueryHandler();
		exports.BUILTIN_QUERY_HANDLERS = Object.freeze({
		    aria: AriaQueryHandler_js_1.ARIAQueryHandler,
		    pierce: PierceQueryHandler_js_1.PierceQueryHandler,
		    xpath: XPathQueryHandler_js_1.XPathQueryHandler,
		    text: TextQueryHandler_js_1.TextQueryHandler,
		});
		const QUERY_SEPARATORS = ['=', '/'];
		/**
		 * @internal
		 */
		function getQueryHandlerByName(name) {
		    if (name in exports.BUILTIN_QUERY_HANDLERS) {
		        return exports.BUILTIN_QUERY_HANDLERS[name];
		    }
		    return CustomQueryHandler_js_1.customQueryHandlers.get(name);
		}
		exports.getQueryHandlerByName = getQueryHandlerByName;
		/**
		 * @internal
		 */
		function getQueryHandlerAndSelector(selector) {
		    for (const handlerMap of [
		        CustomQueryHandler_js_1.customQueryHandlers.names().map(name => {
		            return [name, CustomQueryHandler_js_1.customQueryHandlers.get(name)];
		        }),
		        Object.entries(exports.BUILTIN_QUERY_HANDLERS),
		    ]) {
		        for (const [name, QueryHandler] of handlerMap) {
		            for (const separator of QUERY_SEPARATORS) {
		                const prefix = `${name}${separator}`;
		                if (selector.startsWith(prefix)) {
		                    selector = selector.slice(prefix.length);
		                    return { updatedSelector: selector, QueryHandler };
		                }
		            }
		        }
		    }
		    return { updatedSelector: selector, QueryHandler: PQueryHandler_js_1.PQueryHandler };
		}
		exports.getQueryHandlerAndSelector = getQueryHandlerAndSelector;
		
	} (GetQueryHandler));
	return GetQueryHandler;
}

var JSHandle$2 = {};

var decorators = {};

/**
 * Copyright 2023 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(decorators, "__esModule", { value: true });
decorators.invokeAtMostOnceForArguments = decorators.throwIfDisposed = decorators.moveable = void 0;
const disposablestack_js_1$1 = disposablestack;
const instances = new WeakSet();
function moveable(Class, _) {
    let hasDispose = false;
    if (Class.prototype[disposablestack_js_1$1.Symbol.dispose]) {
        const dispose = Class.prototype[disposablestack_js_1$1.Symbol.dispose];
        Class.prototype[disposablestack_js_1$1.Symbol.dispose] = function () {
            if (instances.has(this)) {
                instances.delete(this);
                return;
            }
            return dispose.call(this);
        };
        hasDispose = true;
    }
    if (Class.prototype[disposablestack_js_1$1.Symbol.asyncDispose]) {
        const asyncDispose = Class.prototype[disposablestack_js_1$1.Symbol.asyncDispose];
        Class.prototype[disposablestack_js_1$1.Symbol.asyncDispose] = function () {
            if (instances.has(this)) {
                instances.delete(this);
                return;
            }
            return asyncDispose.call(this);
        };
        hasDispose = true;
    }
    if (hasDispose) {
        Class.prototype.move = function () {
            instances.add(this);
            return this;
        };
    }
    return Class;
}
decorators.moveable = moveable;
function throwIfDisposed(message = value => {
    return `Attempted to use disposed ${value.constructor.name}.`;
}) {
    return (target, _) => {
        return function (...args) {
            if (this.disposed) {
                throw new Error(message(this));
            }
            return target.call(this, ...args);
        };
    };
}
decorators.throwIfDisposed = throwIfDisposed;
/**
 * The decorator only invokes the target if the target has not been invoked with
 * the same arguments before. The decorated method throws an error if it's
 * invoked with a different number of elements: if you decorate a method, it
 * should have the same number of arguments
 *
 * @internal
 */
function invokeAtMostOnceForArguments(target, _) {
    const cache = new WeakMap();
    let cacheDepth = -1;
    return function (...args) {
        if (cacheDepth === -1) {
            cacheDepth = args.length;
        }
        if (cacheDepth !== args.length) {
            throw new Error('Memoized method was called with the wrong number of arguments');
        }
        let freshArguments = false;
        let cacheIterator = cache;
        for (const arg of args) {
            if (cacheIterator.has(arg)) {
                cacheIterator = cacheIterator.get(arg);
            }
            else {
                freshArguments = true;
                cacheIterator.set(arg, new WeakMap());
                cacheIterator = cacheIterator.get(arg);
            }
        }
        if (!freshArguments) {
            return;
        }
        return target.call(this, ...args);
    };
}
decorators.invokeAtMostOnceForArguments = invokeAtMostOnceForArguments;

var hasRequiredJSHandle$2;

function requireJSHandle$2 () {
	if (hasRequiredJSHandle$2) return JSHandle$2;
	hasRequiredJSHandle$2 = 1;
	/**
	 * Copyright 2023 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var __esDecorate = (commonjsGlobal && commonjsGlobal.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
	    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
	    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
	    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
	    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
	    var _, done = false;
	    for (var i = decorators.length - 1; i >= 0; i--) {
	        var context = {};
	        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
	        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
	        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
	        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
	        if (kind === "accessor") {
	            if (result === void 0) continue;
	            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
	            if (_ = accept(result.get)) descriptor.get = _;
	            if (_ = accept(result.set)) descriptor.set = _;
	            if (_ = accept(result.init)) initializers.unshift(_);
	        }
	        else if (_ = accept(result)) {
	            if (kind === "field") initializers.unshift(_);
	            else descriptor[key] = _;
	        }
	    }
	    if (target) Object.defineProperty(target, contextIn.name, descriptor);
	    done = true;
	};
	var __runInitializers = (commonjsGlobal && commonjsGlobal.__runInitializers) || function (thisArg, initializers, value) {
	    var useValue = arguments.length > 2;
	    for (var i = 0; i < initializers.length; i++) {
	        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
	    }
	    return useValue ? value : void 0;
	};
	var __addDisposableResource = (commonjsGlobal && commonjsGlobal.__addDisposableResource) || function (env, value, async) {
	    if (value !== null && value !== void 0) {
	        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
	        var dispose;
	        if (async) {
	            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
	            dispose = value[Symbol.asyncDispose];
	        }
	        if (dispose === void 0) {
	            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
	            dispose = value[Symbol.dispose];
	        }
	        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
	        env.stack.push({ value: value, dispose: dispose, async: async });
	    }
	    else if (async) {
	        env.stack.push({ async: true });
	    }
	    return value;
	};
	var __disposeResources = (commonjsGlobal && commonjsGlobal.__disposeResources) || (function (SuppressedError) {
	    return function (env) {
	        function fail(e) {
	            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
	            env.hasError = true;
	        }
	        function next() {
	            while (env.stack.length) {
	                var rec = env.stack.pop();
	                try {
	                    var result = rec.dispose && rec.dispose.call(rec.value);
	                    if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
	                }
	                catch (e) {
	                    fail(e);
	                }
	            }
	            if (env.hasError) throw env.error;
	        }
	        return next();
	    };
	})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
	    var e = new Error(message);
	    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
	});
	Object.defineProperty(JSHandle$2, "__esModule", { value: true });
	JSHandle$2.JSHandle = void 0;
	const disposablestack_js_1 = disposablestack;
	const util_js_1 = requireUtil();
	const decorators_js_1 = decorators;
	/**
	 * Represents a reference to a JavaScript object. Instances can be created using
	 * {@link Page.evaluateHandle}.
	 *
	 * Handles prevent the referenced JavaScript object from being garbage-collected
	 * unless the handle is purposely {@link JSHandle.dispose | disposed}. JSHandles
	 * are auto-disposed when their associated frame is navigated away or the parent
	 * context gets destroyed.
	 *
	 * Handles can be used as arguments for any evaluation function such as
	 * {@link Page.$eval}, {@link Page.evaluate}, and {@link Page.evaluateHandle}.
	 * They are resolved to their referenced object.
	 *
	 * @example
	 *
	 * ```ts
	 * const windowHandle = await page.evaluateHandle(() => window);
	 * ```
	 *
	 * @public
	 */
	let JSHandle = (() => {
	    let _classDecorators = [decorators_js_1.moveable];
	    let _classDescriptor;
	    let _classExtraInitializers = [];
	    let _classThis;
	    (class {
	        static { _classThis = this; }
	        static {
	            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
	            __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
	            _classThis = _classDescriptor.value;
	            if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
	            __runInitializers(_classThis, _classExtraInitializers);
	        }
	        /**
	         * @internal
	         */
	        constructor() { }
	        /**
	         * @internal
	         */
	        get disposed() {
	            throw new Error('Not implemented');
	        }
	        /**
	         * Evaluates the given function with the current handle as its first argument.
	         */
	        async evaluate(pageFunction, ...args) {
	            pageFunction = (0, util_js_1.withSourcePuppeteerURLIfNone)(this.evaluate.name, pageFunction);
	            return await this.realm.evaluate(pageFunction, this, ...args);
	        }
	        /**
	         * Evaluates the given function with the current handle as its first argument.
	         *
	         */
	        async evaluateHandle(pageFunction, ...args) {
	            pageFunction = (0, util_js_1.withSourcePuppeteerURLIfNone)(this.evaluateHandle.name, pageFunction);
	            return await this.realm.evaluateHandle(pageFunction, this, ...args);
	        }
	        /**
	         * @internal
	         */
	        async getProperty(propertyName) {
	            return await this.evaluateHandle((object, propertyName) => {
	                return object[propertyName];
	            }, propertyName);
	        }
	        /**
	         * Gets a map of handles representing the properties of the current handle.
	         *
	         * @example
	         *
	         * ```ts
	         * const listHandle = await page.evaluateHandle(() => document.body.children);
	         * const properties = await listHandle.getProperties();
	         * const children = [];
	         * for (const property of properties.values()) {
	         *   const element = property.asElement();
	         *   if (element) {
	         *     children.push(element);
	         *   }
	         * }
	         * children; // holds elementHandles to all children of document.body
	         * ```
	         */
	        async getProperties() {
	            const propertyNames = await this.evaluate(object => {
	                const enumerableProperties = [];
	                const descriptors = Object.getOwnPropertyDescriptors(object);
	                for (const propertyName in descriptors) {
	                    if (descriptors[propertyName]?.enumerable) {
	                        enumerableProperties.push(propertyName);
	                    }
	                }
	                return enumerableProperties;
	            });
	            const map = new Map();
	            const results = await Promise.all(propertyNames.map(key => {
	                return this.getProperty(key);
	            }));
	            for (const [key, value] of Object.entries(propertyNames)) {
	                const env_1 = { stack: [], error: void 0, hasError: false };
	                try {
	                    const handle = __addDisposableResource(env_1, results[key], false);
	                    if (handle) {
	                        map.set(value, handle.move());
	                    }
	                }
	                catch (e_1) {
	                    env_1.error = e_1;
	                    env_1.hasError = true;
	                }
	                finally {
	                    __disposeResources(env_1);
	                }
	            }
	            return map;
	        }
	        [disposablestack_js_1.Symbol.dispose]() {
	            return void this.dispose().catch(util_js_1.debugError);
	        }
	        [disposablestack_js_1.Symbol.asyncDispose]() {
	            return this.dispose();
	        }
	    });
	    return _classThis;
	})();
	JSHandle$2.JSHandle = JSHandle;
	
	return JSHandle$2;
}

var hasRequiredElementHandle$2;

function requireElementHandle$2 () {
	if (hasRequiredElementHandle$2) return ElementHandle$1;
	hasRequiredElementHandle$2 = 1;
	/**
	 * Copyright 2023 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var __runInitializers = (commonjsGlobal && commonjsGlobal.__runInitializers) || function (thisArg, initializers, value) {
	    var useValue = arguments.length > 2;
	    for (var i = 0; i < initializers.length; i++) {
	        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
	    }
	    return useValue ? value : void 0;
	};
	var __esDecorate = (commonjsGlobal && commonjsGlobal.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
	    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
	    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
	    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
	    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
	    var _, done = false;
	    for (var i = decorators.length - 1; i >= 0; i--) {
	        var context = {};
	        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
	        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
	        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
	        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
	        if (kind === "accessor") {
	            if (result === void 0) continue;
	            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
	            if (_ = accept(result.get)) descriptor.get = _;
	            if (_ = accept(result.set)) descriptor.set = _;
	            if (_ = accept(result.init)) initializers.unshift(_);
	        }
	        else if (_ = accept(result)) {
	            if (kind === "field") initializers.unshift(_);
	            else descriptor[key] = _;
	        }
	    }
	    if (target) Object.defineProperty(target, contextIn.name, descriptor);
	    done = true;
	};
	var __addDisposableResource = (commonjsGlobal && commonjsGlobal.__addDisposableResource) || function (env, value, async) {
	    if (value !== null && value !== void 0) {
	        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
	        var dispose;
	        if (async) {
	            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
	            dispose = value[Symbol.asyncDispose];
	        }
	        if (dispose === void 0) {
	            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
	            dispose = value[Symbol.dispose];
	        }
	        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
	        env.stack.push({ value: value, dispose: dispose, async: async });
	    }
	    else if (async) {
	        env.stack.push({ async: true });
	    }
	    return value;
	};
	var __disposeResources = (commonjsGlobal && commonjsGlobal.__disposeResources) || (function (SuppressedError) {
	    return function (env) {
	        function fail(e) {
	            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
	            env.hasError = true;
	        }
	        function next() {
	            while (env.stack.length) {
	                var rec = env.stack.pop();
	                try {
	                    var result = rec.dispose && rec.dispose.call(rec.value);
	                    if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
	                }
	                catch (e) {
	                    fail(e);
	                }
	            }
	            if (env.hasError) throw env.error;
	        }
	        return next();
	    };
	})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
	    var e = new Error(message);
	    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
	});
	Object.defineProperty(ElementHandle$1, "__esModule", { value: true });
	ElementHandle$1.ElementHandle = void 0;
	const GetQueryHandler_js_1 = requireGetQueryHandler();
	const LazyArg_js_1 = LazyArg$1;
	const util_js_1 = requireUtil();
	const assert_js_1 = assert$1;
	const AsyncIterableUtil_js_1 = AsyncIterableUtil$1;
	const JSHandle_js_1 = requireJSHandle$2();
	/**
	 * ElementHandle represents an in-page DOM element.
	 *
	 * @remarks
	 * ElementHandles can be created with the {@link Page.$} method.
	 *
	 * ```ts
	 * import puppeteer from 'puppeteer';
	 *
	 * (async () => {
	 *   const browser = await puppeteer.launch();
	 *   const page = await browser.newPage();
	 *   await page.goto('https://example.com');
	 *   const hrefElement = await page.$('a');
	 *   await hrefElement.click();
	 *   // ...
	 * })();
	 * ```
	 *
	 * ElementHandle prevents the DOM element from being garbage-collected unless the
	 * handle is {@link JSHandle.dispose | disposed}. ElementHandles are auto-disposed
	 * when their origin frame gets navigated.
	 *
	 * ElementHandle instances can be used as arguments in {@link Page.$eval} and
	 * {@link Page.evaluate} methods.
	 *
	 * If you're using TypeScript, ElementHandle takes a generic argument that
	 * denotes the type of element the handle is holding within. For example, if you
	 * have a handle to a `<select>` element, you can type it as
	 * `ElementHandle<HTMLSelectElement>` and you get some nicer type checks.
	 *
	 * @public
	 */
	let ElementHandle = (() => {
	    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1;
	    let _classSuper = JSHandle_js_1.JSHandle;
	    let _instanceExtraInitializers = [];
	    let _getProperty_decorators;
	    let _getProperties_decorators;
	    let _jsonValue_decorators;
	    let _$_decorators;
	    let _$$_decorators;
	    let _$x_decorators;
	    let _waitForSelector_decorators;
	    let _isVisible_decorators;
	    let _isHidden_decorators;
	    let _waitForXPath_decorators;
	    let _toElement_decorators;
	    let _clickablePoint_decorators;
	    let _hover_decorators;
	    let _click_decorators;
	    let _select_decorators;
	    let _tap_decorators;
	    let _touchStart_decorators;
	    let _touchMove_decorators;
	    let _touchEnd_decorators;
	    let _focus_decorators;
	    let _type_decorators;
	    let _press_decorators;
	    let _boundingBox_decorators;
	    let _boxModel_decorators;
	    let _isIntersectingViewport_decorators;
	    let _scrollIntoView_decorators;
	    return class ElementHandle extends _classSuper {
	        static {
	            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
	            _getProperty_decorators = [(_a = ElementHandle).bindIsolatedHandle.bind(_a)];
	            _getProperties_decorators = [(_b = ElementHandle).bindIsolatedHandle.bind(_b)];
	            _jsonValue_decorators = [(_c = ElementHandle).bindIsolatedHandle.bind(_c)];
	            _$_decorators = [(_d = ElementHandle).bindIsolatedHandle.bind(_d)];
	            _$$_decorators = [(_e = ElementHandle).bindIsolatedHandle.bind(_e)];
	            _$x_decorators = [(_f = ElementHandle).bindIsolatedHandle.bind(_f)];
	            _waitForSelector_decorators = [(_g = ElementHandle).bindIsolatedHandle.bind(_g)];
	            _isVisible_decorators = [(_h = ElementHandle).bindIsolatedHandle.bind(_h)];
	            _isHidden_decorators = [(_j = ElementHandle).bindIsolatedHandle.bind(_j)];
	            _waitForXPath_decorators = [(_k = ElementHandle).bindIsolatedHandle.bind(_k)];
	            _toElement_decorators = [(_l = ElementHandle).bindIsolatedHandle.bind(_l)];
	            _clickablePoint_decorators = [(_m = ElementHandle).bindIsolatedHandle.bind(_m)];
	            _hover_decorators = [(_o = ElementHandle).bindIsolatedHandle.bind(_o)];
	            _click_decorators = [(_p = ElementHandle).bindIsolatedHandle.bind(_p)];
	            _select_decorators = [(_q = ElementHandle).bindIsolatedHandle.bind(_q)];
	            _tap_decorators = [(_r = ElementHandle).bindIsolatedHandle.bind(_r)];
	            _touchStart_decorators = [(_s = ElementHandle).bindIsolatedHandle.bind(_s)];
	            _touchMove_decorators = [(_t = ElementHandle).bindIsolatedHandle.bind(_t)];
	            _touchEnd_decorators = [(_u = ElementHandle).bindIsolatedHandle.bind(_u)];
	            _focus_decorators = [(_v = ElementHandle).bindIsolatedHandle.bind(_v)];
	            _type_decorators = [(_w = ElementHandle).bindIsolatedHandle.bind(_w)];
	            _press_decorators = [(_x = ElementHandle).bindIsolatedHandle.bind(_x)];
	            _boundingBox_decorators = [(_y = ElementHandle).bindIsolatedHandle.bind(_y)];
	            _boxModel_decorators = [(_z = ElementHandle).bindIsolatedHandle.bind(_z)];
	            _isIntersectingViewport_decorators = [(_0 = ElementHandle).bindIsolatedHandle.bind(_0)];
	            _scrollIntoView_decorators = [(_1 = ElementHandle).bindIsolatedHandle.bind(_1)];
	            __esDecorate(this, null, _getProperty_decorators, { kind: "method", name: "getProperty", static: false, private: false, access: { has: obj => "getProperty" in obj, get: obj => obj.getProperty }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _getProperties_decorators, { kind: "method", name: "getProperties", static: false, private: false, access: { has: obj => "getProperties" in obj, get: obj => obj.getProperties }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _jsonValue_decorators, { kind: "method", name: "jsonValue", static: false, private: false, access: { has: obj => "jsonValue" in obj, get: obj => obj.jsonValue }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _$_decorators, { kind: "method", name: "$", static: false, private: false, access: { has: obj => "$" in obj, get: obj => obj.$ }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _$$_decorators, { kind: "method", name: "$$", static: false, private: false, access: { has: obj => "$$" in obj, get: obj => obj.$$ }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _$x_decorators, { kind: "method", name: "$x", static: false, private: false, access: { has: obj => "$x" in obj, get: obj => obj.$x }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _waitForSelector_decorators, { kind: "method", name: "waitForSelector", static: false, private: false, access: { has: obj => "waitForSelector" in obj, get: obj => obj.waitForSelector }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _isVisible_decorators, { kind: "method", name: "isVisible", static: false, private: false, access: { has: obj => "isVisible" in obj, get: obj => obj.isVisible }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _isHidden_decorators, { kind: "method", name: "isHidden", static: false, private: false, access: { has: obj => "isHidden" in obj, get: obj => obj.isHidden }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _waitForXPath_decorators, { kind: "method", name: "waitForXPath", static: false, private: false, access: { has: obj => "waitForXPath" in obj, get: obj => obj.waitForXPath }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _toElement_decorators, { kind: "method", name: "toElement", static: false, private: false, access: { has: obj => "toElement" in obj, get: obj => obj.toElement }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _clickablePoint_decorators, { kind: "method", name: "clickablePoint", static: false, private: false, access: { has: obj => "clickablePoint" in obj, get: obj => obj.clickablePoint }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _hover_decorators, { kind: "method", name: "hover", static: false, private: false, access: { has: obj => "hover" in obj, get: obj => obj.hover }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _click_decorators, { kind: "method", name: "click", static: false, private: false, access: { has: obj => "click" in obj, get: obj => obj.click }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _select_decorators, { kind: "method", name: "select", static: false, private: false, access: { has: obj => "select" in obj, get: obj => obj.select }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _tap_decorators, { kind: "method", name: "tap", static: false, private: false, access: { has: obj => "tap" in obj, get: obj => obj.tap }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _touchStart_decorators, { kind: "method", name: "touchStart", static: false, private: false, access: { has: obj => "touchStart" in obj, get: obj => obj.touchStart }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _touchMove_decorators, { kind: "method", name: "touchMove", static: false, private: false, access: { has: obj => "touchMove" in obj, get: obj => obj.touchMove }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _touchEnd_decorators, { kind: "method", name: "touchEnd", static: false, private: false, access: { has: obj => "touchEnd" in obj, get: obj => obj.touchEnd }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _focus_decorators, { kind: "method", name: "focus", static: false, private: false, access: { has: obj => "focus" in obj, get: obj => obj.focus }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _type_decorators, { kind: "method", name: "type", static: false, private: false, access: { has: obj => "type" in obj, get: obj => obj.type }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _press_decorators, { kind: "method", name: "press", static: false, private: false, access: { has: obj => "press" in obj, get: obj => obj.press }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _boundingBox_decorators, { kind: "method", name: "boundingBox", static: false, private: false, access: { has: obj => "boundingBox" in obj, get: obj => obj.boundingBox }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _boxModel_decorators, { kind: "method", name: "boxModel", static: false, private: false, access: { has: obj => "boxModel" in obj, get: obj => obj.boxModel }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _isIntersectingViewport_decorators, { kind: "method", name: "isIntersectingViewport", static: false, private: false, access: { has: obj => "isIntersectingViewport" in obj, get: obj => obj.isIntersectingViewport }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _scrollIntoView_decorators, { kind: "method", name: "scrollIntoView", static: false, private: false, access: { has: obj => "scrollIntoView" in obj, get: obj => obj.scrollIntoView }, metadata: _metadata }, null, _instanceExtraInitializers);
	            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
	        }
	        /**
	         * A given method will have it's `this` replaced with an isolated version of
	         * `this` when decorated with this decorator.
	         *
	         * All changes of isolated `this` are reflected on the actual `this`.
	         *
	         * @internal
	         */
	        static bindIsolatedHandle(target, _) {
	            return async function (...args) {
	                const env_1 = { stack: [], error: void 0, hasError: false };
	                try {
	                    // If the handle is already isolated, then we don't need to adopt it
	                    // again.
	                    if (this.realm === this.frame.isolatedRealm()) {
	                        return await target.call(this, ...args);
	                    }
	                    const adoptedThis = __addDisposableResource(env_1, await this.frame.isolatedRealm().adoptHandle(this), false);
	                    const result = await target.call(adoptedThis, ...args);
	                    // If the function returns `adoptedThis`, then we return `this`.
	                    if (result === adoptedThis) {
	                        return this;
	                    }
	                    // If the function returns a handle, transfer it into the current realm.
	                    if (result instanceof JSHandle_js_1.JSHandle) {
	                        return await this.realm.transferHandle(result);
	                    }
	                    // If the function returns an array of handlers, transfer them into the
	                    // current realm.
	                    if (Array.isArray(result)) {
	                        await Promise.all(result.map(async (item, index, result) => {
	                            if (item instanceof JSHandle_js_1.JSHandle) {
	                                result[index] = await this.realm.transferHandle(item);
	                            }
	                        }));
	                    }
	                    if (result instanceof Map) {
	                        await Promise.all([...result.entries()].map(async ([key, value]) => {
	                            if (value instanceof JSHandle_js_1.JSHandle) {
	                                result.set(key, await this.realm.transferHandle(value));
	                            }
	                        }));
	                    }
	                    return result;
	                }
	                catch (e_1) {
	                    env_1.error = e_1;
	                    env_1.hasError = true;
	                }
	                finally {
	                    __disposeResources(env_1);
	                }
	            };
	        }
	        /**
	         * @internal
	         */
	        handle = (__runInitializers(this, _instanceExtraInitializers), void 0);
	        /**
	         * @internal
	         */
	        constructor(handle) {
	            super();
	            this.handle = handle;
	        }
	        /**
	         * @internal
	         */
	        get id() {
	            return this.handle.id;
	        }
	        /**
	         * @internal
	         */
	        get disposed() {
	            return this.handle.disposed;
	        }
	        /**
	         * @internal
	         */
	        async getProperty(propertyName) {
	            return await this.handle.getProperty(propertyName);
	        }
	        /**
	         * @internal
	         */
	        async getProperties() {
	            return await this.handle.getProperties();
	        }
	        /**
	         * @internal
	         */
	        async evaluate(pageFunction, ...args) {
	            return await this.handle.evaluate(pageFunction, ...args);
	        }
	        /**
	         * @internal
	         */
	        async evaluateHandle(pageFunction, ...args) {
	            return await this.handle.evaluateHandle(pageFunction, ...args);
	        }
	        /**
	         * @internal
	         */
	        async jsonValue() {
	            return await this.handle.jsonValue();
	        }
	        /**
	         * @internal
	         */
	        toString() {
	            return this.handle.toString();
	        }
	        /**
	         * @internal
	         */
	        remoteObject() {
	            return this.handle.remoteObject();
	        }
	        /**
	         * @internal
	         */
	        dispose() {
	            return this.handle.dispose();
	        }
	        /**
	         * @internal
	         */
	        asElement() {
	            return this;
	        }
	        /**
	         * Queries the current element for an element matching the given selector.
	         *
	         * @param selector - The selector to query for.
	         * @returns A {@link ElementHandle | element handle} to the first element
	         * matching the given selector. Otherwise, `null`.
	         */
	        async $(selector) {
	            const { updatedSelector, QueryHandler } = (0, GetQueryHandler_js_1.getQueryHandlerAndSelector)(selector);
	            return (await QueryHandler.queryOne(this, updatedSelector));
	        }
	        /**
	         * Queries the current element for all elements matching the given selector.
	         *
	         * @param selector - The selector to query for.
	         * @returns An array of {@link ElementHandle | element handles} that point to
	         * elements matching the given selector.
	         */
	        async $$(selector) {
	            const { updatedSelector, QueryHandler } = (0, GetQueryHandler_js_1.getQueryHandlerAndSelector)(selector);
	            return await AsyncIterableUtil_js_1.AsyncIterableUtil.collect(QueryHandler.queryAll(this, updatedSelector));
	        }
	        /**
	         * Runs the given function on the first element matching the given selector in
	         * the current element.
	         *
	         * If the given function returns a promise, then this method will wait till
	         * the promise resolves.
	         *
	         * @example
	         *
	         * ```ts
	         * const tweetHandle = await page.$('.tweet');
	         * expect(await tweetHandle.$eval('.like', node => node.innerText)).toBe(
	         *   '100'
	         * );
	         * expect(await tweetHandle.$eval('.retweets', node => node.innerText)).toBe(
	         *   '10'
	         * );
	         * ```
	         *
	         * @param selector - The selector to query for.
	         * @param pageFunction - The function to be evaluated in this element's page's
	         * context. The first element matching the selector will be passed in as the
	         * first argument.
	         * @param args - Additional arguments to pass to `pageFunction`.
	         * @returns A promise to the result of the function.
	         */
	        async $eval(selector, pageFunction, ...args) {
	            const env_2 = { stack: [], error: void 0, hasError: false };
	            try {
	                pageFunction = (0, util_js_1.withSourcePuppeteerURLIfNone)(this.$eval.name, pageFunction);
	                const elementHandle = __addDisposableResource(env_2, await this.$(selector), false);
	                if (!elementHandle) {
	                    throw new Error(`Error: failed to find element matching selector "${selector}"`);
	                }
	                return await elementHandle.evaluate(pageFunction, ...args);
	            }
	            catch (e_2) {
	                env_2.error = e_2;
	                env_2.hasError = true;
	            }
	            finally {
	                __disposeResources(env_2);
	            }
	        }
	        /**
	         * Runs the given function on an array of elements matching the given selector
	         * in the current element.
	         *
	         * If the given function returns a promise, then this method will wait till
	         * the promise resolves.
	         *
	         * @example
	         * HTML:
	         *
	         * ```html
	         * <div class="feed">
	         *   <div class="tweet">Hello!</div>
	         *   <div class="tweet">Hi!</div>
	         * </div>
	         * ```
	         *
	         * JavaScript:
	         *
	         * ```js
	         * const feedHandle = await page.$('.feed');
	         * expect(
	         *   await feedHandle.$$eval('.tweet', nodes => nodes.map(n => n.innerText))
	         * ).toEqual(['Hello!', 'Hi!']);
	         * ```
	         *
	         * @param selector - The selector to query for.
	         * @param pageFunction - The function to be evaluated in the element's page's
	         * context. An array of elements matching the given selector will be passed to
	         * the function as its first argument.
	         * @param args - Additional arguments to pass to `pageFunction`.
	         * @returns A promise to the result of the function.
	         */
	        async $$eval(selector, pageFunction, ...args) {
	            const env_3 = { stack: [], error: void 0, hasError: false };
	            try {
	                pageFunction = (0, util_js_1.withSourcePuppeteerURLIfNone)(this.$$eval.name, pageFunction);
	                const results = await this.$$(selector);
	                const elements = __addDisposableResource(env_3, await this.evaluateHandle((_, ...elements) => {
	                    return elements;
	                }, ...results), false);
	                const [result] = await Promise.all([
	                    elements.evaluate(pageFunction, ...args),
	                    ...results.map(results => {
	                        return results.dispose();
	                    }),
	                ]);
	                return result;
	            }
	            catch (e_3) {
	                env_3.error = e_3;
	                env_3.hasError = true;
	            }
	            finally {
	                __disposeResources(env_3);
	            }
	        }
	        /**
	         * @deprecated Use {@link ElementHandle.$$} with the `xpath` prefix.
	         *
	         * Example: `await elementHandle.$$('xpath/' + xpathExpression)`
	         *
	         * The method evaluates the XPath expression relative to the elementHandle.
	         * If `xpath` starts with `//` instead of `.//`, the dot will be appended
	         * automatically.
	         *
	         * If there are no such elements, the method will resolve to an empty array.
	         * @param expression - Expression to {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/evaluate | evaluate}
	         */
	        async $x(expression) {
	            if (expression.startsWith('//')) {
	                expression = `.${expression}`;
	            }
	            return await this.$$(`xpath/${expression}`);
	        }
	        /**
	         * Wait for an element matching the given selector to appear in the current
	         * element.
	         *
	         * Unlike {@link Frame.waitForSelector}, this method does not work across
	         * navigations or if the element is detached from DOM.
	         *
	         * @example
	         *
	         * ```ts
	         * import puppeteer from 'puppeteer';
	         *
	         * (async () => {
	         *   const browser = await puppeteer.launch();
	         *   const page = await browser.newPage();
	         *   let currentURL;
	         *   page
	         *     .mainFrame()
	         *     .waitForSelector('img')
	         *     .then(() => console.log('First URL with image: ' + currentURL));
	         *
	         *   for (currentURL of [
	         *     'https://example.com',
	         *     'https://google.com',
	         *     'https://bbc.com',
	         *   ]) {
	         *     await page.goto(currentURL);
	         *   }
	         *   await browser.close();
	         * })();
	         * ```
	         *
	         * @param selector - The selector to query and wait for.
	         * @param options - Options for customizing waiting behavior.
	         * @returns An element matching the given selector.
	         * @throws Throws if an element matching the given selector doesn't appear.
	         */
	        async waitForSelector(selector, options = {}) {
	            const { updatedSelector, QueryHandler } = (0, GetQueryHandler_js_1.getQueryHandlerAndSelector)(selector);
	            return (await QueryHandler.waitFor(this, updatedSelector, options));
	        }
	        async #checkVisibility(visibility) {
	            return await this.evaluate(async (element, PuppeteerUtil, visibility) => {
	                return Boolean(PuppeteerUtil.checkVisibility(element, visibility));
	            }, LazyArg_js_1.LazyArg.create(context => {
	                return context.puppeteerUtil;
	            }), visibility);
	        }
	        /**
	         * Checks if an element is visible using the same mechanism as
	         * {@link ElementHandle.waitForSelector}.
	         */
	        async isVisible() {
	            return await this.#checkVisibility(true);
	        }
	        /**
	         * Checks if an element is hidden using the same mechanism as
	         * {@link ElementHandle.waitForSelector}.
	         */
	        async isHidden() {
	            return await this.#checkVisibility(false);
	        }
	        /**
	         * @deprecated Use {@link ElementHandle.waitForSelector} with the `xpath`
	         * prefix.
	         *
	         * Example: `await elementHandle.waitForSelector('xpath/' + xpathExpression)`
	         *
	         * The method evaluates the XPath expression relative to the elementHandle.
	         *
	         * Wait for the `xpath` within the element. If at the moment of calling the
	         * method the `xpath` already exists, the method will return immediately. If
	         * the `xpath` doesn't appear after the `timeout` milliseconds of waiting, the
	         * function will throw.
	         *
	         * If `xpath` starts with `//` instead of `.//`, the dot will be appended
	         * automatically.
	         *
	         * @example
	         * This method works across navigation.
	         *
	         * ```ts
	         * import puppeteer from 'puppeteer';
	         * (async () => {
	         *   const browser = await puppeteer.launch();
	         *   const page = await browser.newPage();
	         *   let currentURL;
	         *   page
	         *     .waitForXPath('//img')
	         *     .then(() => console.log('First URL with image: ' + currentURL));
	         *   for (currentURL of [
	         *     'https://example.com',
	         *     'https://google.com',
	         *     'https://bbc.com',
	         *   ]) {
	         *     await page.goto(currentURL);
	         *   }
	         *   await browser.close();
	         * })();
	         * ```
	         *
	         * @param xpath - A
	         * {@link https://developer.mozilla.org/en-US/docs/Web/XPath | xpath} of an
	         * element to wait for
	         * @param options - Optional waiting parameters
	         * @returns Promise which resolves when element specified by xpath string is
	         * added to DOM. Resolves to `null` if waiting for `hidden: true` and xpath is
	         * not found in DOM, otherwise resolves to `ElementHandle`.
	         * @remarks
	         * The optional Argument `options` have properties:
	         *
	         * - `visible`: A boolean to wait for element to be present in DOM and to be
	         *   visible, i.e. to not have `display: none` or `visibility: hidden` CSS
	         *   properties. Defaults to `false`.
	         *
	         * - `hidden`: A boolean wait for element to not be found in the DOM or to be
	         *   hidden, i.e. have `display: none` or `visibility: hidden` CSS properties.
	         *   Defaults to `false`.
	         *
	         * - `timeout`: A number which is maximum time to wait for in milliseconds.
	         *   Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The
	         *   default value can be changed by using the {@link Page.setDefaultTimeout}
	         *   method.
	         */
	        async waitForXPath(xpath, options = {}) {
	            if (xpath.startsWith('//')) {
	                xpath = `.${xpath}`;
	            }
	            return await this.waitForSelector(`xpath/${xpath}`, options);
	        }
	        /**
	         * Converts the current handle to the given element type.
	         *
	         * @example
	         *
	         * ```ts
	         * const element: ElementHandle<Element> = await page.$(
	         *   '.class-name-of-anchor'
	         * );
	         * // DO NOT DISPOSE `element`, this will be always be the same handle.
	         * const anchor: ElementHandle<HTMLAnchorElement> =
	         *   await element.toElement('a');
	         * ```
	         *
	         * @param tagName - The tag name of the desired element type.
	         * @throws An error if the handle does not match. **The handle will not be
	         * automatically disposed.**
	         */
	        async toElement(tagName) {
	            const isMatchingTagName = await this.evaluate((node, tagName) => {
	                return node.nodeName === tagName.toUpperCase();
	            }, tagName);
	            if (!isMatchingTagName) {
	                throw new Error(`Element is not a(n) \`${tagName}\` element`);
	            }
	            return this;
	        }
	        /**
	         * Returns the middle point within an element unless a specific offset is provided.
	         */
	        async clickablePoint(offset) {
	            const box = await this.#clickableBox();
	            if (!box) {
	                throw new Error('Node is either not clickable or not an Element');
	            }
	            if (offset !== undefined) {
	                return {
	                    x: box.x + offset.x,
	                    y: box.y + offset.y,
	                };
	            }
	            return {
	                x: box.x + box.width / 2,
	                y: box.y + box.height / 2,
	            };
	        }
	        /**
	         * This method scrolls element into view if needed, and then
	         * uses {@link Page} to hover over the center of the element.
	         * If the element is detached from DOM, the method throws an error.
	         */
	        async hover() {
	            await this.scrollIntoViewIfNeeded();
	            const { x, y } = await this.clickablePoint();
	            await this.frame.page().mouse.move(x, y);
	        }
	        /**
	         * This method scrolls element into view if needed, and then
	         * uses {@link Page | Page.mouse} to click in the center of the element.
	         * If the element is detached from DOM, the method throws an error.
	         */
	        async click(options = {}) {
	            await this.scrollIntoViewIfNeeded();
	            const { x, y } = await this.clickablePoint(options.offset);
	            await this.frame.page().mouse.click(x, y, options);
	        }
	        async drag() {
	            throw new Error('Not implemented');
	        }
	        async dragEnter() {
	            throw new Error('Not implemented');
	        }
	        async dragOver() {
	            throw new Error('Not implemented');
	        }
	        async drop() {
	            throw new Error('Not implemented');
	        }
	        async dragAndDrop() {
	            throw new Error('Not implemented');
	        }
	        /**
	         * Triggers a `change` and `input` event once all the provided options have been
	         * selected. If there's no `<select>` element matching `selector`, the method
	         * throws an error.
	         *
	         * @example
	         *
	         * ```ts
	         * handle.select('blue'); // single selection
	         * handle.select('red', 'green', 'blue'); // multiple selections
	         * ```
	         *
	         * @param values - Values of options to select. If the `<select>` has the
	         * `multiple` attribute, all values are considered, otherwise only the first
	         * one is taken into account.
	         */
	        async select(...values) {
	            for (const value of values) {
	                (0, assert_js_1.assert)((0, util_js_1.isString)(value), 'Values must be strings. Found value "' +
	                    value +
	                    '" of type "' +
	                    typeof value +
	                    '"');
	            }
	            return await this.evaluate((element, vals) => {
	                const values = new Set(vals);
	                if (!(element instanceof HTMLSelectElement)) {
	                    throw new Error('Element is not a <select> element.');
	                }
	                const selectedValues = new Set();
	                if (!element.multiple) {
	                    for (const option of element.options) {
	                        option.selected = false;
	                    }
	                    for (const option of element.options) {
	                        if (values.has(option.value)) {
	                            option.selected = true;
	                            selectedValues.add(option.value);
	                            break;
	                        }
	                    }
	                }
	                else {
	                    for (const option of element.options) {
	                        option.selected = values.has(option.value);
	                        if (option.selected) {
	                            selectedValues.add(option.value);
	                        }
	                    }
	                }
	                element.dispatchEvent(new Event('input', { bubbles: true }));
	                element.dispatchEvent(new Event('change', { bubbles: true }));
	                return [...selectedValues.values()];
	            }, values);
	        }
	        async uploadFile() {
	            throw new Error('Not implemented');
	        }
	        /**
	         * This method scrolls element into view if needed, and then uses
	         * {@link Touchscreen.tap} to tap in the center of the element.
	         * If the element is detached from DOM, the method throws an error.
	         */
	        async tap() {
	            await this.scrollIntoViewIfNeeded();
	            const { x, y } = await this.clickablePoint();
	            await this.frame.page().touchscreen.touchStart(x, y);
	            await this.frame.page().touchscreen.touchEnd();
	        }
	        async touchStart() {
	            await this.scrollIntoViewIfNeeded();
	            const { x, y } = await this.clickablePoint();
	            await this.frame.page().touchscreen.touchStart(x, y);
	        }
	        async touchMove() {
	            await this.scrollIntoViewIfNeeded();
	            const { x, y } = await this.clickablePoint();
	            await this.frame.page().touchscreen.touchMove(x, y);
	        }
	        async touchEnd() {
	            await this.scrollIntoViewIfNeeded();
	            await this.frame.page().touchscreen.touchEnd();
	        }
	        /**
	         * Calls {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus | focus} on the element.
	         */
	        async focus() {
	            await this.evaluate(element => {
	                if (!(element instanceof HTMLElement)) {
	                    throw new Error('Cannot focus non-HTMLElement');
	                }
	                return element.focus();
	            });
	        }
	        /**
	         * Focuses the element, and then sends a `keydown`, `keypress`/`input`, and
	         * `keyup` event for each character in the text.
	         *
	         * To press a special key, like `Control` or `ArrowDown`,
	         * use {@link ElementHandle.press}.
	         *
	         * @example
	         *
	         * ```ts
	         * await elementHandle.type('Hello'); // Types instantly
	         * await elementHandle.type('World', {delay: 100}); // Types slower, like a user
	         * ```
	         *
	         * @example
	         * An example of typing into a text field and then submitting the form:
	         *
	         * ```ts
	         * const elementHandle = await page.$('input');
	         * await elementHandle.type('some text');
	         * await elementHandle.press('Enter');
	         * ```
	         *
	         * @param options - Delay in milliseconds. Defaults to 0.
	         */
	        async type(text, options) {
	            await this.focus();
	            await this.frame.page().keyboard.type(text, options);
	        }
	        /**
	         * Focuses the element, and then uses {@link Keyboard.down} and {@link Keyboard.up}.
	         *
	         * @remarks
	         * If `key` is a single character and no modifier keys besides `Shift`
	         * are being held down, a `keypress`/`input` event will also be generated.
	         * The `text` option can be specified to force an input event to be generated.
	         *
	         * **NOTE** Modifier keys DO affect `elementHandle.press`. Holding down `Shift`
	         * will type the text in upper case.
	         *
	         * @param key - Name of key to press, such as `ArrowLeft`.
	         * See {@link KeyInput} for a list of all key names.
	         */
	        async press(key, options) {
	            await this.focus();
	            await this.frame.page().keyboard.press(key, options);
	        }
	        async #clickableBox() {
	            const boxes = await this.evaluate(element => {
	                if (!(element instanceof Element)) {
	                    return null;
	                }
	                return [...element.getClientRects()].map(rect => {
	                    return { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
	                });
	            });
	            if (!boxes?.length) {
	                return null;
	            }
	            await this.#intersectBoundingBoxesWithFrame(boxes);
	            let frame = this.frame;
	            let parentFrame;
	            while ((parentFrame = frame?.parentFrame())) {
	                const env_4 = { stack: [], error: void 0, hasError: false };
	                try {
	                    const handle = __addDisposableResource(env_4, await frame.frameElement(), false);
	                    if (!handle) {
	                        throw new Error('Unsupported frame type');
	                    }
	                    const parentBox = await handle.evaluate(element => {
	                        // Element is not visible.
	                        if (element.getClientRects().length === 0) {
	                            return null;
	                        }
	                        const rect = element.getBoundingClientRect();
	                        const style = window.getComputedStyle(element);
	                        return {
	                            left: rect.left +
	                                parseInt(style.paddingLeft, 10) +
	                                parseInt(style.borderLeftWidth, 10),
	                            top: rect.top +
	                                parseInt(style.paddingTop, 10) +
	                                parseInt(style.borderTopWidth, 10),
	                        };
	                    });
	                    if (!parentBox) {
	                        return null;
	                    }
	                    for (const box of boxes) {
	                        box.x += parentBox.left;
	                        box.y += parentBox.top;
	                    }
	                    await handle.#intersectBoundingBoxesWithFrame(boxes);
	                    frame = parentFrame;
	                }
	                catch (e_4) {
	                    env_4.error = e_4;
	                    env_4.hasError = true;
	                }
	                finally {
	                    __disposeResources(env_4);
	                }
	            }
	            const box = boxes.find(box => {
	                return box.width >= 1 && box.height >= 1;
	            });
	            if (!box) {
	                return null;
	            }
	            return {
	                x: box.x,
	                y: box.y,
	                height: box.height,
	                width: box.width,
	            };
	        }
	        async #intersectBoundingBoxesWithFrame(boxes) {
	            const { documentWidth, documentHeight } = await this.frame
	                .isolatedRealm()
	                .evaluate(() => {
	                return {
	                    documentWidth: document.documentElement.clientWidth,
	                    documentHeight: document.documentElement.clientHeight,
	                };
	            });
	            for (const box of boxes) {
	                intersectBoundingBox(box, documentWidth, documentHeight);
	            }
	        }
	        /**
	         * This method returns the bounding box of the element (relative to the main frame),
	         * or `null` if the element is not visible.
	         */
	        async boundingBox() {
	            const box = await this.evaluate(element => {
	                if (!(element instanceof Element)) {
	                    return null;
	                }
	                // Element is not visible.
	                if (element.getClientRects().length === 0) {
	                    return null;
	                }
	                const rect = element.getBoundingClientRect();
	                return { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
	            });
	            if (!box) {
	                return null;
	            }
	            const offset = await this.#getTopLeftCornerOfFrame();
	            if (!offset) {
	                return null;
	            }
	            return {
	                x: box.x + offset.x,
	                y: box.y + offset.y,
	                height: box.height,
	                width: box.width,
	            };
	        }
	        /**
	         * This method returns boxes of the element, or `null` if the element is not visible.
	         *
	         * @remarks
	         *
	         * Boxes are represented as an array of points;
	         * Each Point is an object `{x, y}`. Box points are sorted clock-wise.
	         */
	        async boxModel() {
	            const model = await this.evaluate(element => {
	                if (!(element instanceof Element)) {
	                    return null;
	                }
	                // Element is not visible.
	                if (element.getClientRects().length === 0) {
	                    return null;
	                }
	                const rect = element.getBoundingClientRect();
	                const style = window.getComputedStyle(element);
	                const offsets = {
	                    padding: {
	                        left: parseInt(style.paddingLeft, 10),
	                        top: parseInt(style.paddingTop, 10),
	                        right: parseInt(style.paddingRight, 10),
	                        bottom: parseInt(style.paddingBottom, 10),
	                    },
	                    margin: {
	                        left: -parseInt(style.marginLeft, 10),
	                        top: -parseInt(style.marginTop, 10),
	                        right: -parseInt(style.marginRight, 10),
	                        bottom: -parseInt(style.marginBottom, 10),
	                    },
	                    border: {
	                        left: parseInt(style.borderLeft, 10),
	                        top: parseInt(style.borderTop, 10),
	                        right: parseInt(style.borderRight, 10),
	                        bottom: parseInt(style.borderBottom, 10),
	                    },
	                };
	                const border = [
	                    { x: rect.left, y: rect.top },
	                    { x: rect.left + rect.width, y: rect.top },
	                    { x: rect.left + rect.width, y: rect.top + rect.bottom },
	                    { x: rect.left, y: rect.top + rect.bottom },
	                ];
	                const padding = transformQuadWithOffsets(border, offsets.border);
	                const content = transformQuadWithOffsets(padding, offsets.padding);
	                const margin = transformQuadWithOffsets(border, offsets.margin);
	                return {
	                    content,
	                    padding,
	                    border,
	                    margin,
	                    width: rect.width,
	                    height: rect.height,
	                };
	                function transformQuadWithOffsets(quad, offsets) {
	                    return [
	                        {
	                            x: quad[0].x + offsets.left,
	                            y: quad[0].y + offsets.top,
	                        },
	                        {
	                            x: quad[1].x - offsets.right,
	                            y: quad[1].y + offsets.top,
	                        },
	                        {
	                            x: quad[2].x - offsets.right,
	                            y: quad[2].y - offsets.bottom,
	                        },
	                        {
	                            x: quad[3].x + offsets.left,
	                            y: quad[3].y - offsets.bottom,
	                        },
	                    ];
	                }
	            });
	            if (!model) {
	                return null;
	            }
	            const offset = await this.#getTopLeftCornerOfFrame();
	            if (!offset) {
	                return null;
	            }
	            for (const attribute of [
	                'content',
	                'padding',
	                'border',
	                'margin',
	            ]) {
	                for (const point of model[attribute]) {
	                    point.x += offset.x;
	                    point.y += offset.y;
	                }
	            }
	            return model;
	        }
	        async #getTopLeftCornerOfFrame() {
	            const point = { x: 0, y: 0 };
	            let frame = this.frame;
	            let parentFrame;
	            while ((parentFrame = frame?.parentFrame())) {
	                const env_5 = { stack: [], error: void 0, hasError: false };
	                try {
	                    const handle = __addDisposableResource(env_5, await frame.frameElement(), false);
	                    if (!handle) {
	                        throw new Error('Unsupported frame type');
	                    }
	                    const parentBox = await handle.evaluate(element => {
	                        // Element is not visible.
	                        if (element.getClientRects().length === 0) {
	                            return null;
	                        }
	                        const rect = element.getBoundingClientRect();
	                        const style = window.getComputedStyle(element);
	                        return {
	                            left: rect.left +
	                                parseInt(style.paddingLeft, 10) +
	                                parseInt(style.borderLeftWidth, 10),
	                            top: rect.top +
	                                parseInt(style.paddingTop, 10) +
	                                parseInt(style.borderTopWidth, 10),
	                        };
	                    });
	                    if (!parentBox) {
	                        return null;
	                    }
	                    point.x += parentBox.left;
	                    point.y += parentBox.top;
	                    frame = parentFrame;
	                }
	                catch (e_5) {
	                    env_5.error = e_5;
	                    env_5.hasError = true;
	                }
	                finally {
	                    __disposeResources(env_5);
	                }
	            }
	            return point;
	        }
	        async screenshot() {
	            throw new Error('Not implemented');
	        }
	        /**
	         * @internal
	         */
	        async assertConnectedElement() {
	            const error = await this.evaluate(async (element) => {
	                if (!element.isConnected) {
	                    return 'Node is detached from document';
	                }
	                if (element.nodeType !== Node.ELEMENT_NODE) {
	                    return 'Node is not of type HTMLElement';
	                }
	                return;
	            });
	            if (error) {
	                throw new Error(error);
	            }
	        }
	        /**
	         * @internal
	         */
	        async scrollIntoViewIfNeeded() {
	            if (await this.isIntersectingViewport({
	                threshold: 1,
	            })) {
	                return;
	            }
	            await this.scrollIntoView();
	        }
	        /**
	         * Resolves to true if the element is visible in the current viewport. If an
	         * element is an SVG, we check if the svg owner element is in the viewport
	         * instead. See https://crbug.com/963246.
	         *
	         * @param options - Threshold for the intersection between 0 (no intersection) and 1
	         * (full intersection). Defaults to 1.
	         */
	        async isIntersectingViewport(options = {}) {
	            const env_6 = { stack: [], error: void 0, hasError: false };
	            try {
	                await this.assertConnectedElement();
	                // eslint-disable-next-line rulesdir/use-using -- Returns `this`.
	                const handle = await this.#asSVGElementHandle();
	                const target = __addDisposableResource(env_6, handle && (await handle.#getOwnerSVGElement()), false);
	                return await (target ?? this).evaluate(async (element, threshold) => {
	                    const visibleRatio = await new Promise(resolve => {
	                        const observer = new IntersectionObserver(entries => {
	                            resolve(entries[0].intersectionRatio);
	                            observer.disconnect();
	                        });
	                        observer.observe(element);
	                    });
	                    return threshold === 1 ? visibleRatio === 1 : visibleRatio > threshold;
	                }, options.threshold ?? 0);
	            }
	            catch (e_6) {
	                env_6.error = e_6;
	                env_6.hasError = true;
	            }
	            finally {
	                __disposeResources(env_6);
	            }
	        }
	        /**
	         * Scrolls the element into view using either the automation protocol client
	         * or by calling element.scrollIntoView.
	         */
	        async scrollIntoView() {
	            await this.assertConnectedElement();
	            await this.evaluate(async (element) => {
	                element.scrollIntoView({
	                    block: 'center',
	                    inline: 'center',
	                    behavior: 'instant',
	                });
	            });
	        }
	        /**
	         * Returns true if an element is an SVGElement (included svg, path, rect
	         * etc.).
	         */
	        async #asSVGElementHandle() {
	            if (await this.evaluate(element => {
	                return element instanceof SVGElement;
	            })) {
	                return this;
	            }
	            else {
	                return null;
	            }
	        }
	        async #getOwnerSVGElement() {
	            // SVGSVGElement.ownerSVGElement === null.
	            return await this.evaluateHandle(element => {
	                if (element instanceof SVGSVGElement) {
	                    return element;
	                }
	                return element.ownerSVGElement;
	            });
	        }
	    };
	})();
	ElementHandle$1.ElementHandle = ElementHandle;
	function intersectBoundingBox(box, width, height) {
	    box.width = Math.max(box.x >= 0
	        ? Math.min(width - box.x, box.width)
	        : Math.min(width, box.width + box.x), 0);
	    box.height = Math.max(box.y >= 0
	        ? Math.min(height - box.y, box.height)
	        : Math.min(height, box.height + box.y), 0);
	}
	
	return ElementHandle$1;
}

var JSHandle$1 = {};

var hasRequiredJSHandle$1;

function requireJSHandle$1 () {
	if (hasRequiredJSHandle$1) return JSHandle$1;
	hasRequiredJSHandle$1 = 1;
	/**
	 * Copyright 2019 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(JSHandle$1, "__esModule", { value: true });
	JSHandle$1.CDPJSHandle = void 0;
	const JSHandle_js_1 = requireJSHandle$2();
	const util_js_1 = requireUtil();
	/**
	 * @internal
	 */
	class CDPJSHandle extends JSHandle_js_1.JSHandle {
	    #disposed = false;
	    #remoteObject;
	    #world;
	    constructor(world, remoteObject) {
	        super();
	        this.#world = world;
	        this.#remoteObject = remoteObject;
	    }
	    get disposed() {
	        return this.#disposed;
	    }
	    get realm() {
	        return this.#world;
	    }
	    get client() {
	        return this.realm.environment.client;
	    }
	    async jsonValue() {
	        if (!this.#remoteObject.objectId) {
	            return (0, util_js_1.valueFromRemoteObject)(this.#remoteObject);
	        }
	        const value = await this.evaluate(object => {
	            return object;
	        });
	        if (value === undefined) {
	            throw new Error('Could not serialize referenced object');
	        }
	        return value;
	    }
	    /**
	     * Either `null` or the handle itself if the handle is an
	     * instance of {@link ElementHandle}.
	     */
	    asElement() {
	        return null;
	    }
	    async dispose() {
	        if (this.#disposed) {
	            return;
	        }
	        this.#disposed = true;
	        await (0, util_js_1.releaseObject)(this.client, this.#remoteObject);
	    }
	    toString() {
	        if (!this.#remoteObject.objectId) {
	            return 'JSHandle:' + (0, util_js_1.valueFromRemoteObject)(this.#remoteObject);
	        }
	        const type = this.#remoteObject.subtype || this.#remoteObject.type;
	        return 'JSHandle@' + type;
	    }
	    get id() {
	        return this.#remoteObject.objectId;
	    }
	    remoteObject() {
	        return this.#remoteObject;
	    }
	}
	JSHandle$1.CDPJSHandle = CDPJSHandle;
	
	return JSHandle$1;
}

var hasRequiredElementHandle$1;

function requireElementHandle$1 () {
	if (hasRequiredElementHandle$1) return ElementHandle$2;
	hasRequiredElementHandle$1 = 1;
	/**
	 * Copyright 2019 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __runInitializers = (commonjsGlobal && commonjsGlobal.__runInitializers) || function (thisArg, initializers, value) {
	    var useValue = arguments.length > 2;
	    for (var i = 0; i < initializers.length; i++) {
	        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
	    }
	    return useValue ? value : void 0;
	};
	var __esDecorate = (commonjsGlobal && commonjsGlobal.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
	    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
	    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
	    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
	    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
	    var _, done = false;
	    for (var i = decorators.length - 1; i >= 0; i--) {
	        var context = {};
	        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
	        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
	        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
	        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
	        if (kind === "accessor") {
	            if (result === void 0) continue;
	            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
	            if (_ = accept(result.get)) descriptor.get = _;
	            if (_ = accept(result.set)) descriptor.set = _;
	            if (_ = accept(result.init)) initializers.unshift(_);
	        }
	        else if (_ = accept(result)) {
	            if (kind === "field") initializers.unshift(_);
	            else descriptor[key] = _;
	        }
	    }
	    if (target) Object.defineProperty(target, contextIn.name, descriptor);
	    done = true;
	};
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(ElementHandle$2, "__esModule", { value: true });
	ElementHandle$2.CDPElementHandle = void 0;
	const ElementHandle_js_1 = requireElementHandle$2();
	const assert_js_1 = assert$1;
	const decorators_js_1 = decorators;
	const JSHandle_js_1 = requireJSHandle$1();
	const util_js_1 = requireUtil();
	/**
	 * The CDPElementHandle extends ElementHandle now to keep compatibility
	 * with `instanceof` because of that we need to have methods for
	 * CDPJSHandle to in this implementation as well.
	 *
	 * @internal
	 */
	let CDPElementHandle = (() => {
	    var _a, _b, _c, _d, _e, _f, _g, _h;
	    let _classSuper = ElementHandle_js_1.ElementHandle;
	    let _instanceExtraInitializers = [];
	    let _contentFrame_decorators;
	    let _scrollIntoView_decorators;
	    let _drag_decorators;
	    let _dragEnter_decorators;
	    let _dragOver_decorators;
	    let _drop_decorators;
	    let _dragAndDrop_decorators;
	    let _uploadFile_decorators;
	    let _screenshot_decorators;
	    let _autofill_decorators;
	    return class CDPElementHandle extends _classSuper {
	        static {
	            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
	            _contentFrame_decorators = [(0, decorators_js_1.throwIfDisposed)()];
	            _scrollIntoView_decorators = [(0, decorators_js_1.throwIfDisposed)(), (_a = ElementHandle_js_1.ElementHandle).bindIsolatedHandle.bind(_a)];
	            _drag_decorators = [(0, decorators_js_1.throwIfDisposed)(), (_b = ElementHandle_js_1.ElementHandle).bindIsolatedHandle.bind(_b)];
	            _dragEnter_decorators = [(0, decorators_js_1.throwIfDisposed)(), (_c = ElementHandle_js_1.ElementHandle).bindIsolatedHandle.bind(_c)];
	            _dragOver_decorators = [(0, decorators_js_1.throwIfDisposed)(), (_d = ElementHandle_js_1.ElementHandle).bindIsolatedHandle.bind(_d)];
	            _drop_decorators = [(0, decorators_js_1.throwIfDisposed)(), (_e = ElementHandle_js_1.ElementHandle).bindIsolatedHandle.bind(_e)];
	            _dragAndDrop_decorators = [(0, decorators_js_1.throwIfDisposed)(), (_f = ElementHandle_js_1.ElementHandle).bindIsolatedHandle.bind(_f)];
	            _uploadFile_decorators = [(0, decorators_js_1.throwIfDisposed)(), (_g = ElementHandle_js_1.ElementHandle).bindIsolatedHandle.bind(_g)];
	            _screenshot_decorators = [(0, decorators_js_1.throwIfDisposed)(), (_h = ElementHandle_js_1.ElementHandle).bindIsolatedHandle.bind(_h)];
	            _autofill_decorators = [(0, decorators_js_1.throwIfDisposed)()];
	            __esDecorate(this, null, _contentFrame_decorators, { kind: "method", name: "contentFrame", static: false, private: false, access: { has: obj => "contentFrame" in obj, get: obj => obj.contentFrame }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _scrollIntoView_decorators, { kind: "method", name: "scrollIntoView", static: false, private: false, access: { has: obj => "scrollIntoView" in obj, get: obj => obj.scrollIntoView }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _drag_decorators, { kind: "method", name: "drag", static: false, private: false, access: { has: obj => "drag" in obj, get: obj => obj.drag }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _dragEnter_decorators, { kind: "method", name: "dragEnter", static: false, private: false, access: { has: obj => "dragEnter" in obj, get: obj => obj.dragEnter }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _dragOver_decorators, { kind: "method", name: "dragOver", static: false, private: false, access: { has: obj => "dragOver" in obj, get: obj => obj.dragOver }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _drop_decorators, { kind: "method", name: "drop", static: false, private: false, access: { has: obj => "drop" in obj, get: obj => obj.drop }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _dragAndDrop_decorators, { kind: "method", name: "dragAndDrop", static: false, private: false, access: { has: obj => "dragAndDrop" in obj, get: obj => obj.dragAndDrop }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _uploadFile_decorators, { kind: "method", name: "uploadFile", static: false, private: false, access: { has: obj => "uploadFile" in obj, get: obj => obj.uploadFile }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _screenshot_decorators, { kind: "method", name: "screenshot", static: false, private: false, access: { has: obj => "screenshot" in obj, get: obj => obj.screenshot }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _autofill_decorators, { kind: "method", name: "autofill", static: false, private: false, access: { has: obj => "autofill" in obj, get: obj => obj.autofill }, metadata: _metadata }, null, _instanceExtraInitializers);
	            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
	        }
	        constructor(world, remoteObject) {
	            super(new JSHandle_js_1.CDPJSHandle(world, remoteObject));
	            __runInitializers(this, _instanceExtraInitializers);
	        }
	        get realm() {
	            return this.handle.realm;
	        }
	        get client() {
	            return this.handle.client;
	        }
	        remoteObject() {
	            return this.handle.remoteObject();
	        }
	        get #frameManager() {
	            return this.frame._frameManager;
	        }
	        get #page() {
	            return this.frame.page();
	        }
	        get frame() {
	            return this.realm.environment;
	        }
	        async contentFrame() {
	            const nodeInfo = await this.client.send('DOM.describeNode', {
	                objectId: this.id,
	            });
	            if (typeof nodeInfo.node.frameId !== 'string') {
	                return null;
	            }
	            return this.#frameManager.frame(nodeInfo.node.frameId);
	        }
	        async scrollIntoView() {
	            await this.assertConnectedElement();
	            try {
	                await this.client.send('DOM.scrollIntoViewIfNeeded', {
	                    objectId: this.id,
	                });
	            }
	            catch (error) {
	                (0, util_js_1.debugError)(error);
	                // Fallback to Element.scrollIntoView if DOM.scrollIntoViewIfNeeded is not supported
	                await super.scrollIntoView();
	            }
	        }
	        /**
	         * This method creates and captures a dragevent from the element.
	         */
	        async drag(target) {
	            (0, assert_js_1.assert)(this.#page.isDragInterceptionEnabled(), 'Drag Interception is not enabled!');
	            await this.scrollIntoViewIfNeeded();
	            const start = await this.clickablePoint();
	            return await this.#page.mouse.drag(start, target);
	        }
	        async dragEnter(data = { items: [], dragOperationsMask: 1 }) {
	            await this.scrollIntoViewIfNeeded();
	            const target = await this.clickablePoint();
	            await this.#page.mouse.dragEnter(target, data);
	        }
	        async dragOver(data = { items: [], dragOperationsMask: 1 }) {
	            await this.scrollIntoViewIfNeeded();
	            const target = await this.clickablePoint();
	            await this.#page.mouse.dragOver(target, data);
	        }
	        async drop(data = { items: [], dragOperationsMask: 1 }) {
	            await this.scrollIntoViewIfNeeded();
	            const destination = await this.clickablePoint();
	            await this.#page.mouse.drop(destination, data);
	        }
	        async dragAndDrop(target, options) {
	            (0, assert_js_1.assert)(this.#page.isDragInterceptionEnabled(), 'Drag Interception is not enabled!');
	            await this.scrollIntoViewIfNeeded();
	            const startPoint = await this.clickablePoint();
	            const targetPoint = await target.clickablePoint();
	            await this.#page.mouse.dragAndDrop(startPoint, targetPoint, options);
	        }
	        async uploadFile(...filePaths) {
	            const isMultiple = await this.evaluate(element => {
	                return element.multiple;
	            });
	            (0, assert_js_1.assert)(filePaths.length <= 1 || isMultiple, 'Multiple file uploads only work with <input type=file multiple>');
	            // Locate all files and confirm that they exist.
	            let path;
	            try {
	                path = await Promise.resolve().then(() => __importStar(require('path')));
	            }
	            catch (error) {
	                if (error instanceof TypeError) {
	                    throw new Error(`JSHandle#uploadFile can only be used in Node-like environments.`);
	                }
	                throw error;
	            }
	            const files = filePaths.map(filePath => {
	                if (path.win32.isAbsolute(filePath) || path.posix.isAbsolute(filePath)) {
	                    return filePath;
	                }
	                else {
	                    return path.resolve(filePath);
	                }
	            });
	            const { node } = await this.client.send('DOM.describeNode', {
	                objectId: this.id,
	            });
	            const { backendNodeId } = node;
	            /*  The zero-length array is a special case, it seems that
	                 DOM.setFileInputFiles does not actually update the files in that case,
	                 so the solution is to eval the element value to a new FileList directly.
	             */
	            if (files.length === 0) {
	                await this.evaluate(element => {
	                    element.files = new DataTransfer().files;
	                    // Dispatch events for this case because it should behave akin to a user action.
	                    element.dispatchEvent(new Event('input', { bubbles: true }));
	                    element.dispatchEvent(new Event('change', { bubbles: true }));
	                });
	            }
	            else {
	                await this.client.send('DOM.setFileInputFiles', {
	                    objectId: this.id,
	                    files,
	                    backendNodeId,
	                });
	            }
	        }
	        async screenshot(options = {}) {
	            let needsViewportReset = false;
	            let boundingBox = await this.boundingBox();
	            (0, assert_js_1.assert)(boundingBox, 'Node is either not visible or not an HTMLElement');
	            const viewport = this.#page.viewport();
	            if (viewport &&
	                (boundingBox.width > viewport.width ||
	                    boundingBox.height > viewport.height)) {
	                const newViewport = {
	                    width: Math.max(viewport.width, Math.ceil(boundingBox.width)),
	                    height: Math.max(viewport.height, Math.ceil(boundingBox.height)),
	                };
	                await this.#page.setViewport(Object.assign({}, viewport, newViewport));
	                needsViewportReset = true;
	            }
	            await this.scrollIntoViewIfNeeded();
	            boundingBox = await this.boundingBox();
	            (0, assert_js_1.assert)(boundingBox, 'Node is either not visible or not an HTMLElement');
	            (0, assert_js_1.assert)(boundingBox.width !== 0, 'Node has 0 width.');
	            (0, assert_js_1.assert)(boundingBox.height !== 0, 'Node has 0 height.');
	            const layoutMetrics = await this.client.send('Page.getLayoutMetrics');
	            // Fallback to `layoutViewport` in case of using Firefox.
	            const { pageX, pageY } = layoutMetrics.cssVisualViewport || layoutMetrics.layoutViewport;
	            const clip = Object.assign({}, boundingBox);
	            clip.x += pageX;
	            clip.y += pageY;
	            const imageData = await this.#page.screenshot(Object.assign({}, {
	                clip,
	            }, options));
	            if (needsViewportReset && viewport) {
	                await this.#page.setViewport(viewport);
	            }
	            return imageData;
	        }
	        async autofill(data) {
	            const nodeInfo = await this.client.send('DOM.describeNode', {
	                objectId: this.handle.id,
	            });
	            const fieldId = nodeInfo.node.backendNodeId;
	            const frameId = this.frame._id;
	            await this.client.send('Autofill.trigger', {
	                fieldId,
	                frameId,
	                card: data.creditCard,
	            });
	        }
	    };
	})();
	ElementHandle$2.CDPElementHandle = CDPElementHandle;
	
	return ElementHandle$2;
}

var hasRequiredUtil;

function requireUtil () {
	if (hasRequiredUtil) return util$1;
	hasRequiredUtil = 1;
	(function (exports) {
		/**
		 * Copyright 2017 Google Inc. All rights reserved.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *     http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
		    Object.defineProperty(o, "default", { enumerable: true, value: v });
		}) : function(o, v) {
		    o["default"] = v;
		});
		var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
		    if (mod && mod.__esModule) return mod;
		    var result = {};
		    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		    __setModuleDefault(result, mod);
		    return result;
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.timeout = exports.Mutex = exports.validateDialogType = exports.getPageContent = exports.setPageContent = exports.getReadableFromProtocolStream = exports.getReadableAsBuffer = exports.importFSPromises = exports.waitWithTimeout = exports.pageBindingInitString = exports.addPageBinding = exports.evaluationString = exports.createCdpHandle = exports.waitForEvent = exports.isDate = exports.isRegExp = exports.isPlainObject = exports.isNumber = exports.isString = exports.removeEventListeners = exports.addEventListener = exports.releaseObject = exports.valueFromRemoteObject = exports.getSourcePuppeteerURLIfAvailable = exports.withSourcePuppeteerURLIfNone = exports.PuppeteerURL = exports.createClientError = exports.createEvaluationError = exports.debugError = void 0;
		const rxjs_js_1 = rxjs;
		const environment_js_1 = environment;
		const assert_js_1 = assert$1;
		const Deferred_js_1 = Deferred$1;
		const ErrorLike_js_1 = ErrorLike;
		const Debug_js_1 = Debug;
		const ElementHandle_js_1 = requireElementHandle$1();
		const Errors_js_1 = Errors;
		const JSHandle_js_1 = requireJSHandle$1();
		/**
		 * @internal
		 */
		exports.debugError = (0, Debug_js_1.debug)('puppeteer:error');
		/**
		 * @internal
		 */
		function createEvaluationError(details) {
		    let name;
		    let message;
		    if (!details.exception) {
		        name = 'Error';
		        message = details.text;
		    }
		    else if ((details.exception.type !== 'object' ||
		        details.exception.subtype !== 'error') &&
		        !details.exception.objectId) {
		        return valueFromRemoteObject(details.exception);
		    }
		    else {
		        const detail = getErrorDetails(details);
		        name = detail.name;
		        message = detail.message;
		    }
		    const messageHeight = message.split('\n').length;
		    const error = new Error(message);
		    error.name = name;
		    const stackLines = error.stack.split('\n');
		    const messageLines = stackLines.splice(0, messageHeight);
		    // The first line is this function which we ignore.
		    stackLines.shift();
		    if (details.stackTrace && stackLines.length < Error.stackTraceLimit) {
		        for (const frame of details.stackTrace.callFrames.reverse()) {
		            if (PuppeteerURL.isPuppeteerURL(frame.url) &&
		                frame.url !== PuppeteerURL.INTERNAL_URL) {
		                const url = PuppeteerURL.parse(frame.url);
		                stackLines.unshift(`    at ${frame.functionName || url.functionName} (${url.functionName} at ${url.siteString}, <anonymous>:${frame.lineNumber}:${frame.columnNumber})`);
		            }
		            else {
		                stackLines.push(`    at ${frame.functionName || '<anonymous>'} (${frame.url}:${frame.lineNumber}:${frame.columnNumber})`);
		            }
		            if (stackLines.length >= Error.stackTraceLimit) {
		                break;
		            }
		        }
		    }
		    error.stack = [...messageLines, ...stackLines].join('\n');
		    return error;
		}
		exports.createEvaluationError = createEvaluationError;
		/**
		 * @internal
		 */
		function createClientError(details) {
		    let name;
		    let message;
		    if (!details.exception) {
		        name = 'Error';
		        message = details.text;
		    }
		    else if ((details.exception.type !== 'object' ||
		        details.exception.subtype !== 'error') &&
		        !details.exception.objectId) {
		        return valueFromRemoteObject(details.exception);
		    }
		    else {
		        const detail = getErrorDetails(details);
		        name = detail.name;
		        message = detail.message;
		    }
		    const messageHeight = message.split('\n').length;
		    const error = new Error(message);
		    error.name = name;
		    const stackLines = [];
		    const messageLines = error.stack.split('\n').splice(0, messageHeight);
		    if (details.stackTrace && stackLines.length < Error.stackTraceLimit) {
		        for (const frame of details.stackTrace.callFrames.reverse()) {
		            stackLines.push(`    at ${frame.functionName || '<anonymous>'} (${frame.url}:${frame.lineNumber}:${frame.columnNumber})`);
		            if (stackLines.length >= Error.stackTraceLimit) {
		                break;
		            }
		        }
		    }
		    error.stack = [...messageLines, ...stackLines].join('\n');
		    return error;
		}
		exports.createClientError = createClientError;
		const getErrorDetails = (details) => {
		    let name = '';
		    let message;
		    const lines = details.exception?.description?.split('\n    at ') ?? [];
		    const size = Math.min(details.stackTrace?.callFrames.length ?? 0, lines.length - 1);
		    lines.splice(-size, size);
		    if (details.exception?.className) {
		        name = details.exception.className;
		    }
		    message = lines.join('\n');
		    if (name && message.startsWith(`${name}: `)) {
		        message = message.slice(name.length + 2);
		    }
		    return { message, name };
		};
		/**
		 * @internal
		 */
		const SOURCE_URL = Symbol('Source URL for Puppeteer evaluation scripts');
		/**
		 * @internal
		 */
		class PuppeteerURL {
		    static INTERNAL_URL = 'pptr:internal';
		    static fromCallSite(functionName, site) {
		        const url = new PuppeteerURL();
		        url.#functionName = functionName;
		        url.#siteString = site.toString();
		        return url;
		    }
		    static parse = (url) => {
		        url = url.slice('pptr:'.length);
		        const [functionName = '', siteString = ''] = url.split(';');
		        const puppeteerUrl = new PuppeteerURL();
		        puppeteerUrl.#functionName = functionName;
		        puppeteerUrl.#siteString = decodeURIComponent(siteString);
		        return puppeteerUrl;
		    };
		    static isPuppeteerURL = (url) => {
		        return url.startsWith('pptr:');
		    };
		    #functionName;
		    #siteString;
		    get functionName() {
		        return this.#functionName;
		    }
		    get siteString() {
		        return this.#siteString;
		    }
		    toString() {
		        return `pptr:${[
		            this.#functionName,
		            encodeURIComponent(this.#siteString),
		        ].join(';')}`;
		    }
		}
		exports.PuppeteerURL = PuppeteerURL;
		/**
		 * @internal
		 */
		const withSourcePuppeteerURLIfNone = (functionName, object) => {
		    if (Object.prototype.hasOwnProperty.call(object, SOURCE_URL)) {
		        return object;
		    }
		    const original = Error.prepareStackTrace;
		    Error.prepareStackTrace = (_, stack) => {
		        // First element is the function. Second element is the caller of this
		        // function. Third element is the caller of the caller of this function
		        // which is precisely what we want.
		        return stack[2];
		    };
		    const site = new Error().stack;
		    Error.prepareStackTrace = original;
		    return Object.assign(object, {
		        [SOURCE_URL]: PuppeteerURL.fromCallSite(functionName, site),
		    });
		};
		exports.withSourcePuppeteerURLIfNone = withSourcePuppeteerURLIfNone;
		/**
		 * @internal
		 */
		const getSourcePuppeteerURLIfAvailable = (object) => {
		    if (Object.prototype.hasOwnProperty.call(object, SOURCE_URL)) {
		        return object[SOURCE_URL];
		    }
		    return undefined;
		};
		exports.getSourcePuppeteerURLIfAvailable = getSourcePuppeteerURLIfAvailable;
		/**
		 * @internal
		 */
		function valueFromRemoteObject(remoteObject) {
		    (0, assert_js_1.assert)(!remoteObject.objectId, 'Cannot extract value when objectId is given');
		    if (remoteObject.unserializableValue) {
		        if (remoteObject.type === 'bigint') {
		            return BigInt(remoteObject.unserializableValue.replace('n', ''));
		        }
		        switch (remoteObject.unserializableValue) {
		            case '-0':
		                return -0;
		            case 'NaN':
		                return NaN;
		            case 'Infinity':
		                return Infinity;
		            case '-Infinity':
		                return -Infinity;
		            default:
		                throw new Error('Unsupported unserializable value: ' +
		                    remoteObject.unserializableValue);
		        }
		    }
		    return remoteObject.value;
		}
		exports.valueFromRemoteObject = valueFromRemoteObject;
		/**
		 * @internal
		 */
		async function releaseObject(client, remoteObject) {
		    if (!remoteObject.objectId) {
		        return;
		    }
		    await client
		        .send('Runtime.releaseObject', { objectId: remoteObject.objectId })
		        .catch(error => {
		        // Exceptions might happen in case of a page been navigated or closed.
		        // Swallow these since they are harmless and we don't leak anything in this case.
		        (0, exports.debugError)(error);
		    });
		}
		exports.releaseObject = releaseObject;
		/**
		 * @internal
		 */
		function addEventListener(emitter, eventName, handler) {
		    emitter.on(eventName, handler);
		    return { emitter, eventName, handler };
		}
		exports.addEventListener = addEventListener;
		/**
		 * @internal
		 */
		function removeEventListeners(listeners) {
		    for (const listener of listeners) {
		        listener.emitter.removeListener(listener.eventName, listener.handler);
		    }
		    listeners.length = 0;
		}
		exports.removeEventListeners = removeEventListeners;
		/**
		 * @internal
		 */
		const isString = (obj) => {
		    return typeof obj === 'string' || obj instanceof String;
		};
		exports.isString = isString;
		/**
		 * @internal
		 */
		const isNumber = (obj) => {
		    return typeof obj === 'number' || obj instanceof Number;
		};
		exports.isNumber = isNumber;
		/**
		 * @internal
		 */
		const isPlainObject = (obj) => {
		    return typeof obj === 'object' && obj?.constructor === Object;
		};
		exports.isPlainObject = isPlainObject;
		/**
		 * @internal
		 */
		const isRegExp = (obj) => {
		    return typeof obj === 'object' && obj?.constructor === RegExp;
		};
		exports.isRegExp = isRegExp;
		/**
		 * @internal
		 */
		const isDate = (obj) => {
		    return typeof obj === 'object' && obj?.constructor === Date;
		};
		exports.isDate = isDate;
		/**
		 * @internal
		 */
		async function waitForEvent(emitter, eventName, predicate, timeout, abortPromise) {
		    const deferred = Deferred_js_1.Deferred.create({
		        message: `Timeout exceeded while waiting for event ${String(eventName)}`,
		        timeout,
		    });
		    const listener = addEventListener(emitter, eventName, async (event) => {
		        if (await predicate(event)) {
		            deferred.resolve(event);
		        }
		    });
		    try {
		        const response = await Deferred_js_1.Deferred.race([deferred, abortPromise]);
		        if ((0, ErrorLike_js_1.isErrorLike)(response)) {
		            throw response;
		        }
		        return response;
		    }
		    catch (error) {
		        throw error;
		    }
		    finally {
		        removeEventListeners([listener]);
		    }
		}
		exports.waitForEvent = waitForEvent;
		/**
		 * @internal
		 */
		function createCdpHandle(realm, remoteObject) {
		    if (remoteObject.subtype === 'node') {
		        return new ElementHandle_js_1.CDPElementHandle(realm, remoteObject);
		    }
		    return new JSHandle_js_1.CDPJSHandle(realm, remoteObject);
		}
		exports.createCdpHandle = createCdpHandle;
		/**
		 * @internal
		 */
		function evaluationString(fun, ...args) {
		    if ((0, exports.isString)(fun)) {
		        (0, assert_js_1.assert)(args.length === 0, 'Cannot evaluate a string with arguments');
		        return fun;
		    }
		    function serializeArgument(arg) {
		        if (Object.is(arg, undefined)) {
		            return 'undefined';
		        }
		        return JSON.stringify(arg);
		    }
		    return `(${fun})(${args.map(serializeArgument).join(',')})`;
		}
		exports.evaluationString = evaluationString;
		/**
		 * @internal
		 */
		function addPageBinding(type, name) {
		    // This is the CDP binding.
		    // @ts-expect-error: In a different context.
		    const callCDP = globalThis[name];
		    // We replace the CDP binding with a Puppeteer binding.
		    Object.assign(globalThis, {
		        [name](...args) {
		            // This is the Puppeteer binding.
		            // @ts-expect-error: In a different context.
		            const callPuppeteer = globalThis[name];
		            callPuppeteer.args ??= new Map();
		            callPuppeteer.callbacks ??= new Map();
		            const seq = (callPuppeteer.lastSeq ?? 0) + 1;
		            callPuppeteer.lastSeq = seq;
		            callPuppeteer.args.set(seq, args);
		            callCDP(JSON.stringify({
		                type,
		                name,
		                seq,
		                args,
		                isTrivial: !args.some(value => {
		                    return value instanceof Node;
		                }),
		            }));
		            return new Promise((resolve, reject) => {
		                callPuppeteer.callbacks.set(seq, {
		                    resolve(value) {
		                        callPuppeteer.args.delete(seq);
		                        resolve(value);
		                    },
		                    reject(value) {
		                        callPuppeteer.args.delete(seq);
		                        reject(value);
		                    },
		                });
		            });
		        },
		    });
		}
		exports.addPageBinding = addPageBinding;
		/**
		 * @internal
		 */
		function pageBindingInitString(type, name) {
		    return evaluationString(addPageBinding, type, name);
		}
		exports.pageBindingInitString = pageBindingInitString;
		/**
		 * @internal
		 */
		async function waitWithTimeout(promise, taskName, timeout) {
		    const deferred = Deferred_js_1.Deferred.create({
		        message: `waiting for ${taskName} failed: timeout ${timeout}ms exceeded`,
		        timeout,
		    });
		    return await Deferred_js_1.Deferred.race([promise, deferred]);
		}
		exports.waitWithTimeout = waitWithTimeout;
		/**
		 * @internal
		 */
		let fs = null;
		/**
		 * @internal
		 */
		async function importFSPromises() {
		    if (!fs) {
		        try {
		            fs = await Promise.resolve().then(() => __importStar(require('fs/promises')));
		        }
		        catch (error) {
		            if (error instanceof TypeError) {
		                throw new Error('Cannot write to a path outside of a Node-like environment.');
		            }
		            throw error;
		        }
		    }
		    return fs;
		}
		exports.importFSPromises = importFSPromises;
		/**
		 * @internal
		 */
		async function getReadableAsBuffer(readable, path) {
		    const buffers = [];
		    if (path) {
		        const fs = await importFSPromises();
		        const fileHandle = await fs.open(path, 'w+');
		        try {
		            for await (const chunk of readable) {
		                buffers.push(chunk);
		                await fileHandle.writeFile(chunk);
		            }
		        }
		        finally {
		            await fileHandle.close();
		        }
		    }
		    else {
		        for await (const chunk of readable) {
		            buffers.push(chunk);
		        }
		    }
		    try {
		        return Buffer.concat(buffers);
		    }
		    catch (error) {
		        return null;
		    }
		}
		exports.getReadableAsBuffer = getReadableAsBuffer;
		/**
		 * @internal
		 */
		async function getReadableFromProtocolStream(client, handle) {
		    // TODO: Once Node 18 becomes the lowest supported version, we can migrate to
		    // ReadableStream.
		    if (!environment_js_1.isNode) {
		        throw new Error('Cannot create a stream outside of Node.js environment.');
		    }
		    const { Readable } = await Promise.resolve().then(() => __importStar(require$$10));
		    let eof = false;
		    return new Readable({
		        async read(size) {
		            if (eof) {
		                return;
		            }
		            try {
		                const response = await client.send('IO.read', { handle, size });
		                this.push(response.data, response.base64Encoded ? 'base64' : undefined);
		                if (response.eof) {
		                    eof = true;
		                    await client.send('IO.close', { handle });
		                    this.push(null);
		                }
		            }
		            catch (error) {
		                if ((0, ErrorLike_js_1.isErrorLike)(error)) {
		                    this.destroy(error);
		                    return;
		                }
		                throw error;
		            }
		        },
		    });
		}
		exports.getReadableFromProtocolStream = getReadableFromProtocolStream;
		/**
		 * @internal
		 */
		async function setPageContent(page, content) {
		    // We rely upon the fact that document.open() will reset frame lifecycle with "init"
		    // lifecycle event. @see https://crrev.com/608658
		    return await page.evaluate(html => {
		        document.open();
		        document.write(html);
		        document.close();
		    }, content);
		}
		exports.setPageContent = setPageContent;
		/**
		 * @internal
		 */
		function getPageContent() {
		    let content = '';
		    for (const node of document.childNodes) {
		        switch (node) {
		            case document.documentElement:
		                content += document.documentElement.outerHTML;
		                break;
		            default:
		                content += new XMLSerializer().serializeToString(node);
		                break;
		        }
		    }
		    return content;
		}
		exports.getPageContent = getPageContent;
		/**
		 * @internal
		 */
		function validateDialogType(type) {
		    let dialogType = null;
		    const validDialogTypes = new Set([
		        'alert',
		        'confirm',
		        'prompt',
		        'beforeunload',
		    ]);
		    if (validDialogTypes.has(type)) {
		        dialogType = type;
		    }
		    (0, assert_js_1.assert)(dialogType, `Unknown javascript dialog type: ${type}`);
		    return dialogType;
		}
		exports.validateDialogType = validateDialogType;
		/**
		 * @internal
		 */
		class Mutex {
		    static Guard = class Guard {
		        #mutex;
		        constructor(mutex) {
		            this.#mutex = mutex;
		        }
		        [Symbol.dispose]() {
		            return this.#mutex.release();
		        }
		    };
		    #locked = false;
		    #acquirers = [];
		    // This is FIFO.
		    async acquire() {
		        if (!this.#locked) {
		            this.#locked = true;
		            return new Mutex.Guard(this);
		        }
		        const deferred = Deferred_js_1.Deferred.create();
		        this.#acquirers.push(deferred.resolve.bind(deferred));
		        await deferred.valueOrThrow();
		        return new Mutex.Guard(this);
		    }
		    release() {
		        const resolve = this.#acquirers.shift();
		        if (!resolve) {
		            this.#locked = false;
		            return;
		        }
		        resolve();
		    }
		}
		exports.Mutex = Mutex;
		/**
		 * @internal
		 */
		function timeout(ms) {
		    return ms === 0
		        ? rxjs_js_1.NEVER
		        : (0, rxjs_js_1.timer)(ms).pipe((0, rxjs_js_1.map)(() => {
		            throw new Errors_js_1.TimeoutError(`Timed out after waiting ${ms}ms`);
		        }));
		}
		exports.timeout = timeout;
		
	} (util$1));
	return util$1;
}

/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(Browser$3, "__esModule", { value: true });
Browser$3.Browser = Browser$3.WEB_PERMISSION_TO_PROTOCOL_PERMISSION = void 0;
const disposablestack_js_1 = disposablestack;
const EventEmitter_js_1$4 = EventEmitter$1;
const util_js_1$f = requireUtil();
const Deferred_js_1$a = Deferred$1;
/**
 * @internal
 */
Browser$3.WEB_PERMISSION_TO_PROTOCOL_PERMISSION = new Map([
    ['geolocation', 'geolocation'],
    ['midi', 'midi'],
    ['notifications', 'notifications'],
    // TODO: push isn't a valid type?
    // ['push', 'push'],
    ['camera', 'videoCapture'],
    ['microphone', 'audioCapture'],
    ['background-sync', 'backgroundSync'],
    ['ambient-light-sensor', 'sensors'],
    ['accelerometer', 'sensors'],
    ['gyroscope', 'sensors'],
    ['magnetometer', 'sensors'],
    ['accessibility-events', 'accessibilityEvents'],
    ['clipboard-read', 'clipboardReadWrite'],
    ['clipboard-write', 'clipboardReadWrite'],
    ['clipboard-sanitized-write', 'clipboardSanitizedWrite'],
    ['payment-handler', 'paymentHandler'],
    ['persistent-storage', 'durableStorage'],
    ['idle-detection', 'idleDetection'],
    // chrome-specific permissions we have.
    ['midi-sysex', 'midiSysex'],
]);
/**
 * A Browser is created when Puppeteer connects to a browser instance, either through
 * {@link PuppeteerNode.launch} or {@link Puppeteer.connect}.
 *
 * @remarks
 *
 * The Browser class extends from Puppeteer's {@link EventEmitter} class and will
 * emit various events which are documented in the {@link BrowserEmittedEvents} enum.
 *
 * @example
 * An example of using a {@link Browser} to create a {@link Page}:
 *
 * ```ts
 * import puppeteer from 'puppeteer';
 *
 * (async () => {
 *   const browser = await puppeteer.launch();
 *   const page = await browser.newPage();
 *   await page.goto('https://example.com');
 *   await browser.close();
 * })();
 * ```
 *
 * @example
 * An example of disconnecting from and reconnecting to a {@link Browser}:
 *
 * ```ts
 * import puppeteer from 'puppeteer';
 *
 * (async () => {
 *   const browser = await puppeteer.launch();
 *   // Store the endpoint to be able to reconnect to the browser.
 *   const browserWSEndpoint = browser.wsEndpoint();
 *   // Disconnect puppeteer from the browser.
 *   browser.disconnect();
 *
 *   // Use the endpoint to reestablish a connection
 *   const browser2 = await puppeteer.connect({browserWSEndpoint});
 *   // Close the browser.
 *   await browser2.close();
 * })();
 * ```
 *
 * @public
 */
let Browser$2 = class Browser extends EventEmitter_js_1$4.EventEmitter {
    /**
     * @internal
     */
    constructor() {
        super();
    }
    /**
     * @internal
     */
    _attach() {
        throw new Error('Not implemented');
    }
    /**
     * @internal
     */
    _detach() {
        throw new Error('Not implemented');
    }
    /**
     * @internal
     */
    get _targets() {
        throw new Error('Not implemented');
    }
    /**
     * The spawned browser process. Returns `null` if the browser instance was created with
     * {@link Puppeteer.connect}.
     */
    process() {
        throw new Error('Not implemented');
    }
    /**
     * @internal
     */
    _getIsPageTargetCallback() {
        throw new Error('Not implemented');
    }
    createIncognitoBrowserContext() {
        throw new Error('Not implemented');
    }
    /**
     * Returns an array of all open browser contexts. In a newly created browser, this will
     * return a single instance of {@link BrowserContext}.
     */
    browserContexts() {
        throw new Error('Not implemented');
    }
    /**
     * Returns the default browser context. The default browser context cannot be closed.
     */
    defaultBrowserContext() {
        throw new Error('Not implemented');
    }
    _disposeContext() {
        throw new Error('Not implemented');
    }
    /**
     * The browser websocket endpoint which can be used as an argument to
     * {@link Puppeteer.connect}.
     *
     * @returns The Browser websocket url.
     *
     * @remarks
     *
     * The format is `ws://${host}:${port}/devtools/browser/<id>`.
     *
     * You can find the `webSocketDebuggerUrl` from `http://${host}:${port}/json/version`.
     * Learn more about the
     * {@link https://chromedevtools.github.io/devtools-protocol | devtools protocol} and
     * the {@link
     * https://chromedevtools.github.io/devtools-protocol/#how-do-i-access-the-browser-target
     * | browser endpoint}.
     */
    wsEndpoint() {
        throw new Error('Not implemented');
    }
    /**
     * Promise which resolves to a new {@link Page} object. The Page is created in
     * a default browser context.
     */
    newPage() {
        throw new Error('Not implemented');
    }
    _createPageInContext() {
        throw new Error('Not implemented');
    }
    /**
     * All active targets inside the Browser. In case of multiple browser contexts, returns
     * an array with all the targets in all browser contexts.
     */
    targets() {
        throw new Error('Not implemented');
    }
    /**
     * The target associated with the browser.
     */
    target() {
        throw new Error('Not implemented');
    }
    /**
     * Searches for a target in all browser contexts.
     *
     * @param predicate - A function to be run for every target.
     * @returns The first target found that matches the `predicate` function.
     *
     * @example
     *
     * An example of finding a target for a page opened via `window.open`:
     *
     * ```ts
     * await page.evaluate(() => window.open('https://www.example.com/'));
     * const newWindowTarget = await browser.waitForTarget(
     *   target => target.url() === 'https://www.example.com/'
     * );
     * ```
     */
    async waitForTarget(predicate, options = {}) {
        const { timeout = 30000 } = options;
        const targetDeferred = Deferred_js_1$a.Deferred.create();
        this.on("targetcreated" /* BrowserEmittedEvents.TargetCreated */, check);
        this.on("targetchanged" /* BrowserEmittedEvents.TargetChanged */, check);
        try {
            this.targets().forEach(check);
            if (!timeout) {
                return await targetDeferred.valueOrThrow();
            }
            return await (0, util_js_1$f.waitWithTimeout)(targetDeferred.valueOrThrow(), 'target', timeout);
        }
        finally {
            this.off("targetcreated" /* BrowserEmittedEvents.TargetCreated */, check);
            this.off("targetchanged" /* BrowserEmittedEvents.TargetChanged */, check);
        }
        async function check(target) {
            if ((await predicate(target)) && !targetDeferred.resolved()) {
                targetDeferred.resolve(target);
            }
        }
    }
    /**
     * An array of all open pages inside the Browser.
     *
     * @remarks
     *
     * In case of multiple browser contexts, returns an array with all the pages in all
     * browser contexts. Non-visible pages, such as `"background_page"`, will not be listed
     * here. You can find them using {@link Target.page}.
     */
    async pages() {
        const contextPages = await Promise.all(this.browserContexts().map(context => {
            return context.pages();
        }));
        // Flatten array.
        return contextPages.reduce((acc, x) => {
            return acc.concat(x);
        }, []);
    }
    /**
     * A string representing the browser name and version.
     *
     * @remarks
     *
     * For headless browser, this is similar to `HeadlessChrome/61.0.3153.0`. For
     * non-headless or new-headless, this is similar to `Chrome/61.0.3153.0`. For
     * Firefox, it is similar to `Firefox/116.0a1`.
     *
     * The format of browser.version() might change with future releases of
     * browsers.
     */
    version() {
        throw new Error('Not implemented');
    }
    /**
     * The browser's original user agent. Pages can override the browser user agent with
     * {@link Page.setUserAgent}.
     */
    userAgent() {
        throw new Error('Not implemented');
    }
    /**
     * Closes the browser and all of its pages (if any were opened). The
     * {@link Browser} object itself is considered to be disposed and cannot be
     * used anymore.
     */
    close() {
        throw new Error('Not implemented');
    }
    /**
     * Disconnects Puppeteer from the browser, but leaves the browser process running.
     * After calling `disconnect`, the {@link Browser} object is considered disposed and
     * cannot be used anymore.
     */
    disconnect() {
        throw new Error('Not implemented');
    }
    /**
     * Indicates that the browser is connected.
     */
    isConnected() {
        throw new Error('Not implemented');
    }
    [disposablestack_js_1.Symbol.dispose]() {
        return void this.close().catch(util_js_1$f.debugError);
    }
    [disposablestack_js_1.Symbol.asyncDispose]() {
        return this.close();
    }
};
Browser$3.Browser = Browser$2;

var BrowserContext$2 = {};

/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(BrowserContext$2, "__esModule", { value: true });
BrowserContext$2.BrowserContext = void 0;
const EventEmitter_js_1$3 = EventEmitter$1;
/**
 * BrowserContexts provide a way to operate multiple independent browser
 * sessions. When a browser is launched, it has a single BrowserContext used by
 * default. The method {@link Browser.newPage | Browser.newPage} creates a page
 * in the default browser context.
 *
 * @remarks
 *
 * The Browser class extends from Puppeteer's {@link EventEmitter} class and
 * will emit various events which are documented in the
 * {@link BrowserContextEmittedEvents} enum.
 *
 * If a page opens another page, e.g. with a `window.open` call, the popup will
 * belong to the parent page's browser context.
 *
 * Puppeteer allows creation of "incognito" browser contexts with
 * {@link Browser.createIncognitoBrowserContext | Browser.createIncognitoBrowserContext}
 * method. "Incognito" browser contexts don't write any browsing data to disk.
 *
 * @example
 *
 * ```ts
 * // Create a new incognito browser context
 * const context = await browser.createIncognitoBrowserContext();
 * // Create a new page inside context.
 * const page = await context.newPage();
 * // ... do stuff with page ...
 * await page.goto('https://example.com');
 * // Dispose context once it's no longer needed.
 * await context.close();
 * ```
 *
 * @public
 */
let BrowserContext$1 = class BrowserContext extends EventEmitter_js_1$3.EventEmitter {
    /**
     * @internal
     */
    constructor() {
        super();
    }
    /**
     * An array of all active targets inside the browser context.
     */
    targets() {
        throw new Error('Not implemented');
    }
    waitForTarget() {
        throw new Error('Not implemented');
    }
    /**
     * An array of all pages inside the browser context.
     *
     * @returns Promise which resolves to an array of all open pages.
     * Non visible pages, such as `"background_page"`, will not be listed here.
     * You can find them using {@link Target.page | the target page}.
     */
    pages() {
        throw new Error('Not implemented');
    }
    /**
     * Returns whether BrowserContext is incognito.
     * The default browser context is the only non-incognito browser context.
     *
     * @remarks
     * The default browser context cannot be closed.
     */
    isIncognito() {
        throw new Error('Not implemented');
    }
    overridePermissions() {
        throw new Error('Not implemented');
    }
    /**
     * Clears all permission overrides for the browser context.
     *
     * @example
     *
     * ```ts
     * const context = browser.defaultBrowserContext();
     * context.overridePermissions('https://example.com', ['clipboard-read']);
     * // do stuff ..
     * context.clearPermissionOverrides();
     * ```
     */
    clearPermissionOverrides() {
        throw new Error('Not implemented');
    }
    /**
     * Creates a new page in the browser context.
     */
    newPage() {
        throw new Error('Not implemented');
    }
    /**
     * The browser this browser context belongs to.
     */
    browser() {
        throw new Error('Not implemented');
    }
    /**
     * Closes the browser context. All the targets that belong to the browser context
     * will be closed.
     *
     * @remarks
     * Only incognito browser contexts can be closed.
     */
    close() {
        throw new Error('Not implemented');
    }
    get id() {
        return undefined;
    }
};
BrowserContext$2.BrowserContext = BrowserContext$1;

var Dialog$3 = {};

/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(Dialog$3, "__esModule", { value: true });
Dialog$3.Dialog = void 0;
const assert_js_1$f = assert$1;
/**
 * Dialog instances are dispatched by the {@link Page} via the `dialog` event.
 *
 * @remarks
 *
 * @example
 *
 * ```ts
 * import puppeteer from 'puppeteer';
 *
 * (async () => {
 *   const browser = await puppeteer.launch();
 *   const page = await browser.newPage();
 *   page.on('dialog', async dialog => {
 *     console.log(dialog.message());
 *     await dialog.dismiss();
 *     await browser.close();
 *   });
 *   page.evaluate(() => alert('1'));
 * })();
 * ```
 *
 * @public
 */
let Dialog$2 = class Dialog {
    #type;
    #message;
    #defaultValue;
    #handled = false;
    /**
     * @internal
     */
    constructor(type, message, defaultValue = '') {
        this.#type = type;
        this.#message = message;
        this.#defaultValue = defaultValue;
    }
    /**
     * The type of the dialog.
     */
    type() {
        return this.#type;
    }
    /**
     * The message displayed in the dialog.
     */
    message() {
        return this.#message;
    }
    /**
     * The default value of the prompt, or an empty string if the dialog
     * is not a `prompt`.
     */
    defaultValue() {
        return this.#defaultValue;
    }
    /**
     * A promise that resolves when the dialog has been accepted.
     *
     * @param promptText - optional text that will be entered in the dialog
     * prompt. Has no effect if the dialog's type is not `prompt`.
     *
     */
    async accept(promptText) {
        (0, assert_js_1$f.assert)(!this.#handled, 'Cannot accept dialog which is already handled!');
        this.#handled = true;
        await this.sendCommand({
            accept: true,
            text: promptText,
        });
    }
    /**
     * A promise which will resolve once the dialog has been dismissed
     */
    async dismiss() {
        (0, assert_js_1$f.assert)(!this.#handled, 'Cannot dismiss dialog which is already handled!');
        this.#handled = true;
        await this.sendCommand({
            accept: false,
        });
    }
};
Dialog$3.Dialog = Dialog$2;

var Environment = {};

/**
 * Copyright 2023 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(Environment, "__esModule", { value: true });

var Frame$2 = {};

var locators = {};

var Locator = {};

var hasRequiredLocator;

function requireLocator () {
	if (hasRequiredLocator) return Locator;
	hasRequiredLocator = 1;
	(function (exports) {
		/**
		 * Copyright 2023 Google Inc. All rights reserved.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *     http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		var __addDisposableResource = (commonjsGlobal && commonjsGlobal.__addDisposableResource) || function (env, value, async) {
		    if (value !== null && value !== void 0) {
		        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
		        var dispose;
		        if (async) {
		            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
		            dispose = value[Symbol.asyncDispose];
		        }
		        if (dispose === void 0) {
		            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
		            dispose = value[Symbol.dispose];
		        }
		        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
		        env.stack.push({ value: value, dispose: dispose, async: async });
		    }
		    else if (async) {
		        env.stack.push({ async: true });
		    }
		    return value;
		};
		var __disposeResources = (commonjsGlobal && commonjsGlobal.__disposeResources) || (function (SuppressedError) {
		    return function (env) {
		        function fail(e) {
		            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
		            env.hasError = true;
		        }
		        function next() {
		            while (env.stack.length) {
		                var rec = env.stack.pop();
		                try {
		                    var result = rec.dispose && rec.dispose.call(rec.value);
		                    if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
		                }
		                catch (e) {
		                    fail(e);
		                }
		            }
		            if (env.hasError) throw env.error;
		        }
		        return next();
		    };
		})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
		    var e = new Error(message);
		    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
		});
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.Locator = exports.LocatorEmittedEvents = exports.RETRY_DELAY = void 0;
		const rxjs_js_1 = rxjs;
		const EventEmitter_js_1 = EventEmitter$1;
		const util_js_1 = requireUtil();
		const locators_js_1 = requireLocators();
		/**
		 * For observables coming from promises, a delay is needed, otherwise RxJS will
		 * never yield in a permanent failure for a promise.
		 *
		 * We also don't want RxJS to do promise operations to often, so we bump the
		 * delay up to 100ms.
		 *
		 * @internal
		 */
		exports.RETRY_DELAY = 100;
		/**
		 * All the events that a locator instance may emit.
		 *
		 * @public
		 */
		var LocatorEmittedEvents;
		(function (LocatorEmittedEvents) {
		    /**
		     * Emitted every time before the locator performs an action on the located element(s).
		     */
		    LocatorEmittedEvents["Action"] = "action";
		})(LocatorEmittedEvents || (exports.LocatorEmittedEvents = LocatorEmittedEvents = {}));
		/**
		 * Locators describe a strategy of locating objects and performing an action on
		 * them. If the action fails because the object is not ready for the action, the
		 * whole operation is retried. Various preconditions for a successful action are
		 * checked automatically.
		 *
		 * @public
		 */
		class Locator extends EventEmitter_js_1.EventEmitter {
		    /**
		     * Creates a race between multiple locators but ensures that only a single one
		     * acts.
		     *
		     * @public
		     */
		    static race(locators) {
		        return locators_js_1.RaceLocator.create(locators);
		    }
		    /**
		     * @internal
		     */
		    visibility = null;
		    /**
		     * @internal
		     */
		    _timeout = 30000;
		    #ensureElementIsInTheViewport = true;
		    #waitForEnabled = true;
		    #waitForStableBoundingBox = true;
		    /**
		     * @internal
		     */
		    operators = {
		        conditions: (conditions, signal) => {
		            return (0, rxjs_js_1.mergeMap)((handle) => {
		                return (0, rxjs_js_1.merge)(...conditions.map(condition => {
		                    return condition(handle, signal);
		                })).pipe((0, rxjs_js_1.defaultIfEmpty)(handle));
		            });
		        },
		        retryAndRaceWithSignalAndTimer: (signal) => {
		            const candidates = [];
		            if (signal) {
		                candidates.push((0, rxjs_js_1.fromEvent)(signal, 'abort').pipe((0, rxjs_js_1.map)(() => {
		                    throw signal.reason;
		                })));
		            }
		            candidates.push((0, util_js_1.timeout)(this._timeout));
		            return (0, rxjs_js_1.pipe)((0, rxjs_js_1.retry)({ delay: exports.RETRY_DELAY }), (0, rxjs_js_1.raceWith)(...candidates));
		        },
		    };
		    // Determines when the locator will timeout for actions.
		    get timeout() {
		        return this._timeout;
		    }
		    on(eventName, handler) {
		        return super.on(eventName, handler);
		    }
		    once(eventName, handler) {
		        return super.once(eventName, handler);
		    }
		    off(eventName, handler) {
		        return super.off(eventName, handler);
		    }
		    setTimeout(timeout) {
		        const locator = this._clone();
		        locator._timeout = timeout;
		        return locator;
		    }
		    setVisibility(visibility) {
		        const locator = this._clone();
		        locator.visibility = visibility;
		        return locator;
		    }
		    setWaitForEnabled(value) {
		        const locator = this._clone();
		        locator.#waitForEnabled = value;
		        return locator;
		    }
		    setEnsureElementIsInTheViewport(value) {
		        const locator = this._clone();
		        locator.#ensureElementIsInTheViewport = value;
		        return locator;
		    }
		    setWaitForStableBoundingBox(value) {
		        const locator = this._clone();
		        locator.#waitForStableBoundingBox = value;
		        return locator;
		    }
		    /**
		     * @internal
		     */
		    copyOptions(locator) {
		        this._timeout = locator._timeout;
		        this.visibility = locator.visibility;
		        this.#waitForEnabled = locator.#waitForEnabled;
		        this.#ensureElementIsInTheViewport = locator.#ensureElementIsInTheViewport;
		        this.#waitForStableBoundingBox = locator.#waitForStableBoundingBox;
		        return this;
		    }
		    /**
		     * If the element has a "disabled" property, wait for the element to be
		     * enabled.
		     */
		    #waitForEnabledIfNeeded = (handle, signal) => {
		        if (!this.#waitForEnabled) {
		            return rxjs_js_1.EMPTY;
		        }
		        return (0, rxjs_js_1.from)(handle.frame.waitForFunction(element => {
		            if (!(element instanceof HTMLElement)) {
		                return true;
		            }
		            const isNativeFormControl = [
		                'BUTTON',
		                'INPUT',
		                'SELECT',
		                'TEXTAREA',
		                'OPTION',
		                'OPTGROUP',
		            ].includes(element.nodeName);
		            return !isNativeFormControl || !element.hasAttribute('disabled');
		        }, {
		            timeout: this._timeout,
		            signal,
		        }, handle)).pipe((0, rxjs_js_1.ignoreElements)());
		    };
		    /**
		     * Compares the bounding box of the element for two consecutive animation
		     * frames and waits till they are the same.
		     */
		    #waitForStableBoundingBoxIfNeeded = (handle) => {
		        if (!this.#waitForStableBoundingBox) {
		            return rxjs_js_1.EMPTY;
		        }
		        return (0, rxjs_js_1.defer)(() => {
		            // Note we don't use waitForFunction because that relies on RAF.
		            return (0, rxjs_js_1.from)(handle.evaluate(element => {
		                return new Promise(resolve => {
		                    window.requestAnimationFrame(() => {
		                        const rect1 = element.getBoundingClientRect();
		                        window.requestAnimationFrame(() => {
		                            const rect2 = element.getBoundingClientRect();
		                            resolve([
		                                {
		                                    x: rect1.x,
		                                    y: rect1.y,
		                                    width: rect1.width,
		                                    height: rect1.height,
		                                },
		                                {
		                                    x: rect2.x,
		                                    y: rect2.y,
		                                    width: rect2.width,
		                                    height: rect2.height,
		                                },
		                            ]);
		                        });
		                    });
		                });
		            }));
		        }).pipe((0, rxjs_js_1.first)(([rect1, rect2]) => {
		            return (rect1.x === rect2.x &&
		                rect1.y === rect2.y &&
		                rect1.width === rect2.width &&
		                rect1.height === rect2.height);
		        }), (0, rxjs_js_1.retry)({ delay: exports.RETRY_DELAY }), (0, rxjs_js_1.ignoreElements)());
		    };
		    /**
		     * Checks if the element is in the viewport and auto-scrolls it if it is not.
		     */
		    #ensureElementIsInTheViewportIfNeeded = (handle) => {
		        if (!this.#ensureElementIsInTheViewport) {
		            return rxjs_js_1.EMPTY;
		        }
		        return (0, rxjs_js_1.from)(handle.isIntersectingViewport({ threshold: 0 })).pipe((0, rxjs_js_1.filter)(isIntersectingViewport => {
		            return !isIntersectingViewport;
		        }), (0, rxjs_js_1.mergeMap)(() => {
		            return (0, rxjs_js_1.from)(handle.scrollIntoView());
		        }), (0, rxjs_js_1.mergeMap)(() => {
		            return (0, rxjs_js_1.defer)(() => {
		                return (0, rxjs_js_1.from)(handle.isIntersectingViewport({ threshold: 0 }));
		            }).pipe((0, rxjs_js_1.first)(rxjs_js_1.identity), (0, rxjs_js_1.retry)({ delay: exports.RETRY_DELAY }), (0, rxjs_js_1.ignoreElements)());
		        }));
		    };
		    #click(options) {
		        const signal = options?.signal;
		        return this._wait(options).pipe(this.operators.conditions([
		            this.#ensureElementIsInTheViewportIfNeeded,
		            this.#waitForStableBoundingBoxIfNeeded,
		            this.#waitForEnabledIfNeeded,
		        ], signal), (0, rxjs_js_1.tap)(() => {
		            return this.emit(LocatorEmittedEvents.Action);
		        }), (0, rxjs_js_1.mergeMap)(handle => {
		            return (0, rxjs_js_1.from)(handle.click(options)).pipe((0, rxjs_js_1.catchError)(err => {
		                void handle.dispose().catch(util_js_1.debugError);
		                throw err;
		            }));
		        }), this.operators.retryAndRaceWithSignalAndTimer(signal));
		    }
		    #fill(value, options) {
		        const signal = options?.signal;
		        return this._wait(options).pipe(this.operators.conditions([
		            this.#ensureElementIsInTheViewportIfNeeded,
		            this.#waitForStableBoundingBoxIfNeeded,
		            this.#waitForEnabledIfNeeded,
		        ], signal), (0, rxjs_js_1.tap)(() => {
		            return this.emit(LocatorEmittedEvents.Action);
		        }), (0, rxjs_js_1.mergeMap)(handle => {
		            return (0, rxjs_js_1.from)(handle.evaluate(el => {
		                if (el instanceof HTMLSelectElement) {
		                    return 'select';
		                }
		                if (el instanceof HTMLTextAreaElement) {
		                    return 'typeable-input';
		                }
		                if (el instanceof HTMLInputElement) {
		                    if (new Set([
		                        'textarea',
		                        'text',
		                        'url',
		                        'tel',
		                        'search',
		                        'password',
		                        'number',
		                        'email',
		                    ]).has(el.type)) {
		                        return 'typeable-input';
		                    }
		                    else {
		                        return 'other-input';
		                    }
		                }
		                if (el.isContentEditable) {
		                    return 'contenteditable';
		                }
		                return 'unknown';
		            }))
		                .pipe((0, rxjs_js_1.mergeMap)(inputType => {
		                switch (inputType) {
		                    case 'select':
		                        return (0, rxjs_js_1.from)(handle.select(value).then(rxjs_js_1.noop));
		                    case 'contenteditable':
		                    case 'typeable-input':
		                        return (0, rxjs_js_1.from)(handle.evaluate((input, newValue) => {
		                            const currentValue = input.isContentEditable
		                                ? input.innerText
		                                : input.value;
		                            // Clear the input if the current value does not match the filled
		                            // out value.
		                            if (newValue.length <= currentValue.length ||
		                                !newValue.startsWith(input.value)) {
		                                if (input.isContentEditable) {
		                                    input.innerText = '';
		                                }
		                                else {
		                                    input.value = '';
		                                }
		                                return newValue;
		                            }
		                            const originalValue = input.isContentEditable
		                                ? input.innerText
		                                : input.value;
		                            // If the value is partially filled out, only type the rest. Move
		                            // cursor to the end of the common prefix.
		                            if (input.isContentEditable) {
		                                input.innerText = '';
		                                input.innerText = originalValue;
		                            }
		                            else {
		                                input.value = '';
		                                input.value = originalValue;
		                            }
		                            return newValue.substring(originalValue.length);
		                        }, value)).pipe((0, rxjs_js_1.mergeMap)(textToType => {
		                            return (0, rxjs_js_1.from)(handle.type(textToType));
		                        }));
		                    case 'other-input':
		                        return (0, rxjs_js_1.from)(handle.focus()).pipe((0, rxjs_js_1.mergeMap)(() => {
		                            return (0, rxjs_js_1.from)(handle.evaluate((input, value) => {
		                                input.value = value;
		                                input.dispatchEvent(new Event('input', { bubbles: true }));
		                                input.dispatchEvent(new Event('change', { bubbles: true }));
		                            }, value));
		                        }));
		                    case 'unknown':
		                        throw new Error(`Element cannot be filled out.`);
		                }
		            }))
		                .pipe((0, rxjs_js_1.catchError)(err => {
		                void handle.dispose().catch(util_js_1.debugError);
		                throw err;
		            }));
		        }), this.operators.retryAndRaceWithSignalAndTimer(signal));
		    }
		    #hover(options) {
		        const signal = options?.signal;
		        return this._wait(options).pipe(this.operators.conditions([
		            this.#ensureElementIsInTheViewportIfNeeded,
		            this.#waitForStableBoundingBoxIfNeeded,
		        ], signal), (0, rxjs_js_1.tap)(() => {
		            return this.emit(LocatorEmittedEvents.Action);
		        }), (0, rxjs_js_1.mergeMap)(handle => {
		            return (0, rxjs_js_1.from)(handle.hover()).pipe((0, rxjs_js_1.catchError)(err => {
		                void handle.dispose().catch(util_js_1.debugError);
		                throw err;
		            }));
		        }), this.operators.retryAndRaceWithSignalAndTimer(signal));
		    }
		    #scroll(options) {
		        const signal = options?.signal;
		        return this._wait(options).pipe(this.operators.conditions([
		            this.#ensureElementIsInTheViewportIfNeeded,
		            this.#waitForStableBoundingBoxIfNeeded,
		        ], signal), (0, rxjs_js_1.tap)(() => {
		            return this.emit(LocatorEmittedEvents.Action);
		        }), (0, rxjs_js_1.mergeMap)(handle => {
		            return (0, rxjs_js_1.from)(handle.evaluate((el, scrollTop, scrollLeft) => {
		                if (scrollTop !== undefined) {
		                    el.scrollTop = scrollTop;
		                }
		                if (scrollLeft !== undefined) {
		                    el.scrollLeft = scrollLeft;
		                }
		            }, options?.scrollTop, options?.scrollLeft)).pipe((0, rxjs_js_1.catchError)(err => {
		                void handle.dispose().catch(util_js_1.debugError);
		                throw err;
		            }));
		        }), this.operators.retryAndRaceWithSignalAndTimer(signal));
		    }
		    /**
		     * Clones the locator.
		     */
		    clone() {
		        return this._clone();
		    }
		    /**
		     * Waits for the locator to get a handle from the page.
		     *
		     * @public
		     */
		    async waitHandle(options) {
		        return await (0, rxjs_js_1.firstValueFrom)(this._wait(options).pipe(this.operators.retryAndRaceWithSignalAndTimer(options?.signal)));
		    }
		    /**
		     * Waits for the locator to get the serialized value from the page.
		     *
		     * Note this requires the value to be JSON-serializable.
		     *
		     * @public
		     */
		    async wait(options) {
		        const env_1 = { stack: [], error: void 0, hasError: false };
		        try {
		            const handle = __addDisposableResource(env_1, await this.waitHandle(options), false);
		            return await handle.jsonValue();
		        }
		        catch (e_1) {
		            env_1.error = e_1;
		            env_1.hasError = true;
		        }
		        finally {
		            __disposeResources(env_1);
		        }
		    }
		    /**
		     * Maps the locator using the provided mapper.
		     *
		     * @public
		     */
		    map(mapper) {
		        return new locators_js_1.MappedLocator(this._clone(), handle => {
		            // SAFETY: TypeScript cannot deduce the type.
		            return handle.evaluateHandle(mapper);
		        });
		    }
		    /**
		     * Creates an expectation that is evaluated against located values.
		     *
		     * If the expectations do not match, then the locator will retry.
		     *
		     * @public
		     */
		    filter(predicate) {
		        return new locators_js_1.FilteredLocator(this._clone(), async (handle, signal) => {
		            await handle.frame.waitForFunction(predicate, { signal, timeout: this._timeout }, handle);
		            return true;
		        });
		    }
		    /**
		     * Creates an expectation that is evaluated against located handles.
		     *
		     * If the expectations do not match, then the locator will retry.
		     *
		     * @internal
		     */
		    filterHandle(predicate) {
		        return new locators_js_1.FilteredLocator(this._clone(), predicate);
		    }
		    /**
		     * Maps the locator using the provided mapper.
		     *
		     * @internal
		     */
		    mapHandle(mapper) {
		        return new locators_js_1.MappedLocator(this._clone(), mapper);
		    }
		    click(options) {
		        return (0, rxjs_js_1.firstValueFrom)(this.#click(options));
		    }
		    /**
		     * Fills out the input identified by the locator using the provided value. The
		     * type of the input is determined at runtime and the appropriate fill-out
		     * method is chosen based on the type. contenteditable, selector, inputs are
		     * supported.
		     */
		    fill(value, options) {
		        return (0, rxjs_js_1.firstValueFrom)(this.#fill(value, options));
		    }
		    hover(options) {
		        return (0, rxjs_js_1.firstValueFrom)(this.#hover(options));
		    }
		    scroll(options) {
		        return (0, rxjs_js_1.firstValueFrom)(this.#scroll(options));
		    }
		}
		exports.Locator = Locator;
		
	} (Locator));
	return Locator;
}

var DelegatedLocator = {};

var hasRequiredDelegatedLocator;

function requireDelegatedLocator () {
	if (hasRequiredDelegatedLocator) return DelegatedLocator;
	hasRequiredDelegatedLocator = 1;
	/**
	 * Copyright 2023 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(DelegatedLocator, "__esModule", { value: true });
	DelegatedLocator.DelegatedLocator = void 0;
	const locators_js_1 = requireLocators();
	/**
	 * @internal
	 */
	let DelegatedLocator$1 = class DelegatedLocator extends locators_js_1.Locator {
	    #delegate;
	    constructor(delegate) {
	        super();
	        this.#delegate = delegate;
	        this.copyOptions(this.#delegate);
	    }
	    get delegate() {
	        return this.#delegate;
	    }
	    setTimeout(timeout) {
	        const locator = super.setTimeout(timeout);
	        locator.#delegate = this.#delegate.setTimeout(timeout);
	        return locator;
	    }
	    setVisibility(visibility) {
	        const locator = super.setVisibility(visibility);
	        locator.#delegate = locator.#delegate.setVisibility(visibility);
	        return locator;
	    }
	    setWaitForEnabled(value) {
	        const locator = super.setWaitForEnabled(value);
	        locator.#delegate = this.#delegate.setWaitForEnabled(value);
	        return locator;
	    }
	    setEnsureElementIsInTheViewport(value) {
	        const locator = super.setEnsureElementIsInTheViewport(value);
	        locator.#delegate = this.#delegate.setEnsureElementIsInTheViewport(value);
	        return locator;
	    }
	    setWaitForStableBoundingBox(value) {
	        const locator = super.setWaitForStableBoundingBox(value);
	        locator.#delegate = this.#delegate.setWaitForStableBoundingBox(value);
	        return locator;
	    }
	};
	DelegatedLocator.DelegatedLocator = DelegatedLocator$1;
	
	return DelegatedLocator;
}

var FilteredLocator = {};

var hasRequiredFilteredLocator;

function requireFilteredLocator () {
	if (hasRequiredFilteredLocator) return FilteredLocator;
	hasRequiredFilteredLocator = 1;
	/**
	 * Copyright 2023 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(FilteredLocator, "__esModule", { value: true });
	FilteredLocator.FilteredLocator = void 0;
	const rxjs_js_1 = rxjs;
	const DelegatedLocator_js_1 = requireDelegatedLocator();
	/**
	 * @internal
	 */
	let FilteredLocator$1 = class FilteredLocator extends DelegatedLocator_js_1.DelegatedLocator {
	    #predicate;
	    constructor(base, predicate) {
	        super(base);
	        this.#predicate = predicate;
	    }
	    _clone() {
	        return new FilteredLocator(this.delegate.clone(), this.#predicate).copyOptions(this);
	    }
	    _wait(options) {
	        return this.delegate._wait(options).pipe((0, rxjs_js_1.mergeMap)(handle => {
	            return (0, rxjs_js_1.from)(Promise.resolve(this.#predicate(handle, options?.signal))).pipe((0, rxjs_js_1.filter)(value => {
	                return value;
	            }), (0, rxjs_js_1.map)(() => {
	                // SAFETY: It passed the predicate, so this is correct.
	                return handle;
	            }));
	        }), (0, rxjs_js_1.throwIfEmpty)());
	    }
	};
	FilteredLocator.FilteredLocator = FilteredLocator$1;
	
	return FilteredLocator;
}

var FunctionLocator = {};

var hasRequiredFunctionLocator;

function requireFunctionLocator () {
	if (hasRequiredFunctionLocator) return FunctionLocator;
	hasRequiredFunctionLocator = 1;
	/**
	 * Copyright 2023 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(FunctionLocator, "__esModule", { value: true });
	FunctionLocator.FunctionLocator = void 0;
	const rxjs_js_1 = rxjs;
	const locators_js_1 = requireLocators();
	/**
	 * @internal
	 */
	let FunctionLocator$1 = class FunctionLocator extends locators_js_1.Locator {
	    static create(pageOrFrame, func) {
	        return new FunctionLocator(pageOrFrame, func).setTimeout('getDefaultTimeout' in pageOrFrame
	            ? pageOrFrame.getDefaultTimeout()
	            : pageOrFrame.page().getDefaultTimeout());
	    }
	    #pageOrFrame;
	    #func;
	    constructor(pageOrFrame, func) {
	        super();
	        this.#pageOrFrame = pageOrFrame;
	        this.#func = func;
	    }
	    _clone() {
	        return new FunctionLocator(this.#pageOrFrame, this.#func);
	    }
	    _wait(options) {
	        const signal = options?.signal;
	        return (0, rxjs_js_1.defer)(() => {
	            return (0, rxjs_js_1.from)(this.#pageOrFrame.waitForFunction(this.#func, {
	                timeout: this.timeout,
	                signal,
	            }));
	        }).pipe((0, rxjs_js_1.throwIfEmpty)());
	    }
	};
	FunctionLocator.FunctionLocator = FunctionLocator$1;
	
	return FunctionLocator;
}

var MappedLocator = {};

var hasRequiredMappedLocator;

function requireMappedLocator () {
	if (hasRequiredMappedLocator) return MappedLocator;
	hasRequiredMappedLocator = 1;
	/**
	 * Copyright 2023 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(MappedLocator, "__esModule", { value: true });
	MappedLocator.MappedLocator = void 0;
	const rxjs_js_1 = rxjs;
	const locators_js_1 = requireLocators();
	/**
	 * @internal
	 */
	let MappedLocator$1 = class MappedLocator extends locators_js_1.DelegatedLocator {
	    #mapper;
	    constructor(base, mapper) {
	        super(base);
	        this.#mapper = mapper;
	    }
	    _clone() {
	        return new MappedLocator(this.delegate.clone(), this.#mapper).copyOptions(this);
	    }
	    _wait(options) {
	        return this.delegate._wait(options).pipe((0, rxjs_js_1.mergeMap)(handle => {
	            return (0, rxjs_js_1.from)(Promise.resolve(this.#mapper(handle, options?.signal)));
	        }));
	    }
	};
	MappedLocator.MappedLocator = MappedLocator$1;
	
	return MappedLocator;
}

var NodeLocator = {};

var hasRequiredNodeLocator;

function requireNodeLocator () {
	if (hasRequiredNodeLocator) return NodeLocator;
	hasRequiredNodeLocator = 1;
	/**
	 * Copyright 2023 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(NodeLocator, "__esModule", { value: true });
	NodeLocator.NodeLocator = void 0;
	const rxjs_js_1 = rxjs;
	const locators_js_1 = requireLocators();
	/**
	 * @internal
	 */
	let NodeLocator$1 = class NodeLocator extends locators_js_1.Locator {
	    static create(pageOrFrame, selector) {
	        return new NodeLocator(pageOrFrame, selector).setTimeout('getDefaultTimeout' in pageOrFrame
	            ? pageOrFrame.getDefaultTimeout()
	            : pageOrFrame.page().getDefaultTimeout());
	    }
	    #pageOrFrame;
	    #selector;
	    constructor(pageOrFrame, selector) {
	        super();
	        this.#pageOrFrame = pageOrFrame;
	        this.#selector = selector;
	    }
	    /**
	     * Waits for the element to become visible or hidden. visibility === 'visible'
	     * means that the element has a computed style, the visibility property other
	     * than 'hidden' or 'collapse' and non-empty bounding box. visibility ===
	     * 'hidden' means the opposite of that.
	     */
	    #waitForVisibilityIfNeeded = (handle) => {
	        if (!this.visibility) {
	            return rxjs_js_1.EMPTY;
	        }
	        return (() => {
	            switch (this.visibility) {
	                case 'hidden':
	                    return (0, rxjs_js_1.defer)(() => {
	                        return (0, rxjs_js_1.from)(handle.isHidden());
	                    });
	                case 'visible':
	                    return (0, rxjs_js_1.defer)(() => {
	                        return (0, rxjs_js_1.from)(handle.isVisible());
	                    });
	            }
	        })().pipe((0, rxjs_js_1.first)(rxjs_js_1.identity), (0, rxjs_js_1.retry)({ delay: locators_js_1.RETRY_DELAY }), (0, rxjs_js_1.ignoreElements)());
	    };
	    _clone() {
	        return new NodeLocator(this.#pageOrFrame, this.#selector).copyOptions(this);
	    }
	    _wait(options) {
	        const signal = options?.signal;
	        return (0, rxjs_js_1.defer)(() => {
	            return (0, rxjs_js_1.from)(this.#pageOrFrame.waitForSelector(this.#selector, {
	                visible: false,
	                timeout: this._timeout,
	                signal,
	            }));
	        }).pipe((0, rxjs_js_1.filter)((value) => {
	            return value !== null;
	        }), (0, rxjs_js_1.throwIfEmpty)(), this.operators.conditions([this.#waitForVisibilityIfNeeded], signal));
	    }
	};
	NodeLocator.NodeLocator = NodeLocator$1;
	
	return NodeLocator;
}

var RaceLocator = {};

var hasRequiredRaceLocator;

function requireRaceLocator () {
	if (hasRequiredRaceLocator) return RaceLocator;
	hasRequiredRaceLocator = 1;
	/**
	 * Copyright 2023 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(RaceLocator, "__esModule", { value: true });
	RaceLocator.RaceLocator = void 0;
	const rxjs_js_1 = rxjs;
	const locators_js_1 = requireLocators();
	function checkLocatorArray(locators) {
	    for (const locator of locators) {
	        if (!(locator instanceof locators_js_1.Locator)) {
	            throw new Error('Unknown locator for race candidate');
	        }
	    }
	    return locators;
	}
	/**
	 * @internal
	 */
	let RaceLocator$1 = class RaceLocator extends locators_js_1.Locator {
	    static create(locators) {
	        const array = checkLocatorArray(locators);
	        return new RaceLocator(array);
	    }
	    #locators;
	    constructor(locators) {
	        super();
	        this.#locators = locators;
	    }
	    _clone() {
	        return new RaceLocator(this.#locators.map(locator => {
	            return locator.clone();
	        })).copyOptions(this);
	    }
	    _wait(options) {
	        return (0, rxjs_js_1.race)(...this.#locators.map(locator => {
	            return locator._wait(options);
	        }));
	    }
	};
	RaceLocator.RaceLocator = RaceLocator$1;
	
	return RaceLocator;
}

var hasRequiredLocators;

function requireLocators () {
	if (hasRequiredLocators) return locators;
	hasRequiredLocators = 1;
	(function (exports) {
		/**
		 * Copyright 2023 Google Inc. All rights reserved.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *     http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		/**
		 * Order of exports matters
		 * Don't sort
		 */
		__exportStar(requireLocator(), exports);
		__exportStar(requireDelegatedLocator(), exports);
		__exportStar(requireFilteredLocator(), exports);
		__exportStar(requireFunctionLocator(), exports);
		__exportStar(requireMappedLocator(), exports);
		__exportStar(requireNodeLocator(), exports);
		__exportStar(requireRaceLocator(), exports);
		
	} (locators));
	return locators;
}

(function (exports) {
	/**
	 * Copyright 2023 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var __runInitializers = (commonjsGlobal && commonjsGlobal.__runInitializers) || function (thisArg, initializers, value) {
	    var useValue = arguments.length > 2;
	    for (var i = 0; i < initializers.length; i++) {
	        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
	    }
	    return useValue ? value : void 0;
	};
	var __esDecorate = (commonjsGlobal && commonjsGlobal.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
	    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
	    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
	    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
	    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
	    var _, done = false;
	    for (var i = decorators.length - 1; i >= 0; i--) {
	        var context = {};
	        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
	        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
	        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
	        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
	        if (kind === "accessor") {
	            if (result === void 0) continue;
	            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
	            if (_ = accept(result.get)) descriptor.get = _;
	            if (_ = accept(result.set)) descriptor.set = _;
	            if (_ = accept(result.init)) initializers.unshift(_);
	        }
	        else if (_ = accept(result)) {
	            if (kind === "field") initializers.unshift(_);
	            else descriptor[key] = _;
	        }
	    }
	    if (target) Object.defineProperty(target, contextIn.name, descriptor);
	    done = true;
	};
	var __addDisposableResource = (commonjsGlobal && commonjsGlobal.__addDisposableResource) || function (env, value, async) {
	    if (value !== null && value !== void 0) {
	        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
	        var dispose;
	        if (async) {
	            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
	            dispose = value[Symbol.asyncDispose];
	        }
	        if (dispose === void 0) {
	            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
	            dispose = value[Symbol.dispose];
	        }
	        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
	        env.stack.push({ value: value, dispose: dispose, async: async });
	    }
	    else if (async) {
	        env.stack.push({ async: true });
	    }
	    return value;
	};
	var __disposeResources = (commonjsGlobal && commonjsGlobal.__disposeResources) || (function (SuppressedError) {
	    return function (env) {
	        function fail(e) {
	            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
	            env.hasError = true;
	        }
	        function next() {
	            while (env.stack.length) {
	                var rec = env.stack.pop();
	                try {
	                    var result = rec.dispose && rec.dispose.call(rec.value);
	                    if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
	                }
	                catch (e) {
	                    fail(e);
	                }
	            }
	            if (env.hasError) throw env.error;
	        }
	        return next();
	    };
	})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
	    var e = new Error(message);
	    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
	});
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Frame = exports.throwIfDetached = void 0;
	const EventEmitter_js_1 = EventEmitter$1;
	const GetQueryHandler_js_1 = requireGetQueryHandler();
	const HandleIterator_js_1 = HandleIterator;
	const LazyArg_js_1 = LazyArg$1;
	const util_js_1 = requireUtil();
	const assert_js_1 = assert$1;
	const decorators_js_1 = decorators;
	const locators_js_1 = requireLocators();
	/**
	 * @internal
	 */
	exports.throwIfDetached = (0, decorators_js_1.throwIfDisposed)(frame => {
	    return `Attempted to use detached Frame '${frame._id}'.`;
	});
	/**
	 * Represents a DOM frame.
	 *
	 * To understand frames, you can think of frames as `<iframe>` elements. Just
	 * like iframes, frames can be nested, and when JavaScript is executed in a
	 * frame, the JavaScript does not effect frames inside the ambient frame the
	 * JavaScript executes in.
	 *
	 * @example
	 * At any point in time, {@link Page | pages} expose their current frame
	 * tree via the {@link Page.mainFrame} and {@link Frame.childFrames} methods.
	 *
	 * @example
	 * An example of dumping frame tree:
	 *
	 * ```ts
	 * import puppeteer from 'puppeteer';
	 *
	 * (async () => {
	 *   const browser = await puppeteer.launch();
	 *   const page = await browser.newPage();
	 *   await page.goto('https://www.google.com/chrome/browser/canary.html');
	 *   dumpFrameTree(page.mainFrame(), '');
	 *   await browser.close();
	 *
	 *   function dumpFrameTree(frame, indent) {
	 *     console.log(indent + frame.url());
	 *     for (const child of frame.childFrames()) {
	 *       dumpFrameTree(child, indent + '  ');
	 *     }
	 *   }
	 * })();
	 * ```
	 *
	 * @example
	 * An example of getting text from an iframe element:
	 *
	 * ```ts
	 * const frame = page.frames().find(frame => frame.name() === 'myframe');
	 * const text = await frame.$eval('.selector', element => element.textContent);
	 * console.log(text);
	 * ```
	 *
	 * @remarks
	 * Frame lifecycles are controlled by three events that are all dispatched on
	 * the parent {@link Frame.page | page}:
	 *
	 * - {@link PageEmittedEvents.FrameAttached}
	 * - {@link PageEmittedEvents.FrameNavigated}
	 * - {@link PageEmittedEvents.FrameDetached}
	 *
	 * @public
	 */
	let Frame = (() => {
	    let _classSuper = EventEmitter_js_1.EventEmitter;
	    let _instanceExtraInitializers = [];
	    let _frameElement_decorators;
	    let _evaluateHandle_decorators;
	    let _evaluate_decorators;
	    let _locator_decorators;
	    let _$_decorators;
	    let _$$_decorators;
	    let _$eval_decorators;
	    let _$$eval_decorators;
	    let _$x_decorators;
	    let _waitForSelector_decorators;
	    let _waitForXPath_decorators;
	    let _waitForFunction_decorators;
	    let _content_decorators;
	    let _addScriptTag_decorators;
	    let _addStyleTag_decorators;
	    let _click_decorators;
	    let _focus_decorators;
	    let _hover_decorators;
	    let _select_decorators;
	    let _tap_decorators;
	    let _type_decorators;
	    let _title_decorators;
	    return class Frame extends _classSuper {
	        static {
	            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
	            _frameElement_decorators = [exports.throwIfDetached];
	            _evaluateHandle_decorators = [exports.throwIfDetached];
	            _evaluate_decorators = [exports.throwIfDetached];
	            _locator_decorators = [exports.throwIfDetached];
	            _$_decorators = [exports.throwIfDetached];
	            _$$_decorators = [exports.throwIfDetached];
	            _$eval_decorators = [exports.throwIfDetached];
	            _$$eval_decorators = [exports.throwIfDetached];
	            _$x_decorators = [exports.throwIfDetached];
	            _waitForSelector_decorators = [exports.throwIfDetached];
	            _waitForXPath_decorators = [exports.throwIfDetached];
	            _waitForFunction_decorators = [exports.throwIfDetached];
	            _content_decorators = [exports.throwIfDetached];
	            _addScriptTag_decorators = [exports.throwIfDetached];
	            _addStyleTag_decorators = [exports.throwIfDetached];
	            _click_decorators = [exports.throwIfDetached];
	            _focus_decorators = [exports.throwIfDetached];
	            _hover_decorators = [exports.throwIfDetached];
	            _select_decorators = [exports.throwIfDetached];
	            _tap_decorators = [exports.throwIfDetached];
	            _type_decorators = [exports.throwIfDetached];
	            _title_decorators = [exports.throwIfDetached];
	            __esDecorate(this, null, _frameElement_decorators, { kind: "method", name: "frameElement", static: false, private: false, access: { has: obj => "frameElement" in obj, get: obj => obj.frameElement }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _evaluateHandle_decorators, { kind: "method", name: "evaluateHandle", static: false, private: false, access: { has: obj => "evaluateHandle" in obj, get: obj => obj.evaluateHandle }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _evaluate_decorators, { kind: "method", name: "evaluate", static: false, private: false, access: { has: obj => "evaluate" in obj, get: obj => obj.evaluate }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _locator_decorators, { kind: "method", name: "locator", static: false, private: false, access: { has: obj => "locator" in obj, get: obj => obj.locator }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _$_decorators, { kind: "method", name: "$", static: false, private: false, access: { has: obj => "$" in obj, get: obj => obj.$ }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _$$_decorators, { kind: "method", name: "$$", static: false, private: false, access: { has: obj => "$$" in obj, get: obj => obj.$$ }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _$eval_decorators, { kind: "method", name: "$eval", static: false, private: false, access: { has: obj => "$eval" in obj, get: obj => obj.$eval }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _$$eval_decorators, { kind: "method", name: "$$eval", static: false, private: false, access: { has: obj => "$$eval" in obj, get: obj => obj.$$eval }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _$x_decorators, { kind: "method", name: "$x", static: false, private: false, access: { has: obj => "$x" in obj, get: obj => obj.$x }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _waitForSelector_decorators, { kind: "method", name: "waitForSelector", static: false, private: false, access: { has: obj => "waitForSelector" in obj, get: obj => obj.waitForSelector }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _waitForXPath_decorators, { kind: "method", name: "waitForXPath", static: false, private: false, access: { has: obj => "waitForXPath" in obj, get: obj => obj.waitForXPath }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _waitForFunction_decorators, { kind: "method", name: "waitForFunction", static: false, private: false, access: { has: obj => "waitForFunction" in obj, get: obj => obj.waitForFunction }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _content_decorators, { kind: "method", name: "content", static: false, private: false, access: { has: obj => "content" in obj, get: obj => obj.content }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _addScriptTag_decorators, { kind: "method", name: "addScriptTag", static: false, private: false, access: { has: obj => "addScriptTag" in obj, get: obj => obj.addScriptTag }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _addStyleTag_decorators, { kind: "method", name: "addStyleTag", static: false, private: false, access: { has: obj => "addStyleTag" in obj, get: obj => obj.addStyleTag }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _click_decorators, { kind: "method", name: "click", static: false, private: false, access: { has: obj => "click" in obj, get: obj => obj.click }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _focus_decorators, { kind: "method", name: "focus", static: false, private: false, access: { has: obj => "focus" in obj, get: obj => obj.focus }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _hover_decorators, { kind: "method", name: "hover", static: false, private: false, access: { has: obj => "hover" in obj, get: obj => obj.hover }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _select_decorators, { kind: "method", name: "select", static: false, private: false, access: { has: obj => "select" in obj, get: obj => obj.select }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _tap_decorators, { kind: "method", name: "tap", static: false, private: false, access: { has: obj => "tap" in obj, get: obj => obj.tap }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _type_decorators, { kind: "method", name: "type", static: false, private: false, access: { has: obj => "type" in obj, get: obj => obj.type }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _title_decorators, { kind: "method", name: "title", static: false, private: false, access: { has: obj => "title" in obj, get: obj => obj.title }, metadata: _metadata }, null, _instanceExtraInitializers);
	            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
	        }
	        /**
	         * @internal
	         */
	        _id = (__runInitializers(this, _instanceExtraInitializers), void 0);
	        /**
	         * @internal
	         */
	        _parentId;
	        /**
	         * @internal
	         */
	        worlds;
	        /**
	         * @internal
	         */
	        _name;
	        /**
	         * @internal
	         */
	        _hasStartedLoading = false;
	        /**
	         * @internal
	         */
	        constructor() {
	            super();
	        }
	        /**
	         * Is `true` if the frame is an out-of-process (OOP) frame. Otherwise,
	         * `false`.
	         */
	        isOOPFrame() {
	            throw new Error('Not implemented');
	        }
	        #_document;
	        /**
	         * @internal
	         */
	        #document() {
	            if (!this.#_document) {
	                this.#_document = this.isolatedRealm()
	                    .evaluateHandle(() => {
	                    return document;
	                })
	                    .then(handle => {
	                    return this.mainRealm().transferHandle(handle);
	                });
	            }
	            return this.#_document;
	        }
	        /**
	         * Used to clear the document handle that has been destroyed.
	         *
	         * @internal
	         */
	        clearDocumentHandle() {
	            this.#_document = undefined;
	        }
	        /**
	         * @internal
	         */
	        async frameElement() {
	            const env_1 = { stack: [], error: void 0, hasError: false };
	            try {
	                const parentFrame = this.parentFrame();
	                if (!parentFrame) {
	                    return null;
	                }
	                const list = __addDisposableResource(env_1, await parentFrame.isolatedRealm().evaluateHandle(() => {
	                    return document.querySelectorAll('iframe');
	                }), false);
	                for await (const iframe_1 of (0, HandleIterator_js_1.transposeIterableHandle)(list)) {
	                    const env_2 = { stack: [], error: void 0, hasError: false };
	                    try {
	                        const iframe = __addDisposableResource(env_2, iframe_1, false);
	                        const frame = await iframe.contentFrame();
	                        if (frame._id === this._id) {
	                            return iframe.move();
	                        }
	                    }
	                    catch (e_1) {
	                        env_2.error = e_1;
	                        env_2.hasError = true;
	                    }
	                    finally {
	                        __disposeResources(env_2);
	                    }
	                }
	                return null;
	            }
	            catch (e_2) {
	                env_1.error = e_2;
	                env_1.hasError = true;
	            }
	            finally {
	                __disposeResources(env_1);
	            }
	        }
	        /**
	         * Behaves identically to {@link Page.evaluateHandle} except it's run within
	         * the context of this frame.
	         *
	         * @see {@link Page.evaluateHandle} for details.
	         */
	        async evaluateHandle(pageFunction, ...args) {
	            pageFunction = (0, util_js_1.withSourcePuppeteerURLIfNone)(this.evaluateHandle.name, pageFunction);
	            return await this.mainRealm().evaluateHandle(pageFunction, ...args);
	        }
	        /**
	         * Behaves identically to {@link Page.evaluate} except it's run within the
	         * the context of this frame.
	         *
	         * @see {@link Page.evaluate} for details.
	         */
	        async evaluate(pageFunction, ...args) {
	            pageFunction = (0, util_js_1.withSourcePuppeteerURLIfNone)(this.evaluate.name, pageFunction);
	            return await this.mainRealm().evaluate(pageFunction, ...args);
	        }
	        /**
	         * @internal
	         */
	        locator(selectorOrFunc) {
	            if (typeof selectorOrFunc === 'string') {
	                return locators_js_1.NodeLocator.create(this, selectorOrFunc);
	            }
	            else {
	                return locators_js_1.FunctionLocator.create(this, selectorOrFunc);
	            }
	        }
	        /**
	         * Queries the frame for an element matching the given selector.
	         *
	         * @param selector - The selector to query for.
	         * @returns A {@link ElementHandle | element handle} to the first element
	         * matching the given selector. Otherwise, `null`.
	         */
	        async $(selector) {
	            // eslint-disable-next-line rulesdir/use-using -- This is cached.
	            const document = await this.#document();
	            return await document.$(selector);
	        }
	        /**
	         * Queries the frame for all elements matching the given selector.
	         *
	         * @param selector - The selector to query for.
	         * @returns An array of {@link ElementHandle | element handles} that point to
	         * elements matching the given selector.
	         */
	        async $$(selector) {
	            // eslint-disable-next-line rulesdir/use-using -- This is cached.
	            const document = await this.#document();
	            return await document.$$(selector);
	        }
	        /**
	         * Runs the given function on the first element matching the given selector in
	         * the frame.
	         *
	         * If the given function returns a promise, then this method will wait till
	         * the promise resolves.
	         *
	         * @example
	         *
	         * ```ts
	         * const searchValue = await frame.$eval('#search', el => el.value);
	         * ```
	         *
	         * @param selector - The selector to query for.
	         * @param pageFunction - The function to be evaluated in the frame's context.
	         * The first element matching the selector will be passed to the function as
	         * its first argument.
	         * @param args - Additional arguments to pass to `pageFunction`.
	         * @returns A promise to the result of the function.
	         */
	        async $eval(selector, pageFunction, ...args) {
	            pageFunction = (0, util_js_1.withSourcePuppeteerURLIfNone)(this.$eval.name, pageFunction);
	            // eslint-disable-next-line rulesdir/use-using -- This is cached.
	            const document = await this.#document();
	            return await document.$eval(selector, pageFunction, ...args);
	        }
	        /**
	         * Runs the given function on an array of elements matching the given selector
	         * in the frame.
	         *
	         * If the given function returns a promise, then this method will wait till
	         * the promise resolves.
	         *
	         * @example
	         *
	         * ```js
	         * const divsCounts = await frame.$$eval('div', divs => divs.length);
	         * ```
	         *
	         * @param selector - The selector to query for.
	         * @param pageFunction - The function to be evaluated in the frame's context.
	         * An array of elements matching the given selector will be passed to the
	         * function as its first argument.
	         * @param args - Additional arguments to pass to `pageFunction`.
	         * @returns A promise to the result of the function.
	         */
	        async $$eval(selector, pageFunction, ...args) {
	            pageFunction = (0, util_js_1.withSourcePuppeteerURLIfNone)(this.$$eval.name, pageFunction);
	            // eslint-disable-next-line rulesdir/use-using -- This is cached.
	            const document = await this.#document();
	            return await document.$$eval(selector, pageFunction, ...args);
	        }
	        /**
	         * @deprecated Use {@link Frame.$$} with the `xpath` prefix.
	         *
	         * Example: `await frame.$$('xpath/' + xpathExpression)`
	         *
	         * This method evaluates the given XPath expression and returns the results.
	         * If `xpath` starts with `//` instead of `.//`, the dot will be appended
	         * automatically.
	         * @param expression - the XPath expression to evaluate.
	         */
	        async $x(expression) {
	            // eslint-disable-next-line rulesdir/use-using -- This is cached.
	            const document = await this.#document();
	            return await document.$x(expression);
	        }
	        /**
	         * Waits for an element matching the given selector to appear in the frame.
	         *
	         * This method works across navigations.
	         *
	         * @example
	         *
	         * ```ts
	         * import puppeteer from 'puppeteer';
	         *
	         * (async () => {
	         *   const browser = await puppeteer.launch();
	         *   const page = await browser.newPage();
	         *   let currentURL;
	         *   page
	         *     .mainFrame()
	         *     .waitForSelector('img')
	         *     .then(() => console.log('First URL with image: ' + currentURL));
	         *
	         *   for (currentURL of [
	         *     'https://example.com',
	         *     'https://google.com',
	         *     'https://bbc.com',
	         *   ]) {
	         *     await page.goto(currentURL);
	         *   }
	         *   await browser.close();
	         * })();
	         * ```
	         *
	         * @param selector - The selector to query and wait for.
	         * @param options - Options for customizing waiting behavior.
	         * @returns An element matching the given selector.
	         * @throws Throws if an element matching the given selector doesn't appear.
	         */
	        async waitForSelector(selector, options = {}) {
	            const { updatedSelector, QueryHandler } = (0, GetQueryHandler_js_1.getQueryHandlerAndSelector)(selector);
	            return (await QueryHandler.waitFor(this, updatedSelector, options));
	        }
	        /**
	         * @deprecated Use {@link Frame.waitForSelector} with the `xpath` prefix.
	         *
	         * Example: `await frame.waitForSelector('xpath/' + xpathExpression)`
	         *
	         * The method evaluates the XPath expression relative to the Frame.
	         * If `xpath` starts with `//` instead of `.//`, the dot will be appended
	         * automatically.
	         *
	         * Wait for the `xpath` to appear in page. If at the moment of calling the
	         * method the `xpath` already exists, the method will return immediately. If
	         * the xpath doesn't appear after the `timeout` milliseconds of waiting, the
	         * function will throw.
	         *
	         * For a code example, see the example for {@link Frame.waitForSelector}. That
	         * function behaves identically other than taking a CSS selector rather than
	         * an XPath.
	         *
	         * @param xpath - the XPath expression to wait for.
	         * @param options - options to configure the visibility of the element and how
	         * long to wait before timing out.
	         */
	        async waitForXPath(xpath, options = {}) {
	            if (xpath.startsWith('//')) {
	                xpath = `.${xpath}`;
	            }
	            return await this.waitForSelector(`xpath/${xpath}`, options);
	        }
	        /**
	         * @example
	         * The `waitForFunction` can be used to observe viewport size change:
	         *
	         * ```ts
	         * import puppeteer from 'puppeteer';
	         *
	         * (async () => {
	         * .  const browser = await puppeteer.launch();
	         * .  const page = await browser.newPage();
	         * .  const watchDog = page.mainFrame().waitForFunction('window.innerWidth < 100');
	         * .  page.setViewport({width: 50, height: 50});
	         * .  await watchDog;
	         * .  await browser.close();
	         * })();
	         * ```
	         *
	         * To pass arguments from Node.js to the predicate of `page.waitForFunction` function:
	         *
	         * ```ts
	         * const selector = '.foo';
	         * await frame.waitForFunction(
	         *   selector => !!document.querySelector(selector),
	         *   {}, // empty options object
	         *   selector
	         * );
	         * ```
	         *
	         * @param pageFunction - the function to evaluate in the frame context.
	         * @param options - options to configure the polling method and timeout.
	         * @param args - arguments to pass to the `pageFunction`.
	         * @returns the promise which resolve when the `pageFunction` returns a truthy value.
	         */
	        async waitForFunction(pageFunction, options = {}, ...args) {
	            return await this.mainRealm().waitForFunction(pageFunction, options, ...args);
	        }
	        /**
	         * The full HTML contents of the frame, including the DOCTYPE.
	         */
	        async content() {
	            return await this.evaluate(util_js_1.getPageContent);
	        }
	        /**
	         * The frame's `name` attribute as specified in the tag.
	         *
	         * @remarks
	         * If the name is empty, it returns the `id` attribute instead.
	         *
	         * @remarks
	         * This value is calculated once when the frame is created, and will not
	         * update if the attribute is changed later.
	         */
	        name() {
	            return this._name || '';
	        }
	        /**
	         * Is`true` if the frame has been detached. Otherwise, `false`.
	         *
	         * @deprecated Use the `detached` getter.
	         */
	        isDetached() {
	            return this.detached;
	        }
	        /**
	         * @internal
	         */
	        get disposed() {
	            return this.detached;
	        }
	        /**
	         * Adds a `<script>` tag into the page with the desired url or content.
	         *
	         * @param options - Options for the script.
	         * @returns An {@link ElementHandle | element handle} to the injected
	         * `<script>` element.
	         */
	        async addScriptTag(options) {
	            let { content = '', type } = options;
	            const { path } = options;
	            if (+!!options.url + +!!path + +!!content !== 1) {
	                throw new Error('Exactly one of `url`, `path`, or `content` must be specified.');
	            }
	            if (path) {
	                const fs = await (0, util_js_1.importFSPromises)();
	                content = await fs.readFile(path, 'utf8');
	                content += `//# sourceURL=${path.replace(/\n/g, '')}`;
	            }
	            type = type ?? 'text/javascript';
	            return await this.mainRealm().transferHandle(await this.isolatedRealm().evaluateHandle(async ({ Deferred }, { url, id, type, content }) => {
	                const deferred = Deferred.create();
	                const script = document.createElement('script');
	                script.type = type;
	                script.text = content;
	                if (url) {
	                    script.src = url;
	                    script.addEventListener('load', () => {
	                        return deferred.resolve();
	                    }, { once: true });
	                    script.addEventListener('error', event => {
	                        deferred.reject(new Error(event.message ?? 'Could not load script'));
	                    }, { once: true });
	                }
	                else {
	                    deferred.resolve();
	                }
	                if (id) {
	                    script.id = id;
	                }
	                document.head.appendChild(script);
	                await deferred.valueOrThrow();
	                return script;
	            }, LazyArg_js_1.LazyArg.create(context => {
	                return context.puppeteerUtil;
	            }), { ...options, type, content }));
	        }
	        /**
	         * @internal
	         */
	        async addStyleTag(options) {
	            let { content = '' } = options;
	            const { path } = options;
	            if (+!!options.url + +!!path + +!!content !== 1) {
	                throw new Error('Exactly one of `url`, `path`, or `content` must be specified.');
	            }
	            if (path) {
	                const fs = await (0, util_js_1.importFSPromises)();
	                content = await fs.readFile(path, 'utf8');
	                content += '/*# sourceURL=' + path.replace(/\n/g, '') + '*/';
	                options.content = content;
	            }
	            return await this.mainRealm().transferHandle(await this.isolatedRealm().evaluateHandle(async ({ Deferred }, { url, content }) => {
	                const deferred = Deferred.create();
	                let element;
	                if (!url) {
	                    element = document.createElement('style');
	                    element.appendChild(document.createTextNode(content));
	                }
	                else {
	                    const link = document.createElement('link');
	                    link.rel = 'stylesheet';
	                    link.href = url;
	                    element = link;
	                }
	                element.addEventListener('load', () => {
	                    deferred.resolve();
	                }, { once: true });
	                element.addEventListener('error', event => {
	                    deferred.reject(new Error(event.message ?? 'Could not load style'));
	                }, { once: true });
	                document.head.appendChild(element);
	                await deferred.valueOrThrow();
	                return element;
	            }, LazyArg_js_1.LazyArg.create(context => {
	                return context.puppeteerUtil;
	            }), options));
	        }
	        /**
	         * Clicks the first element found that matches `selector`.
	         *
	         * @remarks
	         * If `click()` triggers a navigation event and there's a separate
	         * `page.waitForNavigation()` promise to be resolved, you may end up with a
	         * race condition that yields unexpected results. The correct pattern for
	         * click and wait for navigation is the following:
	         *
	         * ```ts
	         * const [response] = await Promise.all([
	         *   page.waitForNavigation(waitOptions),
	         *   frame.click(selector, clickOptions),
	         * ]);
	         * ```
	         *
	         * @param selector - The selector to query for.
	         */
	        async click(selector, options = {}) {
	            const env_3 = { stack: [], error: void 0, hasError: false };
	            try {
	                const handle = __addDisposableResource(env_3, await this.$(selector), false);
	                (0, assert_js_1.assert)(handle, `No element found for selector: ${selector}`);
	                await handle.click(options);
	                await handle.dispose();
	            }
	            catch (e_3) {
	                env_3.error = e_3;
	                env_3.hasError = true;
	            }
	            finally {
	                __disposeResources(env_3);
	            }
	        }
	        /**
	         * Focuses the first element that matches the `selector`.
	         *
	         * @param selector - The selector to query for.
	         * @throws Throws if there's no element matching `selector`.
	         */
	        async focus(selector) {
	            const env_4 = { stack: [], error: void 0, hasError: false };
	            try {
	                const handle = __addDisposableResource(env_4, await this.$(selector), false);
	                (0, assert_js_1.assert)(handle, `No element found for selector: ${selector}`);
	                await handle.focus();
	            }
	            catch (e_4) {
	                env_4.error = e_4;
	                env_4.hasError = true;
	            }
	            finally {
	                __disposeResources(env_4);
	            }
	        }
	        /**
	         * Hovers the pointer over the center of the first element that matches the
	         * `selector`.
	         *
	         * @param selector - The selector to query for.
	         * @throws Throws if there's no element matching `selector`.
	         */
	        async hover(selector) {
	            const env_5 = { stack: [], error: void 0, hasError: false };
	            try {
	                const handle = __addDisposableResource(env_5, await this.$(selector), false);
	                (0, assert_js_1.assert)(handle, `No element found for selector: ${selector}`);
	                await handle.hover();
	            }
	            catch (e_5) {
	                env_5.error = e_5;
	                env_5.hasError = true;
	            }
	            finally {
	                __disposeResources(env_5);
	            }
	        }
	        /**
	         * Selects a set of value on the first `<select>` element that matches the
	         * `selector`.
	         *
	         * @example
	         *
	         * ```ts
	         * frame.select('select#colors', 'blue'); // single selection
	         * frame.select('select#colors', 'red', 'green', 'blue'); // multiple selections
	         * ```
	         *
	         * @param selector - The selector to query for.
	         * @param values - The array of values to select. If the `<select>` has the
	         * `multiple` attribute, all values are considered, otherwise only the first
	         * one is taken into account.
	         * @returns the list of values that were successfully selected.
	         * @throws Throws if there's no `<select>` matching `selector`.
	         */
	        async select(selector, ...values) {
	            const env_6 = { stack: [], error: void 0, hasError: false };
	            try {
	                const handle = __addDisposableResource(env_6, await this.$(selector), false);
	                (0, assert_js_1.assert)(handle, `No element found for selector: ${selector}`);
	                return await handle.select(...values);
	            }
	            catch (e_6) {
	                env_6.error = e_6;
	                env_6.hasError = true;
	            }
	            finally {
	                __disposeResources(env_6);
	            }
	        }
	        /**
	         * Taps the first element that matches the `selector`.
	         *
	         * @param selector - The selector to query for.
	         * @throws Throws if there's no element matching `selector`.
	         */
	        async tap(selector) {
	            const env_7 = { stack: [], error: void 0, hasError: false };
	            try {
	                const handle = __addDisposableResource(env_7, await this.$(selector), false);
	                (0, assert_js_1.assert)(handle, `No element found for selector: ${selector}`);
	                await handle.tap();
	            }
	            catch (e_7) {
	                env_7.error = e_7;
	                env_7.hasError = true;
	            }
	            finally {
	                __disposeResources(env_7);
	            }
	        }
	        /**
	         * Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character
	         * in the text.
	         *
	         * @remarks
	         * To press a special key, like `Control` or `ArrowDown`, use
	         * {@link Keyboard.press}.
	         *
	         * @example
	         *
	         * ```ts
	         * await frame.type('#mytextarea', 'Hello'); // Types instantly
	         * await frame.type('#mytextarea', 'World', {delay: 100}); // Types slower, like a user
	         * ```
	         *
	         * @param selector - the selector for the element to type into. If there are
	         * multiple the first will be used.
	         * @param text - text to type into the element
	         * @param options - takes one option, `delay`, which sets the time to wait
	         * between key presses in milliseconds. Defaults to `0`.
	         */
	        async type(selector, text, options) {
	            const env_8 = { stack: [], error: void 0, hasError: false };
	            try {
	                const handle = __addDisposableResource(env_8, await this.$(selector), false);
	                (0, assert_js_1.assert)(handle, `No element found for selector: ${selector}`);
	                await handle.type(text, options);
	            }
	            catch (e_8) {
	                env_8.error = e_8;
	                env_8.hasError = true;
	            }
	            finally {
	                __disposeResources(env_8);
	            }
	        }
	        /**
	         * @deprecated Replace with `new Promise(r => setTimeout(r, milliseconds));`.
	         *
	         * Causes your script to wait for the given number of milliseconds.
	         *
	         * @remarks
	         * It's generally recommended to not wait for a number of seconds, but instead
	         * use {@link Frame.waitForSelector}, {@link Frame.waitForXPath} or
	         * {@link Frame.waitForFunction} to wait for exactly the conditions you want.
	         *
	         * @example
	         *
	         * Wait for 1 second:
	         *
	         * ```ts
	         * await frame.waitForTimeout(1000);
	         * ```
	         *
	         * @param milliseconds - the number of milliseconds to wait.
	         */
	        async waitForTimeout(milliseconds) {
	            return await new Promise(resolve => {
	                setTimeout(resolve, milliseconds);
	            });
	        }
	        /**
	         * The frame's title.
	         */
	        async title() {
	            return await this.isolatedRealm().evaluate(() => {
	                return document.title;
	            });
	        }
	        /**
	         * @internal
	         */
	        waitForDevicePrompt() {
	            throw new Error('Not implemented');
	        }
	        exposeFunction() {
	            throw new Error('Not implemented');
	        }
	    };
	})();
	exports.Frame = Frame;
	
} (Frame$2));

var HTTPRequest$4 = {};

Object.defineProperty(HTTPRequest$4, "__esModule", { value: true });
HTTPRequest$4.STATUS_TEXTS = HTTPRequest$4.headersArray = HTTPRequest$4.InterceptResolutionAction = HTTPRequest$4.HTTPRequest = HTTPRequest$4.DEFAULT_INTERCEPT_RESOLUTION_PRIORITY = void 0;
/**
 * The default cooperative request interception resolution priority
 *
 * @public
 */
HTTPRequest$4.DEFAULT_INTERCEPT_RESOLUTION_PRIORITY = 0;
/**
 * Represents an HTTP request sent by a page.
 * @remarks
 *
 * Whenever the page sends a request, such as for a network resource, the
 * following events are emitted by Puppeteer's `page`:
 *
 * - `request`: emitted when the request is issued by the page.
 * - `requestfinished` - emitted when the response body is downloaded and the
 *   request is complete.
 *
 * If request fails at some point, then instead of `requestfinished` event the
 * `requestfailed` event is emitted.
 *
 * All of these events provide an instance of `HTTPRequest` representing the
 * request that occurred:
 *
 * ```
 * page.on('request', request => ...)
 * ```
 *
 * NOTE: HTTP Error responses, such as 404 or 503, are still successful
 * responses from HTTP standpoint, so request will complete with
 * `requestfinished` event.
 *
 * If request gets a 'redirect' response, the request is successfully finished
 * with the `requestfinished` event, and a new request is issued to a
 * redirected url.
 *
 * @public
 */
let HTTPRequest$3 = class HTTPRequest {
    /**
     * @internal
     */
    _requestId = '';
    /**
     * @internal
     */
    _interceptionId;
    /**
     * @internal
     */
    _failureText = null;
    /**
     * @internal
     */
    _response = null;
    /**
     * @internal
     */
    _fromMemoryCache = false;
    /**
     * @internal
     */
    _redirectChain = [];
    /**
     * Warning! Using this client can break Puppeteer. Use with caution.
     *
     * @experimental
     */
    get client() {
        throw new Error('Not implemented');
    }
    /**
     * @internal
     */
    constructor() { }
    /**
     * The URL of the request
     */
    url() {
        throw new Error('Not implemented');
    }
    /**
     * The `ContinueRequestOverrides` that will be used
     * if the interception is allowed to continue (ie, `abort()` and
     * `respond()` aren't called).
     */
    continueRequestOverrides() {
        throw new Error('Not implemented');
    }
    /**
     * The `ResponseForRequest` that gets used if the
     * interception is allowed to respond (ie, `abort()` is not called).
     */
    responseForRequest() {
        throw new Error('Not implemented');
    }
    /**
     * The most recent reason for aborting the request
     */
    abortErrorReason() {
        throw new Error('Not implemented');
    }
    /**
     * An InterceptResolutionState object describing the current resolution
     * action and priority.
     *
     * InterceptResolutionState contains:
     * action: InterceptResolutionAction
     * priority?: number
     *
     * InterceptResolutionAction is one of: `abort`, `respond`, `continue`,
     * `disabled`, `none`, or `already-handled`.
     */
    interceptResolutionState() {
        throw new Error('Not implemented');
    }
    /**
     * Is `true` if the intercept resolution has already been handled,
     * `false` otherwise.
     */
    isInterceptResolutionHandled() {
        throw new Error('Not implemented');
    }
    enqueueInterceptAction() {
        throw new Error('Not implemented');
    }
    /**
     * Awaits pending interception handlers and then decides how to fulfill
     * the request interception.
     */
    async finalizeInterceptions() {
        throw new Error('Not implemented');
    }
    /**
     * Contains the request's resource type as it was perceived by the rendering
     * engine.
     */
    resourceType() {
        throw new Error('Not implemented');
    }
    /**
     * The method used (`GET`, `POST`, etc.)
     */
    method() {
        throw new Error('Not implemented');
    }
    /**
     * The request's post body, if any.
     */
    postData() {
        throw new Error('Not implemented');
    }
    /**
     * An object with HTTP headers associated with the request. All
     * header names are lower-case.
     */
    headers() {
        throw new Error('Not implemented');
    }
    /**
     * A matching `HTTPResponse` object, or null if the response has not
     * been received yet.
     */
    response() {
        throw new Error('Not implemented');
    }
    /**
     * The frame that initiated the request, or null if navigating to
     * error pages.
     */
    frame() {
        throw new Error('Not implemented');
    }
    /**
     * True if the request is the driver of the current frame's navigation.
     */
    isNavigationRequest() {
        throw new Error('Not implemented');
    }
    /**
     * The initiator of the request.
     */
    initiator() {
        throw new Error('Not implemented');
    }
    /**
     * A `redirectChain` is a chain of requests initiated to fetch a resource.
     * @remarks
     *
     * `redirectChain` is shared between all the requests of the same chain.
     *
     * For example, if the website `http://example.com` has a single redirect to
     * `https://example.com`, then the chain will contain one request:
     *
     * ```ts
     * const response = await page.goto('http://example.com');
     * const chain = response.request().redirectChain();
     * console.log(chain.length); // 1
     * console.log(chain[0].url()); // 'http://example.com'
     * ```
     *
     * If the website `https://google.com` has no redirects, then the chain will be empty:
     *
     * ```ts
     * const response = await page.goto('https://google.com');
     * const chain = response.request().redirectChain();
     * console.log(chain.length); // 0
     * ```
     *
     * @returns the chain of requests - if a server responds with at least a
     * single redirect, this chain will contain all requests that were redirected.
     */
    redirectChain() {
        throw new Error('Not implemented');
    }
    /**
     * Access information about the request's failure.
     *
     * @remarks
     *
     * @example
     *
     * Example of logging all failed requests:
     *
     * ```ts
     * page.on('requestfailed', request => {
     *   console.log(request.url() + ' ' + request.failure().errorText);
     * });
     * ```
     *
     * @returns `null` unless the request failed. If the request fails this can
     * return an object with `errorText` containing a human-readable error
     * message, e.g. `net::ERR_FAILED`. It is not guaranteed that there will be
     * failure text if the request fails.
     */
    failure() {
        throw new Error('Not implemented');
    }
    async continue() {
        throw new Error('Not implemented');
    }
    async respond() {
        throw new Error('Not implemented');
    }
    async abort() {
        throw new Error('Not implemented');
    }
};
HTTPRequest$4.HTTPRequest = HTTPRequest$3;
/**
 * @public
 */
var InterceptResolutionAction;
(function (InterceptResolutionAction) {
    InterceptResolutionAction["Abort"] = "abort";
    InterceptResolutionAction["Respond"] = "respond";
    InterceptResolutionAction["Continue"] = "continue";
    InterceptResolutionAction["Disabled"] = "disabled";
    InterceptResolutionAction["None"] = "none";
    InterceptResolutionAction["AlreadyHandled"] = "already-handled";
})(InterceptResolutionAction || (HTTPRequest$4.InterceptResolutionAction = InterceptResolutionAction = {}));
/**
 * @internal
 */
function headersArray(headers) {
    const result = [];
    for (const name in headers) {
        const value = headers[name];
        if (!Object.is(value, undefined)) {
            const values = Array.isArray(value) ? value : [value];
            result.push(...values.map(value => {
                return { name, value: value + '' };
            }));
        }
    }
    return result;
}
HTTPRequest$4.headersArray = headersArray;
/**
 * @internal
 *
 * @remarks
 * List taken from {@link https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml}
 * with extra 306 and 418 codes.
 */
HTTPRequest$4.STATUS_TEXTS = {
    '100': 'Continue',
    '101': 'Switching Protocols',
    '102': 'Processing',
    '103': 'Early Hints',
    '200': 'OK',
    '201': 'Created',
    '202': 'Accepted',
    '203': 'Non-Authoritative Information',
    '204': 'No Content',
    '205': 'Reset Content',
    '206': 'Partial Content',
    '207': 'Multi-Status',
    '208': 'Already Reported',
    '226': 'IM Used',
    '300': 'Multiple Choices',
    '301': 'Moved Permanently',
    '302': 'Found',
    '303': 'See Other',
    '304': 'Not Modified',
    '305': 'Use Proxy',
    '306': 'Switch Proxy',
    '307': 'Temporary Redirect',
    '308': 'Permanent Redirect',
    '400': 'Bad Request',
    '401': 'Unauthorized',
    '402': 'Payment Required',
    '403': 'Forbidden',
    '404': 'Not Found',
    '405': 'Method Not Allowed',
    '406': 'Not Acceptable',
    '407': 'Proxy Authentication Required',
    '408': 'Request Timeout',
    '409': 'Conflict',
    '410': 'Gone',
    '411': 'Length Required',
    '412': 'Precondition Failed',
    '413': 'Payload Too Large',
    '414': 'URI Too Long',
    '415': 'Unsupported Media Type',
    '416': 'Range Not Satisfiable',
    '417': 'Expectation Failed',
    '418': "I'm a teapot",
    '421': 'Misdirected Request',
    '422': 'Unprocessable Entity',
    '423': 'Locked',
    '424': 'Failed Dependency',
    '425': 'Too Early',
    '426': 'Upgrade Required',
    '428': 'Precondition Required',
    '429': 'Too Many Requests',
    '431': 'Request Header Fields Too Large',
    '451': 'Unavailable For Legal Reasons',
    '500': 'Internal Server Error',
    '501': 'Not Implemented',
    '502': 'Bad Gateway',
    '503': 'Service Unavailable',
    '504': 'Gateway Timeout',
    '505': 'HTTP Version Not Supported',
    '506': 'Variant Also Negotiates',
    '507': 'Insufficient Storage',
    '508': 'Loop Detected',
    '510': 'Not Extended',
    '511': 'Network Authentication Required',
};

var HTTPResponse$4 = {};

/**
 * Copyright 2023 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(HTTPResponse$4, "__esModule", { value: true });
HTTPResponse$4.HTTPResponse = void 0;
/**
 * The HTTPResponse class represents responses which are received by the
 * {@link Page} class.
 *
 * @public
 */
let HTTPResponse$3 = class HTTPResponse {
    /**
     * @internal
     */
    constructor() { }
    /**
     * @internal
     */
    _resolveBody(_err) {
        throw new Error('Not implemented');
    }
    /**
     * The IP address and port number used to connect to the remote
     * server.
     */
    remoteAddress() {
        throw new Error('Not implemented');
    }
    /**
     * The URL of the response.
     */
    url() {
        throw new Error('Not implemented');
    }
    /**
     * True if the response was successful (status in the range 200-299).
     */
    ok() {
        // TODO: document === 0 case?
        const status = this.status();
        return status === 0 || (status >= 200 && status <= 299);
    }
    /**
     * The status code of the response (e.g., 200 for a success).
     */
    status() {
        throw new Error('Not implemented');
    }
    /**
     * The status text of the response (e.g. usually an "OK" for a
     * success).
     */
    statusText() {
        throw new Error('Not implemented');
    }
    /**
     * An object with HTTP headers associated with the response. All
     * header names are lower-case.
     */
    headers() {
        throw new Error('Not implemented');
    }
    /**
     * {@link SecurityDetails} if the response was received over the
     * secure connection, or `null` otherwise.
     */
    securityDetails() {
        throw new Error('Not implemented');
    }
    /**
     * Timing information related to the response.
     */
    timing() {
        throw new Error('Not implemented');
    }
    /**
     * Promise which resolves to a buffer with response body.
     */
    buffer() {
        throw new Error('Not implemented');
    }
    /**
     * Promise which resolves to a text representation of response body.
     */
    async text() {
        const content = await this.buffer();
        return content.toString('utf8');
    }
    /**
     * Promise which resolves to a JSON representation of response body.
     *
     * @remarks
     *
     * This method will throw if the response body is not parsable via
     * `JSON.parse`.
     */
    async json() {
        const content = await this.text();
        return JSON.parse(content);
    }
    /**
     * A matching {@link HTTPRequest} object.
     */
    request() {
        throw new Error('Not implemented');
    }
    /**
     * True if the response was served from either the browser's disk
     * cache or memory cache.
     */
    fromCache() {
        throw new Error('Not implemented');
    }
    /**
     * True if the response was served by a service worker.
     */
    fromServiceWorker() {
        throw new Error('Not implemented');
    }
    /**
     * A {@link Frame} that initiated this response, or `null` if
     * navigating to error pages.
     */
    frame() {
        throw new Error('Not implemented');
    }
};
HTTPResponse$4.HTTPResponse = HTTPResponse$3;

var Input$2 = {};

/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(Input$2, "__esModule", { value: true });
Input$2.Touchscreen = Input$2.Mouse = Input$2.MouseButton = Input$2.Keyboard = void 0;
/**
 * Keyboard provides an api for managing a virtual keyboard.
 * The high level api is {@link Keyboard."type"},
 * which takes raw characters and generates proper keydown, keypress/input,
 * and keyup events on your page.
 *
 * @remarks
 * For finer control, you can use {@link Keyboard.down},
 * {@link Keyboard.up}, and {@link Keyboard.sendCharacter}
 * to manually fire events as if they were generated from a real keyboard.
 *
 * On macOS, keyboard shortcuts like `⌘ A` -\> Select All do not work.
 * See {@link https://github.com/puppeteer/puppeteer/issues/1313 | #1313}.
 *
 * @example
 * An example of holding down `Shift` in order to select and delete some text:
 *
 * ```ts
 * await page.keyboard.type('Hello World!');
 * await page.keyboard.press('ArrowLeft');
 *
 * await page.keyboard.down('Shift');
 * for (let i = 0; i < ' World'.length; i++)
 *   await page.keyboard.press('ArrowLeft');
 * await page.keyboard.up('Shift');
 *
 * await page.keyboard.press('Backspace');
 * // Result text will end up saying 'Hello!'
 * ```
 *
 * @example
 * An example of pressing `A`
 *
 * ```ts
 * await page.keyboard.down('Shift');
 * await page.keyboard.press('KeyA');
 * await page.keyboard.up('Shift');
 * ```
 *
 * @public
 */
class Keyboard {
    /**
     * @internal
     */
    constructor() { }
    async down() {
        throw new Error('Not implemented');
    }
    async up() {
        throw new Error('Not implemented');
    }
    async sendCharacter() {
        throw new Error('Not implemented');
    }
    async type() {
        throw new Error('Not implemented');
    }
    async press() {
        throw new Error('Not implemented');
    }
}
Input$2.Keyboard = Keyboard;
/**
 * Enum of valid mouse buttons.
 *
 * @public
 */
Input$2.MouseButton = Object.freeze({
    Left: 'left',
    Right: 'right',
    Middle: 'middle',
    Back: 'back',
    Forward: 'forward',
});
/**
 * The Mouse class operates in main-frame CSS pixels
 * relative to the top-left corner of the viewport.
 * @remarks
 * Every `page` object has its own Mouse, accessible with [`page.mouse`](#pagemouse).
 *
 * @example
 *
 * ```ts
 * // Using ‘page.mouse’ to trace a 100x100 square.
 * await page.mouse.move(0, 0);
 * await page.mouse.down();
 * await page.mouse.move(0, 100);
 * await page.mouse.move(100, 100);
 * await page.mouse.move(100, 0);
 * await page.mouse.move(0, 0);
 * await page.mouse.up();
 * ```
 *
 * **Note**: The mouse events trigger synthetic `MouseEvent`s.
 * This means that it does not fully replicate the functionality of what a normal user
 * would be able to do with their mouse.
 *
 * For example, dragging and selecting text is not possible using `page.mouse`.
 * Instead, you can use the {@link https://developer.mozilla.org/en-US/docs/Web/API/DocumentOrShadowRoot/getSelection | `DocumentOrShadowRoot.getSelection()`} functionality implemented in the platform.
 *
 * @example
 * For example, if you want to select all content between nodes:
 *
 * ```ts
 * await page.evaluate(
 *   (from, to) => {
 *     const selection = from.getRootNode().getSelection();
 *     const range = document.createRange();
 *     range.setStartBefore(from);
 *     range.setEndAfter(to);
 *     selection.removeAllRanges();
 *     selection.addRange(range);
 *   },
 *   fromJSHandle,
 *   toJSHandle
 * );
 * ```
 *
 * If you then would want to copy-paste your selection, you can use the clipboard api:
 *
 * ```ts
 * // The clipboard api does not allow you to copy, unless the tab is focused.
 * await page.bringToFront();
 * await page.evaluate(() => {
 *   // Copy the selected content to the clipboard
 *   document.execCommand('copy');
 *   // Obtain the content of the clipboard as a string
 *   return navigator.clipboard.readText();
 * });
 * ```
 *
 * **Note**: If you want access to the clipboard API,
 * you have to give it permission to do so:
 *
 * ```ts
 * await browser
 *   .defaultBrowserContext()
 *   .overridePermissions('<your origin>', [
 *     'clipboard-read',
 *     'clipboard-write',
 *   ]);
 * ```
 *
 * @public
 */
class Mouse {
    /**
     * @internal
     */
    constructor() { }
    /**
     * Resets the mouse to the default state: No buttons pressed; position at
     * (0,0).
     */
    async reset() {
        throw new Error('Not implemented');
    }
    async move() {
        throw new Error('Not implemented');
    }
    async down() {
        throw new Error('Not implemented');
    }
    async up() {
        throw new Error('Not implemented');
    }
    async click() {
        throw new Error('Not implemented');
    }
    async wheel() {
        throw new Error('Not implemented');
    }
    async drag() {
        throw new Error('Not implemented');
    }
    async dragEnter() {
        throw new Error('Not implemented');
    }
    async dragOver() {
        throw new Error('Not implemented');
    }
    async drop() {
        throw new Error('Not implemented');
    }
    async dragAndDrop() {
        throw new Error('Not implemented');
    }
}
Input$2.Mouse = Mouse;
/**
 * The Touchscreen class exposes touchscreen events.
 * @public
 */
class Touchscreen {
    /**
     * @internal
     */
    constructor() { }
    async tap() {
        throw new Error('Not implemented');
    }
    async touchStart() {
        throw new Error('Not implemented');
    }
    async touchMove() {
        throw new Error('Not implemented');
    }
    async touchEnd() {
        throw new Error('Not implemented');
    }
}
Input$2.Touchscreen = Touchscreen;

var Page$2 = {};

var NetworkManager$1 = {};

var Connection$1 = {};

(function (exports) {
	/**
	 * Copyright 2017 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.isTargetClosedError = exports.CDPSessionImpl = exports.CDPSession = exports.CDPSessionEmittedEvents = exports.Connection = exports.CallbackRegistry = exports.Callback = exports.ConnectionEmittedEvents = void 0;
	const assert_js_1 = assert$1;
	const Deferred_js_1 = Deferred$1;
	const Debug_js_1 = Debug;
	const Errors_js_1 = Errors;
	const EventEmitter_js_1 = EventEmitter$1;
	const util_js_1 = requireUtil();
	const debugProtocolSend = (0, Debug_js_1.debug)('puppeteer:protocol:SEND ►');
	const debugProtocolReceive = (0, Debug_js_1.debug)('puppeteer:protocol:RECV ◀');
	/**
	 * Internal events that the Connection class emits.
	 *
	 * @internal
	 */
	exports.ConnectionEmittedEvents = {
	    Disconnected: Symbol('Connection.Disconnected'),
	};
	/**
	 * @internal
	 */
	function createIncrementalIdGenerator() {
	    let id = 0;
	    return () => {
	        return ++id;
	    };
	}
	/**
	 * @internal
	 */
	class Callback {
	    #id;
	    #error = new Errors_js_1.ProtocolError();
	    #deferred = Deferred_js_1.Deferred.create();
	    #timer;
	    #label;
	    constructor(id, label, timeout) {
	        this.#id = id;
	        this.#label = label;
	        if (timeout) {
	            this.#timer = setTimeout(() => {
	                this.#deferred.reject(rewriteError(this.#error, `${label} timed out. Increase the 'protocolTimeout' setting in launch/connect calls for a higher timeout if needed.`));
	            }, timeout);
	        }
	    }
	    resolve(value) {
	        clearTimeout(this.#timer);
	        this.#deferred.resolve(value);
	    }
	    reject(error) {
	        clearTimeout(this.#timer);
	        this.#deferred.reject(error);
	    }
	    get id() {
	        return this.#id;
	    }
	    get promise() {
	        return this.#deferred;
	    }
	    get error() {
	        return this.#error;
	    }
	    get label() {
	        return this.#label;
	    }
	}
	exports.Callback = Callback;
	/**
	 * Manages callbacks and their IDs for the protocol request/response communication.
	 *
	 * @internal
	 */
	class CallbackRegistry {
	    #callbacks = new Map();
	    #idGenerator = createIncrementalIdGenerator();
	    create(label, timeout, request) {
	        const callback = new Callback(this.#idGenerator(), label, timeout);
	        this.#callbacks.set(callback.id, callback);
	        try {
	            request(callback.id);
	        }
	        catch (error) {
	            // We still throw sync errors synchronously and clean up the scheduled
	            // callback.
	            callback.promise
	                .valueOrThrow()
	                .catch(util_js_1.debugError)
	                .finally(() => {
	                this.#callbacks.delete(callback.id);
	            });
	            callback.reject(error);
	            throw error;
	        }
	        // Must only have sync code up until here.
	        return callback.promise.valueOrThrow().finally(() => {
	            this.#callbacks.delete(callback.id);
	        });
	    }
	    reject(id, message, originalMessage) {
	        const callback = this.#callbacks.get(id);
	        if (!callback) {
	            return;
	        }
	        this._reject(callback, message, originalMessage);
	    }
	    _reject(callback, errorMessage, originalMessage) {
	        let error;
	        let message;
	        if (errorMessage instanceof Errors_js_1.ProtocolError) {
	            error = errorMessage;
	            error.cause = callback.error;
	            message = errorMessage.message;
	        }
	        else {
	            error = callback.error;
	            message = errorMessage;
	        }
	        callback.reject(rewriteError(error, `Protocol error (${callback.label}): ${message}`, originalMessage));
	    }
	    resolve(id, value) {
	        const callback = this.#callbacks.get(id);
	        if (!callback) {
	            return;
	        }
	        callback.resolve(value);
	    }
	    clear() {
	        for (const callback of this.#callbacks.values()) {
	            // TODO: probably we can accept error messages as params.
	            this._reject(callback, new Errors_js_1.TargetCloseError('Target closed'));
	        }
	        this.#callbacks.clear();
	    }
	}
	exports.CallbackRegistry = CallbackRegistry;
	/**
	 * @public
	 */
	class Connection extends EventEmitter_js_1.EventEmitter {
	    #url;
	    #transport;
	    #delay;
	    #timeout;
	    #sessions = new Map();
	    #closed = false;
	    #manuallyAttached = new Set();
	    #callbacks = new CallbackRegistry();
	    constructor(url, transport, delay = 0, timeout) {
	        super();
	        this.#url = url;
	        this.#delay = delay;
	        this.#timeout = timeout ?? 180000;
	        this.#transport = transport;
	        this.#transport.onmessage = this.onMessage.bind(this);
	        this.#transport.onclose = this.#onClose.bind(this);
	    }
	    static fromSession(session) {
	        return session.connection();
	    }
	    get timeout() {
	        return this.#timeout;
	    }
	    /**
	     * @internal
	     */
	    get _closed() {
	        return this.#closed;
	    }
	    /**
	     * @internal
	     */
	    get _sessions() {
	        return this.#sessions;
	    }
	    /**
	     * @param sessionId - The session id
	     * @returns The current CDP session if it exists
	     */
	    session(sessionId) {
	        return this.#sessions.get(sessionId) || null;
	    }
	    url() {
	        return this.#url;
	    }
	    send(method, ...paramArgs) {
	        // There is only ever 1 param arg passed, but the Protocol defines it as an
	        // array of 0 or 1 items See this comment:
	        // https://github.com/ChromeDevTools/devtools-protocol/pull/113#issuecomment-412603285
	        // which explains why the protocol defines the params this way for better
	        // type-inference.
	        // So now we check if there are any params or not and deal with them accordingly.
	        const params = paramArgs.length ? paramArgs[0] : undefined;
	        return this._rawSend(this.#callbacks, method, params);
	    }
	    /**
	     * @internal
	     */
	    _rawSend(callbacks, method, params, sessionId) {
	        return callbacks.create(method, this.#timeout, id => {
	            const stringifiedMessage = JSON.stringify({
	                method,
	                params,
	                id,
	                sessionId,
	            });
	            debugProtocolSend(stringifiedMessage);
	            this.#transport.send(stringifiedMessage);
	        });
	    }
	    /**
	     * @internal
	     */
	    async closeBrowser() {
	        await this.send('Browser.close');
	    }
	    /**
	     * @internal
	     */
	    async onMessage(message) {
	        if (this.#delay) {
	            await new Promise(r => {
	                return setTimeout(r, this.#delay);
	            });
	        }
	        debugProtocolReceive(message);
	        const object = JSON.parse(message);
	        if (object.method === 'Target.attachedToTarget') {
	            const sessionId = object.params.sessionId;
	            const session = new CDPSessionImpl(this, object.params.targetInfo.type, sessionId, object.sessionId);
	            this.#sessions.set(sessionId, session);
	            this.emit('sessionattached', session);
	            const parentSession = this.#sessions.get(object.sessionId);
	            if (parentSession) {
	                parentSession.emit('sessionattached', session);
	            }
	        }
	        else if (object.method === 'Target.detachedFromTarget') {
	            const session = this.#sessions.get(object.params.sessionId);
	            if (session) {
	                session._onClosed();
	                this.#sessions.delete(object.params.sessionId);
	                this.emit('sessiondetached', session);
	                const parentSession = this.#sessions.get(object.sessionId);
	                if (parentSession) {
	                    parentSession.emit('sessiondetached', session);
	                }
	            }
	        }
	        if (object.sessionId) {
	            const session = this.#sessions.get(object.sessionId);
	            if (session) {
	                session._onMessage(object);
	            }
	        }
	        else if (object.id) {
	            if (object.error) {
	                this.#callbacks.reject(object.id, createProtocolErrorMessage(object), object.error.message);
	            }
	            else {
	                this.#callbacks.resolve(object.id, object.result);
	            }
	        }
	        else {
	            this.emit(object.method, object.params);
	        }
	    }
	    #onClose() {
	        if (this.#closed) {
	            return;
	        }
	        this.#closed = true;
	        this.#transport.onmessage = undefined;
	        this.#transport.onclose = undefined;
	        this.#callbacks.clear();
	        for (const session of this.#sessions.values()) {
	            session._onClosed();
	        }
	        this.#sessions.clear();
	        this.emit(exports.ConnectionEmittedEvents.Disconnected);
	    }
	    dispose() {
	        this.#onClose();
	        this.#transport.close();
	    }
	    /**
	     * @internal
	     */
	    isAutoAttached(targetId) {
	        return !this.#manuallyAttached.has(targetId);
	    }
	    /**
	     * @internal
	     */
	    async _createSession(targetInfo, isAutoAttachEmulated = true) {
	        if (!isAutoAttachEmulated) {
	            this.#manuallyAttached.add(targetInfo.targetId);
	        }
	        const { sessionId } = await this.send('Target.attachToTarget', {
	            targetId: targetInfo.targetId,
	            flatten: true,
	        });
	        this.#manuallyAttached.delete(targetInfo.targetId);
	        const session = this.#sessions.get(sessionId);
	        if (!session) {
	            throw new Error('CDPSession creation failed.');
	        }
	        return session;
	    }
	    /**
	     * @param targetInfo - The target info
	     * @returns The CDP session that is created
	     */
	    async createSession(targetInfo) {
	        return await this._createSession(targetInfo, false);
	    }
	}
	exports.Connection = Connection;
	/**
	 * Internal events that the CDPSession class emits.
	 *
	 * @internal
	 */
	exports.CDPSessionEmittedEvents = {
	    Disconnected: Symbol('CDPSession.Disconnected'),
	    Swapped: Symbol('CDPSession.Swapped'),
	    /**
	     * Emitted when the session is ready to be configured during the auto-attach
	     * process. Right after the event is handled, the session will be resumed.
	     */
	    Ready: Symbol('CDPSession.Ready'),
	};
	/**
	 * The `CDPSession` instances are used to talk raw Chrome Devtools Protocol.
	 *
	 * @remarks
	 *
	 * Protocol methods can be called with {@link CDPSession.send} method and protocol
	 * events can be subscribed to with `CDPSession.on` method.
	 *
	 * Useful links: {@link https://chromedevtools.github.io/devtools-protocol/ | DevTools Protocol Viewer}
	 * and {@link https://github.com/aslushnikov/getting-started-with-cdp/blob/HEAD/README.md | Getting Started with DevTools Protocol}.
	 *
	 * @example
	 *
	 * ```ts
	 * const client = await page.target().createCDPSession();
	 * await client.send('Animation.enable');
	 * client.on('Animation.animationCreated', () =>
	 *   console.log('Animation created!')
	 * );
	 * const response = await client.send('Animation.getPlaybackRate');
	 * console.log('playback rate is ' + response.playbackRate);
	 * await client.send('Animation.setPlaybackRate', {
	 *   playbackRate: response.playbackRate / 2,
	 * });
	 * ```
	 *
	 * @public
	 */
	class CDPSession extends EventEmitter_js_1.EventEmitter {
	    /**
	     * @internal
	     */
	    constructor() {
	        super();
	    }
	    connection() {
	        throw new Error('Not implemented');
	    }
	    /**
	     * Parent session in terms of CDP's auto-attach mechanism.
	     *
	     * @internal
	     */
	    parentSession() {
	        return undefined;
	    }
	    send() {
	        throw new Error('Not implemented');
	    }
	    /**
	     * Detaches the cdpSession from the target. Once detached, the cdpSession object
	     * won't emit any events and can't be used to send messages.
	     */
	    async detach() {
	        throw new Error('Not implemented');
	    }
	    /**
	     * Returns the session's id.
	     */
	    id() {
	        throw new Error('Not implemented');
	    }
	}
	exports.CDPSession = CDPSession;
	/**
	 * @internal
	 */
	class CDPSessionImpl extends CDPSession {
	    #sessionId;
	    #targetType;
	    #callbacks = new CallbackRegistry();
	    #connection;
	    #parentSessionId;
	    #target;
	    /**
	     * @internal
	     */
	    constructor(connection, targetType, sessionId, parentSessionId) {
	        super();
	        this.#connection = connection;
	        this.#targetType = targetType;
	        this.#sessionId = sessionId;
	        this.#parentSessionId = parentSessionId;
	    }
	    /**
	     * Sets the CDPTarget associated with the session instance.
	     *
	     * @internal
	     */
	    _setTarget(target) {
	        this.#target = target;
	    }
	    /**
	     * Gets the CDPTarget associated with the session instance.
	     *
	     * @internal
	     */
	    _target() {
	        (0, assert_js_1.assert)(this.#target, 'Target must exist');
	        return this.#target;
	    }
	    connection() {
	        return this.#connection;
	    }
	    parentSession() {
	        if (!this.#parentSessionId) {
	            return;
	        }
	        const parent = this.#connection?.session(this.#parentSessionId);
	        return parent ?? undefined;
	    }
	    send(method, ...paramArgs) {
	        if (!this.#connection) {
	            return Promise.reject(new Errors_js_1.TargetCloseError(`Protocol error (${method}): Session closed. Most likely the ${this.#targetType} has been closed.`));
	        }
	        // See the comment in Connection#send explaining why we do this.
	        const params = paramArgs.length ? paramArgs[0] : undefined;
	        return this.#connection._rawSend(this.#callbacks, method, params, this.#sessionId);
	    }
	    /**
	     * @internal
	     */
	    _onMessage(object) {
	        if (object.id) {
	            if (object.error) {
	                this.#callbacks.reject(object.id, createProtocolErrorMessage(object), object.error.message);
	            }
	            else {
	                this.#callbacks.resolve(object.id, object.result);
	            }
	        }
	        else {
	            (0, assert_js_1.assert)(!object.id);
	            this.emit(object.method, object.params);
	        }
	    }
	    /**
	     * Detaches the cdpSession from the target. Once detached, the cdpSession object
	     * won't emit any events and can't be used to send messages.
	     */
	    async detach() {
	        if (!this.#connection) {
	            throw new Error(`Session already detached. Most likely the ${this.#targetType} has been closed.`);
	        }
	        await this.#connection.send('Target.detachFromTarget', {
	            sessionId: this.#sessionId,
	        });
	    }
	    /**
	     * @internal
	     */
	    _onClosed() {
	        this.#callbacks.clear();
	        this.#connection = undefined;
	        this.emit(exports.CDPSessionEmittedEvents.Disconnected);
	    }
	    /**
	     * Returns the session's id.
	     */
	    id() {
	        return this.#sessionId;
	    }
	}
	exports.CDPSessionImpl = CDPSessionImpl;
	function createProtocolErrorMessage(object) {
	    let message = `${object.error.message}`;
	    // TODO: remove the type checks when we stop connecting to BiDi with a CDP
	    // client.
	    if (object.error &&
	        typeof object.error === 'object' &&
	        'data' in object.error) {
	        message += ` ${object.error.data}`;
	    }
	    return message;
	}
	function rewriteError(error, message, originalMessage) {
	    error.message = message;
	    error.originalMessage = originalMessage ?? error.originalMessage;
	    return error;
	}
	/**
	 * @internal
	 */
	function isTargetClosedError(error) {
	    return error instanceof Errors_js_1.TargetCloseError;
	}
	exports.isTargetClosedError = isTargetClosedError;
	
} (Connection$1));

var HTTPRequest$2 = {};

Object.defineProperty(HTTPRequest$2, "__esModule", { value: true });
HTTPRequest$2.HTTPRequest = void 0;
const HTTPRequest_js_1 = HTTPRequest$4;
const assert_js_1$e = assert$1;
const util_js_1$e = requireUtil();
/**
 * @internal
 */
let HTTPRequest$1 = class HTTPRequest extends HTTPRequest_js_1.HTTPRequest {
    _requestId;
    _interceptionId;
    _failureText = null;
    _response = null;
    _fromMemoryCache = false;
    _redirectChain;
    #client;
    #isNavigationRequest;
    #allowInterception;
    #interceptionHandled = false;
    #url;
    #resourceType;
    #method;
    #postData;
    #headers = {};
    #frame;
    #continueRequestOverrides;
    #responseForRequest = null;
    #abortErrorReason = null;
    #interceptResolutionState = {
        action: HTTPRequest_js_1.InterceptResolutionAction.None,
    };
    #interceptHandlers;
    #initiator;
    get client() {
        return this.#client;
    }
    constructor(client, frame, interceptionId, allowInterception, data, redirectChain) {
        super();
        this.#client = client;
        this._requestId = data.requestId;
        this.#isNavigationRequest =
            data.requestId === data.loaderId && data.type === 'Document';
        this._interceptionId = interceptionId;
        this.#allowInterception = allowInterception;
        this.#url = data.request.url;
        this.#resourceType = (data.type || 'other').toLowerCase();
        this.#method = data.request.method;
        this.#postData = data.request.postData;
        this.#frame = frame;
        this._redirectChain = redirectChain;
        this.#continueRequestOverrides = {};
        this.#interceptHandlers = [];
        this.#initiator = data.initiator;
        for (const [key, value] of Object.entries(data.request.headers)) {
            this.#headers[key.toLowerCase()] = value;
        }
    }
    url() {
        return this.#url;
    }
    continueRequestOverrides() {
        (0, assert_js_1$e.assert)(this.#allowInterception, 'Request Interception is not enabled!');
        return this.#continueRequestOverrides;
    }
    responseForRequest() {
        (0, assert_js_1$e.assert)(this.#allowInterception, 'Request Interception is not enabled!');
        return this.#responseForRequest;
    }
    abortErrorReason() {
        (0, assert_js_1$e.assert)(this.#allowInterception, 'Request Interception is not enabled!');
        return this.#abortErrorReason;
    }
    interceptResolutionState() {
        if (!this.#allowInterception) {
            return { action: HTTPRequest_js_1.InterceptResolutionAction.Disabled };
        }
        if (this.#interceptionHandled) {
            return { action: HTTPRequest_js_1.InterceptResolutionAction.AlreadyHandled };
        }
        return { ...this.#interceptResolutionState };
    }
    isInterceptResolutionHandled() {
        return this.#interceptionHandled;
    }
    enqueueInterceptAction(pendingHandler) {
        this.#interceptHandlers.push(pendingHandler);
    }
    async finalizeInterceptions() {
        await this.#interceptHandlers.reduce((promiseChain, interceptAction) => {
            return promiseChain.then(interceptAction);
        }, Promise.resolve());
        const { action } = this.interceptResolutionState();
        switch (action) {
            case 'abort':
                return await this.#abort(this.#abortErrorReason);
            case 'respond':
                if (this.#responseForRequest === null) {
                    throw new Error('Response is missing for the interception');
                }
                return await this.#respond(this.#responseForRequest);
            case 'continue':
                return await this.#continue(this.#continueRequestOverrides);
        }
    }
    resourceType() {
        return this.#resourceType;
    }
    method() {
        return this.#method;
    }
    postData() {
        return this.#postData;
    }
    headers() {
        return this.#headers;
    }
    response() {
        return this._response;
    }
    frame() {
        return this.#frame;
    }
    isNavigationRequest() {
        return this.#isNavigationRequest;
    }
    initiator() {
        return this.#initiator;
    }
    redirectChain() {
        return this._redirectChain.slice();
    }
    failure() {
        if (!this._failureText) {
            return null;
        }
        return {
            errorText: this._failureText,
        };
    }
    async continue(overrides = {}, priority) {
        // Request interception is not supported for data: urls.
        if (this.#url.startsWith('data:')) {
            return;
        }
        (0, assert_js_1$e.assert)(this.#allowInterception, 'Request Interception is not enabled!');
        (0, assert_js_1$e.assert)(!this.#interceptionHandled, 'Request is already handled!');
        if (priority === undefined) {
            return await this.#continue(overrides);
        }
        this.#continueRequestOverrides = overrides;
        if (this.#interceptResolutionState.priority === undefined ||
            priority > this.#interceptResolutionState.priority) {
            this.#interceptResolutionState = {
                action: HTTPRequest_js_1.InterceptResolutionAction.Continue,
                priority,
            };
            return;
        }
        if (priority === this.#interceptResolutionState.priority) {
            if (this.#interceptResolutionState.action === 'abort' ||
                this.#interceptResolutionState.action === 'respond') {
                return;
            }
            this.#interceptResolutionState.action =
                HTTPRequest_js_1.InterceptResolutionAction.Continue;
        }
        return;
    }
    async #continue(overrides = {}) {
        const { url, method, postData, headers } = overrides;
        this.#interceptionHandled = true;
        const postDataBinaryBase64 = postData
            ? Buffer.from(postData).toString('base64')
            : undefined;
        if (this._interceptionId === undefined) {
            throw new Error('HTTPRequest is missing _interceptionId needed for Fetch.continueRequest');
        }
        await this.#client
            .send('Fetch.continueRequest', {
            requestId: this._interceptionId,
            url,
            method,
            postData: postDataBinaryBase64,
            headers: headers ? (0, HTTPRequest_js_1.headersArray)(headers) : undefined,
        })
            .catch(error => {
            this.#interceptionHandled = false;
            return handleError(error);
        });
    }
    async respond(response, priority) {
        // Mocking responses for dataURL requests is not currently supported.
        if (this.#url.startsWith('data:')) {
            return;
        }
        (0, assert_js_1$e.assert)(this.#allowInterception, 'Request Interception is not enabled!');
        (0, assert_js_1$e.assert)(!this.#interceptionHandled, 'Request is already handled!');
        if (priority === undefined) {
            return await this.#respond(response);
        }
        this.#responseForRequest = response;
        if (this.#interceptResolutionState.priority === undefined ||
            priority > this.#interceptResolutionState.priority) {
            this.#interceptResolutionState = {
                action: HTTPRequest_js_1.InterceptResolutionAction.Respond,
                priority,
            };
            return;
        }
        if (priority === this.#interceptResolutionState.priority) {
            if (this.#interceptResolutionState.action === 'abort') {
                return;
            }
            this.#interceptResolutionState.action = HTTPRequest_js_1.InterceptResolutionAction.Respond;
        }
    }
    async #respond(response) {
        this.#interceptionHandled = true;
        const responseBody = response.body && (0, util_js_1$e.isString)(response.body)
            ? Buffer.from(response.body)
            : response.body || null;
        const responseHeaders = {};
        if (response.headers) {
            for (const header of Object.keys(response.headers)) {
                const value = response.headers[header];
                responseHeaders[header.toLowerCase()] = Array.isArray(value)
                    ? value.map(item => {
                        return String(item);
                    })
                    : String(value);
            }
        }
        if (response.contentType) {
            responseHeaders['content-type'] = response.contentType;
        }
        if (responseBody && !('content-length' in responseHeaders)) {
            responseHeaders['content-length'] = String(Buffer.byteLength(responseBody));
        }
        const status = response.status || 200;
        if (this._interceptionId === undefined) {
            throw new Error('HTTPRequest is missing _interceptionId needed for Fetch.fulfillRequest');
        }
        await this.#client
            .send('Fetch.fulfillRequest', {
            requestId: this._interceptionId,
            responseCode: status,
            responsePhrase: HTTPRequest_js_1.STATUS_TEXTS[status],
            responseHeaders: (0, HTTPRequest_js_1.headersArray)(responseHeaders),
            body: responseBody ? responseBody.toString('base64') : undefined,
        })
            .catch(error => {
            this.#interceptionHandled = false;
            return handleError(error);
        });
    }
    async abort(errorCode = 'failed', priority) {
        // Request interception is not supported for data: urls.
        if (this.#url.startsWith('data:')) {
            return;
        }
        const errorReason = errorReasons[errorCode];
        (0, assert_js_1$e.assert)(errorReason, 'Unknown error code: ' + errorCode);
        (0, assert_js_1$e.assert)(this.#allowInterception, 'Request Interception is not enabled!');
        (0, assert_js_1$e.assert)(!this.#interceptionHandled, 'Request is already handled!');
        if (priority === undefined) {
            return await this.#abort(errorReason);
        }
        this.#abortErrorReason = errorReason;
        if (this.#interceptResolutionState.priority === undefined ||
            priority >= this.#interceptResolutionState.priority) {
            this.#interceptResolutionState = {
                action: HTTPRequest_js_1.InterceptResolutionAction.Abort,
                priority,
            };
            return;
        }
    }
    async #abort(errorReason) {
        this.#interceptionHandled = true;
        if (this._interceptionId === undefined) {
            throw new Error('HTTPRequest is missing _interceptionId needed for Fetch.failRequest');
        }
        await this.#client
            .send('Fetch.failRequest', {
            requestId: this._interceptionId,
            errorReason: errorReason || 'Failed',
        })
            .catch(handleError);
    }
};
HTTPRequest$2.HTTPRequest = HTTPRequest$1;
const errorReasons = {
    aborted: 'Aborted',
    accessdenied: 'AccessDenied',
    addressunreachable: 'AddressUnreachable',
    blockedbyclient: 'BlockedByClient',
    blockedbyresponse: 'BlockedByResponse',
    connectionaborted: 'ConnectionAborted',
    connectionclosed: 'ConnectionClosed',
    connectionfailed: 'ConnectionFailed',
    connectionrefused: 'ConnectionRefused',
    connectionreset: 'ConnectionReset',
    internetdisconnected: 'InternetDisconnected',
    namenotresolved: 'NameNotResolved',
    timedout: 'TimedOut',
    failed: 'Failed',
};
async function handleError(error) {
    if (['Invalid header'].includes(error.originalMessage)) {
        throw error;
    }
    // In certain cases, protocol will return error if the request was
    // already canceled or the page was closed. We should tolerate these
    // errors.
    (0, util_js_1$e.debugError)(error);
}

var HTTPResponse$2 = {};

var SecurityDetails$1 = {};

/**
 * Copyright 2020 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(SecurityDetails$1, "__esModule", { value: true });
SecurityDetails$1.SecurityDetails = void 0;
/**
 * The SecurityDetails class represents the security details of a
 * response that was received over a secure connection.
 *
 * @public
 */
class SecurityDetails {
    #subjectName;
    #issuer;
    #validFrom;
    #validTo;
    #protocol;
    #sanList;
    /**
     * @internal
     */
    constructor(securityPayload) {
        this.#subjectName = securityPayload.subjectName;
        this.#issuer = securityPayload.issuer;
        this.#validFrom = securityPayload.validFrom;
        this.#validTo = securityPayload.validTo;
        this.#protocol = securityPayload.protocol;
        this.#sanList = securityPayload.sanList;
    }
    /**
     * The name of the issuer of the certificate.
     */
    issuer() {
        return this.#issuer;
    }
    /**
     * {@link https://en.wikipedia.org/wiki/Unix_time | Unix timestamp}
     * marking the start of the certificate's validity.
     */
    validFrom() {
        return this.#validFrom;
    }
    /**
     * {@link https://en.wikipedia.org/wiki/Unix_time | Unix timestamp}
     * marking the end of the certificate's validity.
     */
    validTo() {
        return this.#validTo;
    }
    /**
     * The security protocol being used, e.g. "TLS 1.2".
     */
    protocol() {
        return this.#protocol;
    }
    /**
     * The name of the subject to which the certificate was issued.
     */
    subjectName() {
        return this.#subjectName;
    }
    /**
     * The list of {@link https://en.wikipedia.org/wiki/Subject_Alternative_Name | subject alternative names (SANs)} of the certificate.
     */
    subjectAlternativeNames() {
        return this.#sanList;
    }
}
SecurityDetails$1.SecurityDetails = SecurityDetails;

Object.defineProperty(HTTPResponse$2, "__esModule", { value: true });
HTTPResponse$2.HTTPResponse = void 0;
const HTTPResponse_js_1 = HTTPResponse$4;
const Deferred_js_1$9 = Deferred$1;
const Errors_js_1$3 = Errors;
const SecurityDetails_js_1 = SecurityDetails$1;
/**
 * @internal
 */
let HTTPResponse$1 = class HTTPResponse extends HTTPResponse_js_1.HTTPResponse {
    #client;
    #request;
    #contentPromise = null;
    #bodyLoadedDeferred = Deferred_js_1$9.Deferred.create();
    #remoteAddress;
    #status;
    #statusText;
    #url;
    #fromDiskCache;
    #fromServiceWorker;
    #headers = {};
    #securityDetails;
    #timing;
    constructor(client, request, responsePayload, extraInfo) {
        super();
        this.#client = client;
        this.#request = request;
        this.#remoteAddress = {
            ip: responsePayload.remoteIPAddress,
            port: responsePayload.remotePort,
        };
        this.#statusText =
            this.#parseStatusTextFromExtrInfo(extraInfo) ||
                responsePayload.statusText;
        this.#url = request.url();
        this.#fromDiskCache = !!responsePayload.fromDiskCache;
        this.#fromServiceWorker = !!responsePayload.fromServiceWorker;
        this.#status = extraInfo ? extraInfo.statusCode : responsePayload.status;
        const headers = extraInfo ? extraInfo.headers : responsePayload.headers;
        for (const [key, value] of Object.entries(headers)) {
            this.#headers[key.toLowerCase()] = value;
        }
        this.#securityDetails = responsePayload.securityDetails
            ? new SecurityDetails_js_1.SecurityDetails(responsePayload.securityDetails)
            : null;
        this.#timing = responsePayload.timing || null;
    }
    #parseStatusTextFromExtrInfo(extraInfo) {
        if (!extraInfo || !extraInfo.headersText) {
            return;
        }
        const firstLine = extraInfo.headersText.split('\r', 1)[0];
        if (!firstLine) {
            return;
        }
        const match = firstLine.match(/[^ ]* [^ ]* (.*)/);
        if (!match) {
            return;
        }
        const statusText = match[1];
        if (!statusText) {
            return;
        }
        return statusText;
    }
    _resolveBody(err) {
        if (err) {
            return this.#bodyLoadedDeferred.resolve(err);
        }
        return this.#bodyLoadedDeferred.resolve();
    }
    remoteAddress() {
        return this.#remoteAddress;
    }
    url() {
        return this.#url;
    }
    status() {
        return this.#status;
    }
    statusText() {
        return this.#statusText;
    }
    headers() {
        return this.#headers;
    }
    securityDetails() {
        return this.#securityDetails;
    }
    timing() {
        return this.#timing;
    }
    buffer() {
        if (!this.#contentPromise) {
            this.#contentPromise = this.#bodyLoadedDeferred
                .valueOrThrow()
                .then(async (error) => {
                if (error) {
                    throw error;
                }
                try {
                    const response = await this.#client.send('Network.getResponseBody', {
                        requestId: this.#request._requestId,
                    });
                    return Buffer.from(response.body, response.base64Encoded ? 'base64' : 'utf8');
                }
                catch (error) {
                    if (error instanceof Errors_js_1$3.ProtocolError &&
                        error.originalMessage ===
                            'No resource with given identifier found') {
                        throw new Errors_js_1$3.ProtocolError('Could not load body for this request. This might happen if the request is a preflight request.');
                    }
                    throw error;
                }
            });
        }
        return this.#contentPromise;
    }
    request() {
        return this.#request;
    }
    fromCache() {
        return this.#fromDiskCache || this.#request._fromMemoryCache;
    }
    fromServiceWorker() {
        return this.#fromServiceWorker;
    }
    frame() {
        return this.#request.frame();
    }
};
HTTPResponse$2.HTTPResponse = HTTPResponse$1;

var NetworkEventManager$1 = {};

/**
 * Copyright 2022 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(NetworkEventManager$1, "__esModule", { value: true });
NetworkEventManager$1.NetworkEventManager = void 0;
/**
 * Helper class to track network events by request ID
 *
 * @internal
 */
class NetworkEventManager {
    /**
     * There are four possible orders of events:
     * A. `_onRequestWillBeSent`
     * B. `_onRequestWillBeSent`, `_onRequestPaused`
     * C. `_onRequestPaused`, `_onRequestWillBeSent`
     * D. `_onRequestPaused`, `_onRequestWillBeSent`, `_onRequestPaused`,
     * `_onRequestWillBeSent`, `_onRequestPaused`, `_onRequestPaused`
     * (see crbug.com/1196004)
     *
     * For `_onRequest` we need the event from `_onRequestWillBeSent` and
     * optionally the `interceptionId` from `_onRequestPaused`.
     *
     * If request interception is disabled, call `_onRequest` once per call to
     * `_onRequestWillBeSent`.
     * If request interception is enabled, call `_onRequest` once per call to
     * `_onRequestPaused` (once per `interceptionId`).
     *
     * Events are stored to allow for subsequent events to call `_onRequest`.
     *
     * Note that (chains of) redirect requests have the same `requestId` (!) as
     * the original request. We have to anticipate series of events like these:
     * A. `_onRequestWillBeSent`,
     * `_onRequestWillBeSent`, ...
     * B. `_onRequestWillBeSent`, `_onRequestPaused`,
     * `_onRequestWillBeSent`, `_onRequestPaused`, ...
     * C. `_onRequestWillBeSent`, `_onRequestPaused`,
     * `_onRequestPaused`, `_onRequestWillBeSent`, ...
     * D. `_onRequestPaused`, `_onRequestWillBeSent`,
     * `_onRequestPaused`, `_onRequestWillBeSent`, `_onRequestPaused`,
     * `_onRequestWillBeSent`, `_onRequestPaused`, `_onRequestPaused`, ...
     * (see crbug.com/1196004)
     */
    #requestWillBeSentMap = new Map();
    #requestPausedMap = new Map();
    #httpRequestsMap = new Map();
    /*
     * The below maps are used to reconcile Network.responseReceivedExtraInfo
     * events with their corresponding request. Each response and redirect
     * response gets an ExtraInfo event, and we don't know which will come first.
     * This means that we have to store a Response or an ExtraInfo for each
     * response, and emit the event when we get both of them. In addition, to
     * handle redirects, we have to make them Arrays to represent the chain of
     * events.
     */
    #responseReceivedExtraInfoMap = new Map();
    #queuedRedirectInfoMap = new Map();
    #queuedEventGroupMap = new Map();
    forget(networkRequestId) {
        this.#requestWillBeSentMap.delete(networkRequestId);
        this.#requestPausedMap.delete(networkRequestId);
        this.#queuedEventGroupMap.delete(networkRequestId);
        this.#queuedRedirectInfoMap.delete(networkRequestId);
        this.#responseReceivedExtraInfoMap.delete(networkRequestId);
    }
    responseExtraInfo(networkRequestId) {
        if (!this.#responseReceivedExtraInfoMap.has(networkRequestId)) {
            this.#responseReceivedExtraInfoMap.set(networkRequestId, []);
        }
        return this.#responseReceivedExtraInfoMap.get(networkRequestId);
    }
    queuedRedirectInfo(fetchRequestId) {
        if (!this.#queuedRedirectInfoMap.has(fetchRequestId)) {
            this.#queuedRedirectInfoMap.set(fetchRequestId, []);
        }
        return this.#queuedRedirectInfoMap.get(fetchRequestId);
    }
    queueRedirectInfo(fetchRequestId, redirectInfo) {
        this.queuedRedirectInfo(fetchRequestId).push(redirectInfo);
    }
    takeQueuedRedirectInfo(fetchRequestId) {
        return this.queuedRedirectInfo(fetchRequestId).shift();
    }
    inFlightRequestsCount() {
        let inFlightRequestCounter = 0;
        for (const request of this.#httpRequestsMap.values()) {
            if (!request.response()) {
                inFlightRequestCounter++;
            }
        }
        return inFlightRequestCounter;
    }
    storeRequestWillBeSent(networkRequestId, event) {
        this.#requestWillBeSentMap.set(networkRequestId, event);
    }
    getRequestWillBeSent(networkRequestId) {
        return this.#requestWillBeSentMap.get(networkRequestId);
    }
    forgetRequestWillBeSent(networkRequestId) {
        this.#requestWillBeSentMap.delete(networkRequestId);
    }
    getRequestPaused(networkRequestId) {
        return this.#requestPausedMap.get(networkRequestId);
    }
    forgetRequestPaused(networkRequestId) {
        this.#requestPausedMap.delete(networkRequestId);
    }
    storeRequestPaused(networkRequestId, event) {
        this.#requestPausedMap.set(networkRequestId, event);
    }
    getRequest(networkRequestId) {
        return this.#httpRequestsMap.get(networkRequestId);
    }
    storeRequest(networkRequestId, request) {
        this.#httpRequestsMap.set(networkRequestId, request);
    }
    forgetRequest(networkRequestId) {
        this.#httpRequestsMap.delete(networkRequestId);
    }
    getQueuedEventGroup(networkRequestId) {
        return this.#queuedEventGroupMap.get(networkRequestId);
    }
    queueEventGroup(networkRequestId, event) {
        this.#queuedEventGroupMap.set(networkRequestId, event);
    }
    forgetQueuedEventGroup(networkRequestId) {
        this.#queuedEventGroupMap.delete(networkRequestId);
    }
}
NetworkEventManager$1.NetworkEventManager = NetworkEventManager;

(function (exports) {
	/**
	 * Copyright 2017 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.NetworkManager = exports.NetworkManagerEmittedEvents = void 0;
	const assert_js_1 = assert$1;
	const Connection_js_1 = Connection$1;
	const EventEmitter_js_1 = EventEmitter$1;
	const HTTPRequest_js_1 = HTTPRequest$2;
	const HTTPResponse_js_1 = HTTPResponse$2;
	const NetworkEventManager_js_1 = NetworkEventManager$1;
	const util_js_1 = requireUtil();
	/**
	 * We use symbols to prevent any external parties listening to these events.
	 * They are internal to Puppeteer.
	 *
	 * @internal
	 */
	exports.NetworkManagerEmittedEvents = {
	    Request: Symbol('NetworkManager.Request'),
	    RequestServedFromCache: Symbol('NetworkManager.RequestServedFromCache'),
	    Response: Symbol('NetworkManager.Response'),
	    RequestFailed: Symbol('NetworkManager.RequestFailed'),
	    RequestFinished: Symbol('NetworkManager.RequestFinished'),
	};
	/**
	 * @internal
	 */
	class NetworkManager extends EventEmitter_js_1.EventEmitter {
	    #ignoreHTTPSErrors;
	    #frameManager;
	    #networkEventManager = new NetworkEventManager_js_1.NetworkEventManager();
	    #extraHTTPHeaders;
	    #credentials;
	    #attemptedAuthentications = new Set();
	    #userRequestInterceptionEnabled = false;
	    #protocolRequestInterceptionEnabled = false;
	    #userCacheDisabled;
	    #emulatedNetworkConditions;
	    #userAgent;
	    #userAgentMetadata;
	    #handlers = new Map([
	        ['Fetch.requestPaused', this.#onRequestPaused],
	        ['Fetch.authRequired', this.#onAuthRequired],
	        ['Network.requestWillBeSent', this.#onRequestWillBeSent],
	        ['Network.requestServedFromCache', this.#onRequestServedFromCache],
	        ['Network.responseReceived', this.#onResponseReceived],
	        ['Network.loadingFinished', this.#onLoadingFinished],
	        ['Network.loadingFailed', this.#onLoadingFailed],
	        ['Network.responseReceivedExtraInfo', this.#onResponseReceivedExtraInfo],
	    ]);
	    #clients = new Map();
	    constructor(ignoreHTTPSErrors, frameManager) {
	        super();
	        this.#ignoreHTTPSErrors = ignoreHTTPSErrors;
	        this.#frameManager = frameManager;
	    }
	    async addClient(client) {
	        if (this.#clients.has(client)) {
	            return;
	        }
	        const listeners = [];
	        this.#clients.set(client, listeners);
	        for (const [event, handler] of this.#handlers) {
	            listeners.push({
	                event,
	                handler: handler.bind(this, client),
	            });
	            client.on(event, listeners.at(-1).handler);
	        }
	        listeners.push({
	            event: Connection_js_1.CDPSessionEmittedEvents.Disconnected,
	            handler: this.#removeClient.bind(this, client),
	        });
	        client.on(Connection_js_1.CDPSessionEmittedEvents.Disconnected, listeners.at(-1).handler);
	        await Promise.all([
	            this.#ignoreHTTPSErrors
	                ? client.send('Security.setIgnoreCertificateErrors', {
	                    ignore: true,
	                })
	                : null,
	            client.send('Network.enable'),
	            this.#applyExtraHTTPHeaders(client),
	            this.#applyNetworkConditions(client),
	            this.#applyProtocolCacheDisabled(client),
	            this.#applyProtocolRequestInterception(client),
	            this.#applyUserAgent(client),
	        ]);
	    }
	    async #removeClient(client) {
	        const listeners = this.#clients.get(client);
	        for (const { event, handler } of listeners || []) {
	            client.off(event, handler);
	        }
	        this.#clients.delete(client);
	    }
	    async authenticate(credentials) {
	        this.#credentials = credentials;
	        const enabled = this.#userRequestInterceptionEnabled || !!this.#credentials;
	        if (enabled === this.#protocolRequestInterceptionEnabled) {
	            return;
	        }
	        this.#protocolRequestInterceptionEnabled = enabled;
	        await this.#applyToAllClients(this.#applyProtocolRequestInterception.bind(this));
	    }
	    async setExtraHTTPHeaders(extraHTTPHeaders) {
	        this.#extraHTTPHeaders = {};
	        for (const key of Object.keys(extraHTTPHeaders)) {
	            const value = extraHTTPHeaders[key];
	            (0, assert_js_1.assert)((0, util_js_1.isString)(value), `Expected value of header "${key}" to be String, but "${typeof value}" is found.`);
	            this.#extraHTTPHeaders[key.toLowerCase()] = value;
	        }
	        await this.#applyToAllClients(this.#applyExtraHTTPHeaders.bind(this));
	    }
	    async #applyExtraHTTPHeaders(client) {
	        if (this.#extraHTTPHeaders === undefined) {
	            return;
	        }
	        await client.send('Network.setExtraHTTPHeaders', {
	            headers: this.#extraHTTPHeaders,
	        });
	    }
	    extraHTTPHeaders() {
	        return Object.assign({}, this.#extraHTTPHeaders);
	    }
	    inFlightRequestsCount() {
	        return this.#networkEventManager.inFlightRequestsCount();
	    }
	    async setOfflineMode(value) {
	        if (!this.#emulatedNetworkConditions) {
	            this.#emulatedNetworkConditions = {
	                offline: false,
	                upload: -1,
	                download: -1,
	                latency: 0,
	            };
	        }
	        this.#emulatedNetworkConditions.offline = value;
	        await this.#applyToAllClients(this.#applyNetworkConditions.bind(this));
	    }
	    async emulateNetworkConditions(networkConditions) {
	        if (!this.#emulatedNetworkConditions) {
	            this.#emulatedNetworkConditions = {
	                offline: false,
	                upload: -1,
	                download: -1,
	                latency: 0,
	            };
	        }
	        this.#emulatedNetworkConditions.upload = networkConditions
	            ? networkConditions.upload
	            : -1;
	        this.#emulatedNetworkConditions.download = networkConditions
	            ? networkConditions.download
	            : -1;
	        this.#emulatedNetworkConditions.latency = networkConditions
	            ? networkConditions.latency
	            : 0;
	        await this.#applyToAllClients(this.#applyNetworkConditions.bind(this));
	    }
	    async #applyToAllClients(fn) {
	        await Promise.all(Array.from(this.#clients.keys()).map(client => {
	            return fn(client);
	        }));
	    }
	    async #applyNetworkConditions(client) {
	        if (this.#emulatedNetworkConditions === undefined) {
	            return;
	        }
	        await client.send('Network.emulateNetworkConditions', {
	            offline: this.#emulatedNetworkConditions.offline,
	            latency: this.#emulatedNetworkConditions.latency,
	            uploadThroughput: this.#emulatedNetworkConditions.upload,
	            downloadThroughput: this.#emulatedNetworkConditions.download,
	        });
	    }
	    async setUserAgent(userAgent, userAgentMetadata) {
	        this.#userAgent = userAgent;
	        this.#userAgentMetadata = userAgentMetadata;
	        await this.#applyToAllClients(this.#applyUserAgent.bind(this));
	    }
	    async #applyUserAgent(client) {
	        if (this.#userAgent === undefined) {
	            return;
	        }
	        await client.send('Network.setUserAgentOverride', {
	            userAgent: this.#userAgent,
	            userAgentMetadata: this.#userAgentMetadata,
	        });
	    }
	    async setCacheEnabled(enabled) {
	        this.#userCacheDisabled = !enabled;
	        await this.#applyToAllClients(this.#applyProtocolCacheDisabled.bind(this));
	    }
	    async setRequestInterception(value) {
	        this.#userRequestInterceptionEnabled = value;
	        const enabled = this.#userRequestInterceptionEnabled || !!this.#credentials;
	        if (enabled === this.#protocolRequestInterceptionEnabled) {
	            return;
	        }
	        this.#protocolRequestInterceptionEnabled = enabled;
	        await this.#applyToAllClients(this.#applyProtocolRequestInterception.bind(this));
	    }
	    async #applyProtocolRequestInterception(client) {
	        if (this.#userCacheDisabled === undefined) {
	            this.#userCacheDisabled = false;
	        }
	        if (this.#protocolRequestInterceptionEnabled) {
	            await Promise.all([
	                this.#applyProtocolCacheDisabled(client),
	                client.send('Fetch.enable', {
	                    handleAuthRequests: true,
	                    patterns: [{ urlPattern: '*' }],
	                }),
	            ]);
	        }
	        else {
	            await Promise.all([
	                this.#applyProtocolCacheDisabled(client),
	                client.send('Fetch.disable'),
	            ]);
	        }
	    }
	    async #applyProtocolCacheDisabled(client) {
	        if (this.#userCacheDisabled === undefined) {
	            return;
	        }
	        await client.send('Network.setCacheDisabled', {
	            cacheDisabled: this.#userCacheDisabled,
	        });
	    }
	    #onRequestWillBeSent(client, event) {
	        // Request interception doesn't happen for data URLs with Network Service.
	        if (this.#userRequestInterceptionEnabled &&
	            !event.request.url.startsWith('data:')) {
	            const { requestId: networkRequestId } = event;
	            this.#networkEventManager.storeRequestWillBeSent(networkRequestId, event);
	            /**
	             * CDP may have sent a Fetch.requestPaused event already. Check for it.
	             */
	            const requestPausedEvent = this.#networkEventManager.getRequestPaused(networkRequestId);
	            if (requestPausedEvent) {
	                const { requestId: fetchRequestId } = requestPausedEvent;
	                this.#patchRequestEventHeaders(event, requestPausedEvent);
	                this.#onRequest(client, event, fetchRequestId);
	                this.#networkEventManager.forgetRequestPaused(networkRequestId);
	            }
	            return;
	        }
	        this.#onRequest(client, event, undefined);
	    }
	    #onAuthRequired(client, event) {
	        let response = 'Default';
	        if (this.#attemptedAuthentications.has(event.requestId)) {
	            response = 'CancelAuth';
	        }
	        else if (this.#credentials) {
	            response = 'ProvideCredentials';
	            this.#attemptedAuthentications.add(event.requestId);
	        }
	        const { username, password } = this.#credentials || {
	            username: undefined,
	            password: undefined,
	        };
	        client
	            .send('Fetch.continueWithAuth', {
	            requestId: event.requestId,
	            authChallengeResponse: { response, username, password },
	        })
	            .catch(util_js_1.debugError);
	    }
	    /**
	     * CDP may send a Fetch.requestPaused without or before a
	     * Network.requestWillBeSent
	     *
	     * CDP may send multiple Fetch.requestPaused
	     * for the same Network.requestWillBeSent.
	     */
	    #onRequestPaused(client, event) {
	        if (!this.#userRequestInterceptionEnabled &&
	            this.#protocolRequestInterceptionEnabled) {
	            client
	                .send('Fetch.continueRequest', {
	                requestId: event.requestId,
	            })
	                .catch(util_js_1.debugError);
	        }
	        const { networkId: networkRequestId, requestId: fetchRequestId } = event;
	        if (!networkRequestId) {
	            this.#onRequestWithoutNetworkInstrumentation(client, event);
	            return;
	        }
	        const requestWillBeSentEvent = (() => {
	            const requestWillBeSentEvent = this.#networkEventManager.getRequestWillBeSent(networkRequestId);
	            // redirect requests have the same `requestId`,
	            if (requestWillBeSentEvent &&
	                (requestWillBeSentEvent.request.url !== event.request.url ||
	                    requestWillBeSentEvent.request.method !== event.request.method)) {
	                this.#networkEventManager.forgetRequestWillBeSent(networkRequestId);
	                return;
	            }
	            return requestWillBeSentEvent;
	        })();
	        if (requestWillBeSentEvent) {
	            this.#patchRequestEventHeaders(requestWillBeSentEvent, event);
	            this.#onRequest(client, requestWillBeSentEvent, fetchRequestId);
	        }
	        else {
	            this.#networkEventManager.storeRequestPaused(networkRequestId, event);
	        }
	    }
	    #patchRequestEventHeaders(requestWillBeSentEvent, requestPausedEvent) {
	        requestWillBeSentEvent.request.headers = {
	            ...requestWillBeSentEvent.request.headers,
	            // includes extra headers, like: Accept, Origin
	            ...requestPausedEvent.request.headers,
	        };
	    }
	    #onRequestWithoutNetworkInstrumentation(client, event) {
	        // If an event has no networkId it should not have any network events. We
	        // still want to dispatch it for the interception by the user.
	        const frame = event.frameId
	            ? this.#frameManager.frame(event.frameId)
	            : null;
	        const request = new HTTPRequest_js_1.HTTPRequest(client, frame, event.requestId, this.#userRequestInterceptionEnabled, event, []);
	        this.emit(exports.NetworkManagerEmittedEvents.Request, request);
	        void request.finalizeInterceptions();
	    }
	    #onRequest(client, event, fetchRequestId) {
	        let redirectChain = [];
	        if (event.redirectResponse) {
	            // We want to emit a response and requestfinished for the
	            // redirectResponse, but we can't do so unless we have a
	            // responseExtraInfo ready to pair it up with. If we don't have any
	            // responseExtraInfos saved in our queue, they we have to wait until
	            // the next one to emit response and requestfinished, *and* we should
	            // also wait to emit this Request too because it should come after the
	            // response/requestfinished.
	            let redirectResponseExtraInfo = null;
	            if (event.redirectHasExtraInfo) {
	                redirectResponseExtraInfo = this.#networkEventManager
	                    .responseExtraInfo(event.requestId)
	                    .shift();
	                if (!redirectResponseExtraInfo) {
	                    this.#networkEventManager.queueRedirectInfo(event.requestId, {
	                        event,
	                        fetchRequestId,
	                    });
	                    return;
	                }
	            }
	            const request = this.#networkEventManager.getRequest(event.requestId);
	            // If we connect late to the target, we could have missed the
	            // requestWillBeSent event.
	            if (request) {
	                this.#handleRequestRedirect(client, request, event.redirectResponse, redirectResponseExtraInfo);
	                redirectChain = request._redirectChain;
	            }
	        }
	        const frame = event.frameId
	            ? this.#frameManager.frame(event.frameId)
	            : null;
	        const request = new HTTPRequest_js_1.HTTPRequest(client, frame, fetchRequestId, this.#userRequestInterceptionEnabled, event, redirectChain);
	        this.#networkEventManager.storeRequest(event.requestId, request);
	        this.emit(exports.NetworkManagerEmittedEvents.Request, request);
	        void request.finalizeInterceptions();
	    }
	    #onRequestServedFromCache(_client, event) {
	        const request = this.#networkEventManager.getRequest(event.requestId);
	        if (request) {
	            request._fromMemoryCache = true;
	        }
	        this.emit(exports.NetworkManagerEmittedEvents.RequestServedFromCache, request);
	    }
	    #handleRequestRedirect(client, request, responsePayload, extraInfo) {
	        const response = new HTTPResponse_js_1.HTTPResponse(client, request, responsePayload, extraInfo);
	        request._response = response;
	        request._redirectChain.push(request);
	        response._resolveBody(new Error('Response body is unavailable for redirect responses'));
	        this.#forgetRequest(request, false);
	        this.emit(exports.NetworkManagerEmittedEvents.Response, response);
	        this.emit(exports.NetworkManagerEmittedEvents.RequestFinished, request);
	    }
	    #emitResponseEvent(client, responseReceived, extraInfo) {
	        const request = this.#networkEventManager.getRequest(responseReceived.requestId);
	        // FileUpload sends a response without a matching request.
	        if (!request) {
	            return;
	        }
	        const extraInfos = this.#networkEventManager.responseExtraInfo(responseReceived.requestId);
	        if (extraInfos.length) {
	            (0, util_js_1.debugError)(new Error('Unexpected extraInfo events for request ' +
	                responseReceived.requestId));
	        }
	        // Chromium sends wrong extraInfo events for responses served from cache.
	        // See https://github.com/puppeteer/puppeteer/issues/9965 and
	        // https://crbug.com/1340398.
	        if (responseReceived.response.fromDiskCache) {
	            extraInfo = null;
	        }
	        const response = new HTTPResponse_js_1.HTTPResponse(client, request, responseReceived.response, extraInfo);
	        request._response = response;
	        this.emit(exports.NetworkManagerEmittedEvents.Response, response);
	    }
	    #onResponseReceived(client, event) {
	        const request = this.#networkEventManager.getRequest(event.requestId);
	        let extraInfo = null;
	        if (request && !request._fromMemoryCache && event.hasExtraInfo) {
	            extraInfo = this.#networkEventManager
	                .responseExtraInfo(event.requestId)
	                .shift();
	            if (!extraInfo) {
	                // Wait until we get the corresponding ExtraInfo event.
	                this.#networkEventManager.queueEventGroup(event.requestId, {
	                    responseReceivedEvent: event,
	                });
	                return;
	            }
	        }
	        this.#emitResponseEvent(client, event, extraInfo);
	    }
	    #onResponseReceivedExtraInfo(client, event) {
	        // We may have skipped a redirect response/request pair due to waiting for
	        // this ExtraInfo event. If so, continue that work now that we have the
	        // request.
	        const redirectInfo = this.#networkEventManager.takeQueuedRedirectInfo(event.requestId);
	        if (redirectInfo) {
	            this.#networkEventManager.responseExtraInfo(event.requestId).push(event);
	            this.#onRequest(client, redirectInfo.event, redirectInfo.fetchRequestId);
	            return;
	        }
	        // We may have skipped response and loading events because we didn't have
	        // this ExtraInfo event yet. If so, emit those events now.
	        const queuedEvents = this.#networkEventManager.getQueuedEventGroup(event.requestId);
	        if (queuedEvents) {
	            this.#networkEventManager.forgetQueuedEventGroup(event.requestId);
	            this.#emitResponseEvent(client, queuedEvents.responseReceivedEvent, event);
	            if (queuedEvents.loadingFinishedEvent) {
	                this.#emitLoadingFinished(queuedEvents.loadingFinishedEvent);
	            }
	            if (queuedEvents.loadingFailedEvent) {
	                this.#emitLoadingFailed(queuedEvents.loadingFailedEvent);
	            }
	            return;
	        }
	        // Wait until we get another event that can use this ExtraInfo event.
	        this.#networkEventManager.responseExtraInfo(event.requestId).push(event);
	    }
	    #forgetRequest(request, events) {
	        const requestId = request._requestId;
	        const interceptionId = request._interceptionId;
	        this.#networkEventManager.forgetRequest(requestId);
	        interceptionId !== undefined &&
	            this.#attemptedAuthentications.delete(interceptionId);
	        if (events) {
	            this.#networkEventManager.forget(requestId);
	        }
	    }
	    #onLoadingFinished(_client, event) {
	        // If the response event for this request is still waiting on a
	        // corresponding ExtraInfo event, then wait to emit this event too.
	        const queuedEvents = this.#networkEventManager.getQueuedEventGroup(event.requestId);
	        if (queuedEvents) {
	            queuedEvents.loadingFinishedEvent = event;
	        }
	        else {
	            this.#emitLoadingFinished(event);
	        }
	    }
	    #emitLoadingFinished(event) {
	        const request = this.#networkEventManager.getRequest(event.requestId);
	        // For certain requestIds we never receive requestWillBeSent event.
	        // @see https://crbug.com/750469
	        if (!request) {
	            return;
	        }
	        // Under certain conditions we never get the Network.responseReceived
	        // event from protocol. @see https://crbug.com/883475
	        if (request.response()) {
	            request.response()?._resolveBody(null);
	        }
	        this.#forgetRequest(request, true);
	        this.emit(exports.NetworkManagerEmittedEvents.RequestFinished, request);
	    }
	    #onLoadingFailed(_client, event) {
	        // If the response event for this request is still waiting on a
	        // corresponding ExtraInfo event, then wait to emit this event too.
	        const queuedEvents = this.#networkEventManager.getQueuedEventGroup(event.requestId);
	        if (queuedEvents) {
	            queuedEvents.loadingFailedEvent = event;
	        }
	        else {
	            this.#emitLoadingFailed(event);
	        }
	    }
	    #emitLoadingFailed(event) {
	        const request = this.#networkEventManager.getRequest(event.requestId);
	        // For certain requestIds we never receive requestWillBeSent event.
	        // @see https://crbug.com/750469
	        if (!request) {
	            return;
	        }
	        request._failureText = event.errorText;
	        const response = request.response();
	        if (response) {
	            response._resolveBody(null);
	        }
	        this.#forgetRequest(request, true);
	        this.emit(exports.NetworkManagerEmittedEvents.RequestFailed, request);
	    }
	}
	exports.NetworkManager = NetworkManager;
	
} (NetworkManager$1));

var PDFOptions = {};

/**
 * Copyright 2020 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(PDFOptions, "__esModule", { value: true });
PDFOptions.paperFormats = void 0;
/**
 * @internal
 */
PDFOptions.paperFormats = {
    letter: { width: 8.5, height: 11 },
    legal: { width: 8.5, height: 14 },
    tabloid: { width: 11, height: 17 },
    ledger: { width: 17, height: 11 },
    a0: { width: 33.1, height: 46.8 },
    a1: { width: 23.4, height: 33.1 },
    a2: { width: 16.54, height: 23.4 },
    a3: { width: 11.7, height: 16.54 },
    a4: { width: 8.27, height: 11.7 },
    a5: { width: 5.83, height: 8.27 },
    a6: { width: 4.13, height: 5.83 },
};

(function (exports) {
	/**
	 * Copyright 2017 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.unitToPixels = exports.supportedMetrics = exports.Page = void 0;
	const rxjs_js_1 = rxjs;
	const Errors_js_1 = Errors;
	const EventEmitter_js_1 = EventEmitter$1;
	const NetworkManager_js_1 = NetworkManager$1;
	const PDFOptions_js_1 = PDFOptions;
	const util_js_1 = requireUtil();
	const assert_js_1 = assert$1;
	const locators_js_1 = requireLocators();
	/**
	 * Page provides methods to interact with a single tab or
	 * {@link https://developer.chrome.com/extensions/background_pages | extension background page}
	 * in the browser.
	 *
	 * :::note
	 *
	 * One Browser instance might have multiple Page instances.
	 *
	 * :::
	 *
	 * @example
	 * This example creates a page, navigates it to a URL, and then saves a screenshot:
	 *
	 * ```ts
	 * import puppeteer from 'puppeteer';
	 *
	 * (async () => {
	 *   const browser = await puppeteer.launch();
	 *   const page = await browser.newPage();
	 *   await page.goto('https://example.com');
	 *   await page.screenshot({path: 'screenshot.png'});
	 *   await browser.close();
	 * })();
	 * ```
	 *
	 * The Page class extends from Puppeteer's {@link EventEmitter} class and will
	 * emit various events which are documented in the {@link PageEmittedEvents} enum.
	 *
	 * @example
	 * This example logs a message for a single page `load` event:
	 *
	 * ```ts
	 * page.once('load', () => console.log('Page loaded!'));
	 * ```
	 *
	 * To unsubscribe from events use the {@link Page.off} method:
	 *
	 * ```ts
	 * function logRequest(interceptedRequest) {
	 *   console.log('A request was made:', interceptedRequest.url());
	 * }
	 * page.on('request', logRequest);
	 * // Sometime later...
	 * page.off('request', logRequest);
	 * ```
	 *
	 * @public
	 */
	class Page extends EventEmitter_js_1.EventEmitter {
	    #handlerMap = new WeakMap();
	    /**
	     * @internal
	     */
	    constructor() {
	        super();
	    }
	    /**
	     * `true` if the service worker are being bypassed, `false` otherwise.
	     */
	    isServiceWorkerBypassed() {
	        throw new Error('Not implemented');
	    }
	    /**
	     * `true` if drag events are being intercepted, `false` otherwise.
	     */
	    isDragInterceptionEnabled() {
	        throw new Error('Not implemented');
	    }
	    /**
	     * `true` if the page has JavaScript enabled, `false` otherwise.
	     */
	    isJavaScriptEnabled() {
	        throw new Error('Not implemented');
	    }
	    /**
	     * Listen to page events.
	     *
	     * :::note
	     *
	     * This method exists to define event typings and handle proper wireup of
	     * cooperative request interception. Actual event listening and dispatching is
	     * delegated to {@link EventEmitter}.
	     *
	     * :::
	     */
	    on(eventName, handler) {
	        if (eventName === 'request') {
	            const wrap = this.#handlerMap.get(handler) ||
	                ((event) => {
	                    event.enqueueInterceptAction(() => {
	                        return handler(event);
	                    });
	                });
	            this.#handlerMap.set(handler, wrap);
	            return super.on(eventName, wrap);
	        }
	        return super.on(eventName, handler);
	    }
	    once(eventName, handler) {
	        // Note: this method only exists to define the types; we delegate the impl
	        // to EventEmitter.
	        return super.once(eventName, handler);
	    }
	    off(eventName, handler) {
	        if (eventName === 'request') {
	            handler = this.#handlerMap.get(handler) || handler;
	        }
	        return super.off(eventName, handler);
	    }
	    waitForFileChooser() {
	        throw new Error('Not implemented');
	    }
	    async setGeolocation() {
	        throw new Error('Not implemented');
	    }
	    /**
	     * A target this page was created from.
	     */
	    target() {
	        throw new Error('Not implemented');
	    }
	    /**
	     * Get the browser the page belongs to.
	     */
	    browser() {
	        throw new Error('Not implemented');
	    }
	    /**
	     * Get the browser context that the page belongs to.
	     */
	    browserContext() {
	        throw new Error('Not implemented');
	    }
	    /**
	     * The page's main frame.
	     *
	     * @remarks
	     * Page is guaranteed to have a main frame which persists during navigations.
	     */
	    mainFrame() {
	        throw new Error('Not implemented');
	    }
	    /**
	     * Creates a Chrome Devtools Protocol session attached to the page.
	     */
	    createCDPSession() {
	        throw new Error('Not implemented');
	    }
	    /**
	     * {@inheritDoc Keyboard}
	     */
	    get keyboard() {
	        throw new Error('Not implemented');
	    }
	    /**
	     * {@inheritDoc Touchscreen}
	     */
	    get touchscreen() {
	        throw new Error('Not implemented');
	    }
	    /**
	     * {@inheritDoc Coverage}
	     */
	    get coverage() {
	        throw new Error('Not implemented');
	    }
	    /**
	     * {@inheritDoc Tracing}
	     */
	    get tracing() {
	        throw new Error('Not implemented');
	    }
	    /**
	     * {@inheritDoc Accessibility}
	     */
	    get accessibility() {
	        throw new Error('Not implemented');
	    }
	    /**
	     * An array of all frames attached to the page.
	     */
	    frames() {
	        throw new Error('Not implemented');
	    }
	    /**
	     * All of the dedicated {@link
	     * https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API |
	     * WebWorkers} associated with the page.
	     *
	     * @remarks
	     * This does not contain ServiceWorkers
	     */
	    workers() {
	        throw new Error('Not implemented');
	    }
	    async setRequestInterception() {
	        throw new Error('Not implemented');
	    }
	    async setBypassServiceWorker() {
	        throw new Error('Not implemented');
	    }
	    async setDragInterception() {
	        throw new Error('Not implemented');
	    }
	    setOfflineMode() {
	        throw new Error('Not implemented');
	    }
	    emulateNetworkConditions() {
	        throw new Error('Not implemented');
	    }
	    setDefaultNavigationTimeout() {
	        throw new Error('Not implemented');
	    }
	    setDefaultTimeout() {
	        throw new Error('Not implemented');
	    }
	    /**
	     * Maximum time in milliseconds.
	     */
	    getDefaultTimeout() {
	        throw new Error('Not implemented');
	    }
	    locator(selectorOrFunc) {
	        if (typeof selectorOrFunc === 'string') {
	            return locators_js_1.NodeLocator.create(this, selectorOrFunc);
	        }
	        else {
	            return locators_js_1.FunctionLocator.create(this, selectorOrFunc);
	        }
	    }
	    /**
	     * A shortcut for {@link Locator.race} that does not require static imports.
	     *
	     * @internal
	     */
	    locatorRace(locators) {
	        return locators_js_1.Locator.race(locators);
	    }
	    /**
	     * Runs `document.querySelector` within the page. If no element matches the
	     * selector, the return value resolves to `null`.
	     *
	     * @param selector - A `selector` to query page for
	     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}
	     * to query page for.
	     */
	    async $(selector) {
	        return await this.mainFrame().$(selector);
	    }
	    /**
	     * The method runs `document.querySelectorAll` within the page. If no elements
	     * match the selector, the return value resolves to `[]`.
	     * @remarks
	     * Shortcut for {@link Frame.$$ | Page.mainFrame().$$(selector) }.
	     * @param selector - A `selector` to query page for
	     */
	    async $$(selector) {
	        return await this.mainFrame().$$(selector);
	    }
	    /**
	     * @remarks
	     *
	     * The only difference between {@link Page.evaluate | page.evaluate} and
	     * `page.evaluateHandle` is that `evaluateHandle` will return the value
	     * wrapped in an in-page object.
	     *
	     * If the function passed to `page.evaluateHandle` returns a Promise, the
	     * function will wait for the promise to resolve and return its value.
	     *
	     * You can pass a string instead of a function (although functions are
	     * recommended as they are easier to debug and use with TypeScript):
	     *
	     * @example
	     *
	     * ```ts
	     * const aHandle = await page.evaluateHandle('document');
	     * ```
	     *
	     * @example
	     * {@link JSHandle} instances can be passed as arguments to the `pageFunction`:
	     *
	     * ```ts
	     * const aHandle = await page.evaluateHandle(() => document.body);
	     * const resultHandle = await page.evaluateHandle(
	     *   body => body.innerHTML,
	     *   aHandle
	     * );
	     * console.log(await resultHandle.jsonValue());
	     * await resultHandle.dispose();
	     * ```
	     *
	     * Most of the time this function returns a {@link JSHandle},
	     * but if `pageFunction` returns a reference to an element,
	     * you instead get an {@link ElementHandle} back:
	     *
	     * @example
	     *
	     * ```ts
	     * const button = await page.evaluateHandle(() =>
	     *   document.querySelector('button')
	     * );
	     * // can call `click` because `button` is an `ElementHandle`
	     * await button.click();
	     * ```
	     *
	     * The TypeScript definitions assume that `evaluateHandle` returns
	     * a `JSHandle`, but if you know it's going to return an
	     * `ElementHandle`, pass it as the generic argument:
	     *
	     * ```ts
	     * const button = await page.evaluateHandle<ElementHandle>(...);
	     * ```
	     *
	     * @param pageFunction - a function that is run within the page
	     * @param args - arguments to be passed to the pageFunction
	     */
	    async evaluateHandle(pageFunction, ...args) {
	        pageFunction = (0, util_js_1.withSourcePuppeteerURLIfNone)(this.evaluateHandle.name, pageFunction);
	        return await this.mainFrame().evaluateHandle(pageFunction, ...args);
	    }
	    async queryObjects() {
	        throw new Error('Not implemented');
	    }
	    /**
	     * This method runs `document.querySelector` within the page and passes the
	     * result as the first argument to the `pageFunction`.
	     *
	     * @remarks
	     *
	     * If no element is found matching `selector`, the method will throw an error.
	     *
	     * If `pageFunction` returns a promise `$eval` will wait for the promise to
	     * resolve and then return its value.
	     *
	     * @example
	     *
	     * ```ts
	     * const searchValue = await page.$eval('#search', el => el.value);
	     * const preloadHref = await page.$eval('link[rel=preload]', el => el.href);
	     * const html = await page.$eval('.main-container', el => el.outerHTML);
	     * ```
	     *
	     * If you are using TypeScript, you may have to provide an explicit type to the
	     * first argument of the `pageFunction`.
	     * By default it is typed as `Element`, but you may need to provide a more
	     * specific sub-type:
	     *
	     * @example
	     *
	     * ```ts
	     * // if you don't provide HTMLInputElement here, TS will error
	     * // as `value` is not on `Element`
	     * const searchValue = await page.$eval(
	     *   '#search',
	     *   (el: HTMLInputElement) => el.value
	     * );
	     * ```
	     *
	     * The compiler should be able to infer the return type
	     * from the `pageFunction` you provide. If it is unable to, you can use the generic
	     * type to tell the compiler what return type you expect from `$eval`:
	     *
	     * @example
	     *
	     * ```ts
	     * // The compiler can infer the return type in this case, but if it can't
	     * // or if you want to be more explicit, provide it as the generic type.
	     * const searchValue = await page.$eval<string>(
	     *   '#search',
	     *   (el: HTMLInputElement) => el.value
	     * );
	     * ```
	     *
	     * @param selector - the
	     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}
	     * to query for
	     * @param pageFunction - the function to be evaluated in the page context.
	     * Will be passed the result of `document.querySelector(selector)` as its
	     * first argument.
	     * @param args - any additional arguments to pass through to `pageFunction`.
	     *
	     * @returns The result of calling `pageFunction`. If it returns an element it
	     * is wrapped in an {@link ElementHandle}, else the raw value itself is
	     * returned.
	     */
	    async $eval(selector, pageFunction, ...args) {
	        pageFunction = (0, util_js_1.withSourcePuppeteerURLIfNone)(this.$eval.name, pageFunction);
	        return await this.mainFrame().$eval(selector, pageFunction, ...args);
	    }
	    /**
	     * This method runs `Array.from(document.querySelectorAll(selector))` within
	     * the page and passes the result as the first argument to the `pageFunction`.
	     *
	     * @remarks
	     * If `pageFunction` returns a promise `$$eval` will wait for the promise to
	     * resolve and then return its value.
	     *
	     * @example
	     *
	     * ```ts
	     * // get the amount of divs on the page
	     * const divCount = await page.$$eval('div', divs => divs.length);
	     *
	     * // get the text content of all the `.options` elements:
	     * const options = await page.$$eval('div > span.options', options => {
	     *   return options.map(option => option.textContent);
	     * });
	     * ```
	     *
	     * If you are using TypeScript, you may have to provide an explicit type to the
	     * first argument of the `pageFunction`.
	     * By default it is typed as `Element[]`, but you may need to provide a more
	     * specific sub-type:
	     *
	     * @example
	     *
	     * ```ts
	     * // if you don't provide HTMLInputElement here, TS will error
	     * // as `value` is not on `Element`
	     * await page.$$eval('input', (elements: HTMLInputElement[]) => {
	     *   return elements.map(e => e.value);
	     * });
	     * ```
	     *
	     * The compiler should be able to infer the return type
	     * from the `pageFunction` you provide. If it is unable to, you can use the generic
	     * type to tell the compiler what return type you expect from `$$eval`:
	     *
	     * @example
	     *
	     * ```ts
	     * // The compiler can infer the return type in this case, but if it can't
	     * // or if you want to be more explicit, provide it as the generic type.
	     * const allInputValues = await page.$$eval<string[]>(
	     *   'input',
	     *   (elements: HTMLInputElement[]) => elements.map(e => e.textContent)
	     * );
	     * ```
	     *
	     * @param selector - the
	     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}
	     * to query for
	     * @param pageFunction - the function to be evaluated in the page context.
	     * Will be passed the result of
	     * `Array.from(document.querySelectorAll(selector))` as its first argument.
	     * @param args - any additional arguments to pass through to `pageFunction`.
	     *
	     * @returns The result of calling `pageFunction`. If it returns an element it
	     * is wrapped in an {@link ElementHandle}, else the raw value itself is
	     * returned.
	     */
	    async $$eval(selector, pageFunction, ...args) {
	        pageFunction = (0, util_js_1.withSourcePuppeteerURLIfNone)(this.$$eval.name, pageFunction);
	        return await this.mainFrame().$$eval(selector, pageFunction, ...args);
	    }
	    /**
	     * The method evaluates the XPath expression relative to the page document as
	     * its context node. If there are no such elements, the method resolves to an
	     * empty array.
	     *
	     * @remarks
	     * Shortcut for {@link Frame.$x | Page.mainFrame().$x(expression) }.
	     *
	     * @param expression - Expression to evaluate
	     */
	    async $x(expression) {
	        return await this.mainFrame().$x(expression);
	    }
	    async cookies() {
	        throw new Error('Not implemented');
	    }
	    async deleteCookie() {
	        throw new Error('Not implemented');
	    }
	    async setCookie() {
	        throw new Error('Not implemented');
	    }
	    /**
	     * Adds a `<script>` tag into the page with the desired URL or content.
	     *
	     * @remarks
	     * Shortcut for
	     * {@link Frame.addScriptTag | page.mainFrame().addScriptTag(options)}.
	     *
	     * @param options - Options for the script.
	     * @returns An {@link ElementHandle | element handle} to the injected
	     * `<script>` element.
	     */
	    async addScriptTag(options) {
	        return await this.mainFrame().addScriptTag(options);
	    }
	    async addStyleTag(options) {
	        return await this.mainFrame().addStyleTag(options);
	    }
	    async removeExposedFunction() {
	        throw new Error('Not implemented');
	    }
	    async authenticate() {
	        throw new Error('Not implemented');
	    }
	    async setExtraHTTPHeaders() {
	        throw new Error('Not implemented');
	    }
	    async setUserAgent() {
	        throw new Error('Not implemented');
	    }
	    /**
	     * Object containing metrics as key/value pairs.
	     *
	     * @returns
	     *
	     * - `Timestamp` : The timestamp when the metrics sample was taken.
	     *
	     * - `Documents` : Number of documents in the page.
	     *
	     * - `Frames` : Number of frames in the page.
	     *
	     * - `JSEventListeners` : Number of events in the page.
	     *
	     * - `Nodes` : Number of DOM nodes in the page.
	     *
	     * - `LayoutCount` : Total number of full or partial page layout.
	     *
	     * - `RecalcStyleCount` : Total number of page style recalculations.
	     *
	     * - `LayoutDuration` : Combined durations of all page layouts.
	     *
	     * - `RecalcStyleDuration` : Combined duration of all page style
	     *   recalculations.
	     *
	     * - `ScriptDuration` : Combined duration of JavaScript execution.
	     *
	     * - `TaskDuration` : Combined duration of all tasks performed by the browser.
	     *
	     * - `JSHeapUsedSize` : Used JavaScript heap size.
	     *
	     * - `JSHeapTotalSize` : Total JavaScript heap size.
	     *
	     * @remarks
	     * All timestamps are in monotonic time: monotonically increasing time
	     * in seconds since an arbitrary point in the past.
	     */
	    async metrics() {
	        throw new Error('Not implemented');
	    }
	    /**
	     * The page's URL.
	     * @remarks Shortcut for
	     * {@link Frame.url | page.mainFrame().url()}.
	     */
	    url() {
	        return this.mainFrame().url();
	    }
	    /**
	     * The full HTML contents of the page, including the DOCTYPE.
	     */
	    async content() {
	        return await this.mainFrame().content();
	    }
	    /**
	     * Set the content of the page.
	     *
	     * @param html - HTML markup to assign to the page.
	     * @param options - Parameters that has some properties.
	     * @remarks
	     * The parameter `options` might have the following options.
	     *
	     * - `timeout` : Maximum time in milliseconds for resources to load, defaults
	     *   to 30 seconds, pass `0` to disable timeout. The default value can be
	     *   changed by using the {@link Page.setDefaultNavigationTimeout} or
	     *   {@link Page.setDefaultTimeout} methods.
	     *
	     * - `waitUntil`: When to consider setting markup succeeded, defaults to
	     *   `load`. Given an array of event strings, setting content is considered
	     *   to be successful after all events have been fired. Events can be
	     *   either:<br/>
	     * - `load` : consider setting content to be finished when the `load` event
	     *   is fired.<br/>
	     * - `domcontentloaded` : consider setting content to be finished when the
	     *   `DOMContentLoaded` event is fired.<br/>
	     * - `networkidle0` : consider setting content to be finished when there are
	     *   no more than 0 network connections for at least `500` ms.<br/>
	     * - `networkidle2` : consider setting content to be finished when there are
	     *   no more than 2 network connections for at least `500` ms.
	     */
	    async setContent(html, options) {
	        await this.mainFrame().setContent(html, options);
	    }
	    /**
	     * @param url - URL to navigate page to. The URL should include scheme, e.g.
	     * `https://`
	     * @param options - Navigation Parameter
	     * @returns Promise which resolves to the main resource response. In case of
	     * multiple redirects, the navigation will resolve with the response of the
	     * last redirect.
	     * @remarks
	     * The argument `options` might have the following properties:
	     *
	     * - `timeout` : Maximum navigation time in milliseconds, defaults to 30
	     *   seconds, pass 0 to disable timeout. The default value can be changed by
	     *   using the {@link Page.setDefaultNavigationTimeout} or
	     *   {@link Page.setDefaultTimeout} methods.
	     *
	     * - `waitUntil`:When to consider navigation succeeded, defaults to `load`.
	     *   Given an array of event strings, navigation is considered to be
	     *   successful after all events have been fired. Events can be either:<br/>
	     * - `load` : consider navigation to be finished when the load event is
	     *   fired.<br/>
	     * - `domcontentloaded` : consider navigation to be finished when the
	     *   DOMContentLoaded event is fired.<br/>
	     * - `networkidle0` : consider navigation to be finished when there are no
	     *   more than 0 network connections for at least `500` ms.<br/>
	     * - `networkidle2` : consider navigation to be finished when there are no
	     *   more than 2 network connections for at least `500` ms.
	     *
	     * - `referer` : Referer header value. If provided it will take preference
	     *   over the referer header value set by
	     *   {@link Page.setExtraHTTPHeaders |page.setExtraHTTPHeaders()}.<br/>
	     * - `referrerPolicy` : ReferrerPolicy. If provided it will take preference
	     *   over the referer-policy header value set by
	     *   {@link Page.setExtraHTTPHeaders |page.setExtraHTTPHeaders()}.
	     *
	     * `page.goto` will throw an error if:
	     *
	     * - there's an SSL error (e.g. in case of self-signed certificates).
	     * - target URL is invalid.
	     * - the timeout is exceeded during navigation.
	     * - the remote server does not respond or is unreachable.
	     * - the main resource failed to load.
	     *
	     * `page.goto` will not throw an error when any valid HTTP status code is
	     * returned by the remote server, including 404 "Not Found" and 500
	     * "Internal Server Error". The status code for such responses can be
	     * retrieved by calling response.status().
	     *
	     * NOTE: `page.goto` either throws an error or returns a main resource
	     * response. The only exceptions are navigation to about:blank or navigation
	     * to the same URL with a different hash, which would succeed and return null.
	     *
	     * NOTE: Headless mode doesn't support navigation to a PDF document. See the
	     * {@link https://bugs.chromium.org/p/chromium/issues/detail?id=761295 |
	     * upstream issue}.
	     *
	     * Shortcut for {@link Frame.goto | page.mainFrame().goto(url, options)}.
	     */
	    async goto(url, options) {
	        return await this.mainFrame().goto(url, options);
	    }
	    async reload() {
	        throw new Error('Not implemented');
	    }
	    /**
	     * Waits for the page to navigate to a new URL or to reload. It is useful when
	     * you run code that will indirectly cause the page to navigate.
	     *
	     * @example
	     *
	     * ```ts
	     * const [response] = await Promise.all([
	     *   page.waitForNavigation(), // The promise resolves after navigation has finished
	     *   page.click('a.my-link'), // Clicking the link will indirectly cause a navigation
	     * ]);
	     * ```
	     *
	     * @remarks
	     * Usage of the
	     * {@link https://developer.mozilla.org/en-US/docs/Web/API/History_API | History API}
	     * to change the URL is considered a navigation.
	     *
	     * @param options - Navigation parameters which might have the following
	     * properties:
	     * @returns A `Promise` which resolves to the main resource response.
	     *
	     * - In case of multiple redirects, the navigation will resolve with the
	     *   response of the last redirect.
	     * - In case of navigation to a different anchor or navigation due to History
	     *   API usage, the navigation will resolve with `null`.
	     */
	    async waitForNavigation(options = {}) {
	        return await this.mainFrame().waitForNavigation(options);
	    }
	    async waitForRequest() {
	        throw new Error('Not implemented');
	    }
	    async waitForResponse() {
	        throw new Error('Not implemented');
	    }
	    async waitForNetworkIdle() {
	        throw new Error('Not implemented');
	    }
	    /**
	     * @internal
	     */
	    async _waitForNetworkIdle(networkManager, idleTime, ms, closedDeferred) {
	        await (0, rxjs_js_1.firstValueFrom)((0, rxjs_js_1.merge)((0, rxjs_js_1.fromEvent)(networkManager, NetworkManager_js_1.NetworkManagerEmittedEvents.Request), (0, rxjs_js_1.fromEvent)(networkManager, NetworkManager_js_1.NetworkManagerEmittedEvents.Response), (0, rxjs_js_1.fromEvent)(networkManager, NetworkManager_js_1.NetworkManagerEmittedEvents.RequestFailed)).pipe((0, rxjs_js_1.startWith)(null), (0, rxjs_js_1.filter)(() => {
	            return networkManager.inFlightRequestsCount() === 0;
	        }), (0, rxjs_js_1.switchMap)(v => {
	            return (0, rxjs_js_1.of)(v).pipe((0, rxjs_js_1.delay)(idleTime));
	        }), (0, rxjs_js_1.raceWith)((0, util_js_1.timeout)(ms), (0, rxjs_js_1.from)(closedDeferred.valueOrThrow()))));
	    }
	    /**
	     * Waits for a frame matching the given conditions to appear.
	     *
	     * @example
	     *
	     * ```ts
	     * const frame = await page.waitForFrame(async frame => {
	     *   return frame.name() === 'Test';
	     * });
	     * ```
	     */
	    async waitForFrame(urlOrPredicate, options = {}) {
	        const { timeout: ms = this.getDefaultTimeout() } = options;
	        if ((0, util_js_1.isString)(urlOrPredicate)) {
	            urlOrPredicate = (frame) => {
	                return urlOrPredicate === frame.url();
	            };
	        }
	        return await (0, rxjs_js_1.firstValueFrom)((0, rxjs_js_1.merge)((0, rxjs_js_1.fromEvent)(this, "frameattached" /* PageEmittedEvents.FrameAttached */), (0, rxjs_js_1.fromEvent)(this, "framenavigated" /* PageEmittedEvents.FrameNavigated */), (0, rxjs_js_1.from)(this.frames())).pipe((0, rxjs_js_1.filterAsync)(urlOrPredicate), (0, rxjs_js_1.first)(), (0, rxjs_js_1.raceWith)((0, util_js_1.timeout)(ms), (0, rxjs_js_1.fromEvent)(this, "close" /* PageEmittedEvents.Close */).pipe((0, rxjs_js_1.map)(() => {
	            throw new Errors_js_1.TargetCloseError('Page closed.');
	        })))));
	    }
	    async goBack() {
	        throw new Error('Not implemented');
	    }
	    async goForward() {
	        throw new Error('Not implemented');
	    }
	    /**
	     * Brings page to front (activates tab).
	     */
	    async bringToFront() {
	        throw new Error('Not implemented');
	    }
	    /**
	     * Emulates a given device's metrics and user agent.
	     *
	     * To aid emulation, Puppeteer provides a list of known devices that can be
	     * via {@link KnownDevices}.
	     *
	     * @remarks
	     * This method is a shortcut for calling two methods:
	     * {@link Page.setUserAgent} and {@link Page.setViewport}.
	     *
	     * @remarks
	     * This method will resize the page. A lot of websites don't expect phones to
	     * change size, so you should emulate before navigating to the page.
	     *
	     * @example
	     *
	     * ```ts
	     * import {KnownDevices} from 'puppeteer';
	     * const iPhone = KnownDevices['iPhone 6'];
	     *
	     * (async () => {
	     *   const browser = await puppeteer.launch();
	     *   const page = await browser.newPage();
	     *   await page.emulate(iPhone);
	     *   await page.goto('https://www.google.com');
	     *   // other actions...
	     *   await browser.close();
	     * })();
	     * ```
	     */
	    async emulate(device) {
	        await Promise.all([
	            this.setUserAgent(device.userAgent),
	            this.setViewport(device.viewport),
	        ]);
	    }
	    async setJavaScriptEnabled() {
	        throw new Error('Not implemented');
	    }
	    async setBypassCSP() {
	        throw new Error('Not implemented');
	    }
	    async emulateMediaType() {
	        throw new Error('Not implemented');
	    }
	    async emulateCPUThrottling() {
	        throw new Error('Not implemented');
	    }
	    async emulateMediaFeatures() {
	        throw new Error('Not implemented');
	    }
	    async emulateTimezone() {
	        throw new Error('Not implemented');
	    }
	    async emulateIdleState() {
	        throw new Error('Not implemented');
	    }
	    async emulateVisionDeficiency() {
	        throw new Error('Not implemented');
	    }
	    async setViewport() {
	        throw new Error('Not implemented');
	    }
	    /**
	     * Current page viewport settings.
	     *
	     * @returns
	     *
	     * - `width`: page's width in pixels
	     *
	     * - `height`: page's height in pixels
	     *
	     * - `deviceScaleFactor`: Specify device scale factor (can be though of as
	     *   dpr). Defaults to `1`.
	     *
	     * - `isMobile`: Whether the meta viewport tag is taken into account. Defaults
	     *   to `false`.
	     *
	     * - `hasTouch`: Specifies if viewport supports touch events. Defaults to
	     *   `false`.
	     *
	     * - `isLandScape`: Specifies if viewport is in landscape mode. Defaults to
	     *   `false`.
	     */
	    viewport() {
	        throw new Error('Not implemented');
	    }
	    /**
	     * Evaluates a function in the page's context and returns the result.
	     *
	     * If the function passed to `page.evaluate` returns a Promise, the
	     * function will wait for the promise to resolve and return its value.
	     *
	     * @example
	     *
	     * ```ts
	     * const result = await frame.evaluate(() => {
	     *   return Promise.resolve(8 * 7);
	     * });
	     * console.log(result); // prints "56"
	     * ```
	     *
	     * You can pass a string instead of a function (although functions are
	     * recommended as they are easier to debug and use with TypeScript):
	     *
	     * @example
	     *
	     * ```ts
	     * const aHandle = await page.evaluate('1 + 2');
	     * ```
	     *
	     * To get the best TypeScript experience, you should pass in as the
	     * generic the type of `pageFunction`:
	     *
	     * ```ts
	     * const aHandle = await page.evaluate(() => 2);
	     * ```
	     *
	     * @example
	     *
	     * {@link ElementHandle} instances (including {@link JSHandle}s) can be passed
	     * as arguments to the `pageFunction`:
	     *
	     * ```ts
	     * const bodyHandle = await page.$('body');
	     * const html = await page.evaluate(body => body.innerHTML, bodyHandle);
	     * await bodyHandle.dispose();
	     * ```
	     *
	     * @param pageFunction - a function that is run within the page
	     * @param args - arguments to be passed to the pageFunction
	     *
	     * @returns the return value of `pageFunction`.
	     */
	    async evaluate(pageFunction, ...args) {
	        pageFunction = (0, util_js_1.withSourcePuppeteerURLIfNone)(this.evaluate.name, pageFunction);
	        return await this.mainFrame().evaluate(pageFunction, ...args);
	    }
	    async evaluateOnNewDocument() {
	        throw new Error('Not implemented');
	    }
	    async removeScriptToEvaluateOnNewDocument() {
	        throw new Error('Not implemented');
	    }
	    async setCacheEnabled() {
	        throw new Error('Not implemented');
	    }
	    /**
	     * @internal
	     */
	    async _maybeWriteBufferToFile(path, buffer) {
	        if (!path) {
	            return;
	        }
	        const fs = await (0, util_js_1.importFSPromises)();
	        await fs.writeFile(path, buffer);
	    }
	    async screenshot() {
	        throw new Error('Not implemented');
	    }
	    /**
	     * @internal
	     */
	    _getPDFOptions(options = {}, lengthUnit = 'in') {
	        const defaults = {
	            scale: 1,
	            displayHeaderFooter: false,
	            headerTemplate: '',
	            footerTemplate: '',
	            printBackground: false,
	            landscape: false,
	            pageRanges: '',
	            preferCSSPageSize: false,
	            omitBackground: false,
	            timeout: 30000,
	        };
	        let width = 8.5;
	        let height = 11;
	        if (options.format) {
	            const format = PDFOptions_js_1.paperFormats[options.format.toLowerCase()];
	            (0, assert_js_1.assert)(format, 'Unknown paper format: ' + options.format);
	            width = format.width;
	            height = format.height;
	        }
	        else {
	            width = convertPrintParameterToInches(options.width, lengthUnit) ?? width;
	            height =
	                convertPrintParameterToInches(options.height, lengthUnit) ?? height;
	        }
	        const margin = {
	            top: convertPrintParameterToInches(options.margin?.top, lengthUnit) || 0,
	            left: convertPrintParameterToInches(options.margin?.left, lengthUnit) || 0,
	            bottom: convertPrintParameterToInches(options.margin?.bottom, lengthUnit) || 0,
	            right: convertPrintParameterToInches(options.margin?.right, lengthUnit) || 0,
	        };
	        const output = {
	            ...defaults,
	            ...options,
	            width,
	            height,
	            margin,
	        };
	        return output;
	    }
	    async createPDFStream() {
	        throw new Error('Not implemented');
	    }
	    async pdf() {
	        throw new Error('Not implemented');
	    }
	    /**
	     * The page's title
	     *
	     * @remarks
	     * Shortcut for {@link Frame.title | page.mainFrame().title()}.
	     */
	    async title() {
	        return await this.mainFrame().title();
	    }
	    async close() {
	        throw new Error('Not implemented');
	    }
	    /**
	     * Indicates that the page has been closed.
	     * @returns
	     */
	    isClosed() {
	        throw new Error('Not implemented');
	    }
	    /**
	     * {@inheritDoc Mouse}
	     */
	    get mouse() {
	        throw new Error('Not implemented');
	    }
	    /**
	     * This method fetches an element with `selector`, scrolls it into view if
	     * needed, and then uses {@link Page | Page.mouse} to click in the center of the
	     * element. If there's no element matching `selector`, the method throws an
	     * error.
	     * @remarks Bear in mind that if `click()` triggers a navigation event and
	     * there's a separate `page.waitForNavigation()` promise to be resolved, you
	     * may end up with a race condition that yields unexpected results. The
	     * correct pattern for click and wait for navigation is the following:
	     *
	     * ```ts
	     * const [response] = await Promise.all([
	     *   page.waitForNavigation(waitOptions),
	     *   page.click(selector, clickOptions),
	     * ]);
	     * ```
	     *
	     * Shortcut for {@link Frame.click | page.mainFrame().click(selector[, options]) }.
	     * @param selector - A `selector` to search for element to click. If there are
	     * multiple elements satisfying the `selector`, the first will be clicked
	     * @param options - `Object`
	     * @returns Promise which resolves when the element matching `selector` is
	     * successfully clicked. The Promise will be rejected if there is no element
	     * matching `selector`.
	     */
	    click(selector, options) {
	        return this.mainFrame().click(selector, options);
	    }
	    /**
	     * This method fetches an element with `selector` and focuses it. If there's no
	     * element matching `selector`, the method throws an error.
	     * @param selector - A
	     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector }
	     * of an element to focus. If there are multiple elements satisfying the
	     * selector, the first will be focused.
	     * @returns Promise which resolves when the element matching selector is
	     * successfully focused. The promise will be rejected if there is no element
	     * matching selector.
	     * @remarks
	     * Shortcut for {@link Frame.focus | page.mainFrame().focus(selector)}.
	     */
	    focus(selector) {
	        return this.mainFrame().focus(selector);
	    }
	    /**
	     * This method fetches an element with `selector`, scrolls it into view if
	     * needed, and then uses {@link Page | Page.mouse}
	     * to hover over the center of the element.
	     * If there's no element matching `selector`, the method throws an error.
	     * @param selector - A
	     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}
	     * to search for element to hover. If there are multiple elements satisfying
	     * the selector, the first will be hovered.
	     * @returns Promise which resolves when the element matching `selector` is
	     * successfully hovered. Promise gets rejected if there's no element matching
	     * `selector`.
	     * @remarks
	     * Shortcut for {@link Page.hover | page.mainFrame().hover(selector)}.
	     */
	    hover(selector) {
	        return this.mainFrame().hover(selector);
	    }
	    /**
	     * Triggers a `change` and `input` event once all the provided options have been
	     * selected. If there's no `<select>` element matching `selector`, the method
	     * throws an error.
	     *
	     * @example
	     *
	     * ```ts
	     * page.select('select#colors', 'blue'); // single selection
	     * page.select('select#colors', 'red', 'green', 'blue'); // multiple selections
	     * ```
	     *
	     * @param selector - A
	     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | Selector}
	     * to query the page for
	     * @param values - Values of options to select. If the `<select>` has the
	     * `multiple` attribute, all values are considered, otherwise only the first one
	     * is taken into account.
	     * @returns
	     *
	     * @remarks
	     * Shortcut for {@link Frame.select | page.mainFrame().select()}
	     */
	    select(selector, ...values) {
	        return this.mainFrame().select(selector, ...values);
	    }
	    /**
	     * This method fetches an element with `selector`, scrolls it into view if
	     * needed, and then uses {@link Page | Page.touchscreen}
	     * to tap in the center of the element.
	     * If there's no element matching `selector`, the method throws an error.
	     * @param selector - A
	     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | Selector}
	     * to search for element to tap. If there are multiple elements satisfying the
	     * selector, the first will be tapped.
	     * @returns
	     * @remarks
	     * Shortcut for {@link Frame.tap | page.mainFrame().tap(selector)}.
	     */
	    tap(selector) {
	        return this.mainFrame().tap(selector);
	    }
	    /**
	     * Sends a `keydown`, `keypress/input`, and `keyup` event for each character
	     * in the text.
	     *
	     * To press a special key, like `Control` or `ArrowDown`, use {@link Keyboard.press}.
	     * @example
	     *
	     * ```ts
	     * await page.type('#mytextarea', 'Hello');
	     * // Types instantly
	     * await page.type('#mytextarea', 'World', {delay: 100});
	     * // Types slower, like a user
	     * ```
	     *
	     * @param selector - A
	     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}
	     * of an element to type into. If there are multiple elements satisfying the
	     * selector, the first will be used.
	     * @param text - A text to type into a focused element.
	     * @param options - have property `delay` which is the Time to wait between
	     * key presses in milliseconds. Defaults to `0`.
	     * @returns
	     * @remarks
	     */
	    type(selector, text, options) {
	        return this.mainFrame().type(selector, text, options);
	    }
	    /**
	     * @deprecated Replace with `new Promise(r => setTimeout(r, milliseconds));`.
	     *
	     * Causes your script to wait for the given number of milliseconds.
	     *
	     * @remarks
	     * It's generally recommended to not wait for a number of seconds, but instead
	     * use {@link Frame.waitForSelector}, {@link Frame.waitForXPath} or
	     * {@link Frame.waitForFunction} to wait for exactly the conditions you want.
	     *
	     * @example
	     *
	     * Wait for 1 second:
	     *
	     * ```ts
	     * await page.waitForTimeout(1000);
	     * ```
	     *
	     * @param milliseconds - the number of milliseconds to wait.
	     */
	    waitForTimeout(milliseconds) {
	        return this.mainFrame().waitForTimeout(milliseconds);
	    }
	    /**
	     * Wait for the `selector` to appear in page. If at the moment of calling the
	     * method the `selector` already exists, the method will return immediately. If
	     * the `selector` doesn't appear after the `timeout` milliseconds of waiting, the
	     * function will throw.
	     *
	     * @example
	     * This method works across navigations:
	     *
	     * ```ts
	     * import puppeteer from 'puppeteer';
	     * (async () => {
	     *   const browser = await puppeteer.launch();
	     *   const page = await browser.newPage();
	     *   let currentURL;
	     *   page
	     *     .waitForSelector('img')
	     *     .then(() => console.log('First URL with image: ' + currentURL));
	     *   for (currentURL of [
	     *     'https://example.com',
	     *     'https://google.com',
	     *     'https://bbc.com',
	     *   ]) {
	     *     await page.goto(currentURL);
	     *   }
	     *   await browser.close();
	     * })();
	     * ```
	     *
	     * @param selector - A
	     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}
	     * of an element to wait for
	     * @param options - Optional waiting parameters
	     * @returns Promise which resolves when element specified by selector string
	     * is added to DOM. Resolves to `null` if waiting for hidden: `true` and
	     * selector is not found in DOM.
	     * @remarks
	     * The optional Parameter in Arguments `options` are:
	     *
	     * - `visible`: A boolean wait for element to be present in DOM and to be
	     *   visible, i.e. to not have `display: none` or `visibility: hidden` CSS
	     *   properties. Defaults to `false`.
	     *
	     * - `hidden`: Wait for element to not be found in the DOM or to be hidden,
	     *   i.e. have `display: none` or `visibility: hidden` CSS properties. Defaults to
	     *   `false`.
	     *
	     * - `timeout`: maximum time to wait for in milliseconds. Defaults to `30000`
	     *   (30 seconds). Pass `0` to disable timeout. The default value can be changed
	     *   by using the {@link Page.setDefaultTimeout} method.
	     */
	    async waitForSelector(selector, options = {}) {
	        return await this.mainFrame().waitForSelector(selector, options);
	    }
	    /**
	     * Wait for the `xpath` to appear in page. If at the moment of calling the
	     * method the `xpath` already exists, the method will return immediately. If
	     * the `xpath` doesn't appear after the `timeout` milliseconds of waiting, the
	     * function will throw.
	     *
	     * @example
	     * This method works across navigation
	     *
	     * ```ts
	     * import puppeteer from 'puppeteer';
	     * (async () => {
	     *   const browser = await puppeteer.launch();
	     *   const page = await browser.newPage();
	     *   let currentURL;
	     *   page
	     *     .waitForXPath('//img')
	     *     .then(() => console.log('First URL with image: ' + currentURL));
	     *   for (currentURL of [
	     *     'https://example.com',
	     *     'https://google.com',
	     *     'https://bbc.com',
	     *   ]) {
	     *     await page.goto(currentURL);
	     *   }
	     *   await browser.close();
	     * })();
	     * ```
	     *
	     * @param xpath - A
	     * {@link https://developer.mozilla.org/en-US/docs/Web/XPath | xpath} of an
	     * element to wait for
	     * @param options - Optional waiting parameters
	     * @returns Promise which resolves when element specified by xpath string is
	     * added to DOM. Resolves to `null` if waiting for `hidden: true` and xpath is
	     * not found in DOM, otherwise resolves to `ElementHandle`.
	     * @remarks
	     * The optional Argument `options` have properties:
	     *
	     * - `visible`: A boolean to wait for element to be present in DOM and to be
	     *   visible, i.e. to not have `display: none` or `visibility: hidden` CSS
	     *   properties. Defaults to `false`.
	     *
	     * - `hidden`: A boolean wait for element to not be found in the DOM or to be
	     *   hidden, i.e. have `display: none` or `visibility: hidden` CSS properties.
	     *   Defaults to `false`.
	     *
	     * - `timeout`: A number which is maximum time to wait for in milliseconds.
	     *   Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default
	     *   value can be changed by using the {@link Page.setDefaultTimeout} method.
	     */
	    waitForXPath(xpath, options) {
	        return this.mainFrame().waitForXPath(xpath, options);
	    }
	    /**
	     * Waits for a function to finish evaluating in the page's context.
	     *
	     * @example
	     * The {@link Page.waitForFunction} can be used to observe viewport size change:
	     *
	     * ```ts
	     * import puppeteer from 'puppeteer';
	     * (async () => {
	     *   const browser = await puppeteer.launch();
	     *   const page = await browser.newPage();
	     *   const watchDog = page.waitForFunction('window.innerWidth < 100');
	     *   await page.setViewport({width: 50, height: 50});
	     *   await watchDog;
	     *   await browser.close();
	     * })();
	     * ```
	     *
	     * @example
	     * To pass arguments from node.js to the predicate of
	     * {@link Page.waitForFunction} function:
	     *
	     * ```ts
	     * const selector = '.foo';
	     * await page.waitForFunction(
	     *   selector => !!document.querySelector(selector),
	     *   {},
	     *   selector
	     * );
	     * ```
	     *
	     * @example
	     * The predicate of {@link Page.waitForFunction} can be asynchronous too:
	     *
	     * ```ts
	     * const username = 'github-username';
	     * await page.waitForFunction(
	     *   async username => {
	     *     const githubResponse = await fetch(
	     *       `https://api.github.com/users/${username}`
	     *     );
	     *     const githubUser = await githubResponse.json();
	     *     // show the avatar
	     *     const img = document.createElement('img');
	     *     img.src = githubUser.avatar_url;
	     *     // wait 3 seconds
	     *     await new Promise((resolve, reject) => setTimeout(resolve, 3000));
	     *     img.remove();
	     *   },
	     *   {},
	     *   username
	     * );
	     * ```
	     *
	     * @param pageFunction - Function to be evaluated in browser context
	     * @param options - Options for configuring waiting behavior.
	     */
	    waitForFunction(pageFunction, options, ...args) {
	        return this.mainFrame().waitForFunction(pageFunction, options, ...args);
	    }
	    waitForDevicePrompt() {
	        throw new Error('Not implemented');
	    }
	    [Symbol.dispose]() {
	        return void this.close().catch(util_js_1.debugError);
	    }
	    [Symbol.asyncDispose]() {
	        return this.close();
	    }
	}
	exports.Page = Page;
	/**
	 * @internal
	 */
	exports.supportedMetrics = new Set([
	    'Timestamp',
	    'Documents',
	    'Frames',
	    'JSEventListeners',
	    'Nodes',
	    'LayoutCount',
	    'RecalcStyleCount',
	    'LayoutDuration',
	    'RecalcStyleDuration',
	    'ScriptDuration',
	    'TaskDuration',
	    'JSHeapUsedSize',
	    'JSHeapTotalSize',
	]);
	/**
	 * @internal
	 */
	exports.unitToPixels = {
	    px: 1,
	    in: 96,
	    cm: 37.8,
	    mm: 3.78,
	};
	function convertPrintParameterToInches(parameter, lengthUnit = 'in') {
	    if (typeof parameter === 'undefined') {
	        return undefined;
	    }
	    let pixels;
	    if ((0, util_js_1.isNumber)(parameter)) {
	        // Treat numbers as pixel values to be aligned with phantom's paperSize.
	        pixels = parameter;
	    }
	    else if ((0, util_js_1.isString)(parameter)) {
	        const text = parameter;
	        let unit = text.substring(text.length - 2).toLowerCase();
	        let valueText = '';
	        if (unit in exports.unitToPixels) {
	            valueText = text.substring(0, text.length - 2);
	        }
	        else {
	            // In case of unknown unit try to parse the whole parameter as number of pixels.
	            // This is consistent with phantom's paperSize behavior.
	            unit = 'px';
	            valueText = text;
	        }
	        const value = Number(valueText);
	        (0, assert_js_1.assert)(!isNaN(value), 'Failed to parse parameter value: ' + text);
	        pixels = value * exports.unitToPixels[unit];
	    }
	    else {
	        throw new Error('page.pdf() Cannot handle parameter type: ' + typeof parameter);
	    }
	    return pixels / exports.unitToPixels[lengthUnit];
	}
	
} (Page$2));

var Realm$2 = {};

var WaitTask$1 = {};

/**
 * Copyright 2022 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(WaitTask$1, "__esModule", { value: true });
WaitTask$1.TaskManager = WaitTask$1.WaitTask = void 0;
const Deferred_js_1$8 = Deferred$1;
const ErrorLike_js_1$5 = ErrorLike;
const Function_js_1$1 = _Function;
const Errors_js_1$2 = Errors;
const LazyArg_js_1$1 = LazyArg$1;
/**
 * @internal
 */
class WaitTask {
    #world;
    #polling;
    #root;
    #fn;
    #args;
    #timeout;
    #result = Deferred_js_1$8.Deferred.create();
    #poller;
    #signal;
    constructor(world, options, fn, ...args) {
        this.#world = world;
        this.#polling = options.polling;
        this.#root = options.root;
        this.#signal = options.signal;
        this.#signal?.addEventListener('abort', () => {
            void this.terminate(this.#signal?.reason);
        }, {
            once: true,
        });
        switch (typeof fn) {
            case 'string':
                this.#fn = `() => {return (${fn});}`;
                break;
            default:
                this.#fn = (0, Function_js_1$1.stringifyFunction)(fn);
                break;
        }
        this.#args = args;
        this.#world.taskManager.add(this);
        if (options.timeout) {
            this.#timeout = setTimeout(() => {
                void this.terminate(new Errors_js_1$2.TimeoutError(`Waiting failed: ${options.timeout}ms exceeded`));
            }, options.timeout);
        }
        void this.rerun();
    }
    get result() {
        return this.#result.valueOrThrow();
    }
    async rerun() {
        try {
            switch (this.#polling) {
                case 'raf':
                    this.#poller = await this.#world.evaluateHandle(({ RAFPoller, createFunction }, fn, ...args) => {
                        const fun = createFunction(fn);
                        return new RAFPoller(() => {
                            return fun(...args);
                        });
                    }, LazyArg_js_1$1.LazyArg.create(context => {
                        return context.puppeteerUtil;
                    }), this.#fn, ...this.#args);
                    break;
                case 'mutation':
                    this.#poller = await this.#world.evaluateHandle(({ MutationPoller, createFunction }, root, fn, ...args) => {
                        const fun = createFunction(fn);
                        return new MutationPoller(() => {
                            return fun(...args);
                        }, root || document);
                    }, LazyArg_js_1$1.LazyArg.create(context => {
                        return context.puppeteerUtil;
                    }), this.#root, this.#fn, ...this.#args);
                    break;
                default:
                    this.#poller = await this.#world.evaluateHandle(({ IntervalPoller, createFunction }, ms, fn, ...args) => {
                        const fun = createFunction(fn);
                        return new IntervalPoller(() => {
                            return fun(...args);
                        }, ms);
                    }, LazyArg_js_1$1.LazyArg.create(context => {
                        return context.puppeteerUtil;
                    }), this.#polling, this.#fn, ...this.#args);
                    break;
            }
            await this.#poller.evaluate(poller => {
                void poller.start();
            });
            const result = await this.#poller.evaluateHandle(poller => {
                return poller.result();
            });
            this.#result.resolve(result);
            await this.terminate();
        }
        catch (error) {
            const badError = this.getBadError(error);
            if (badError) {
                await this.terminate(badError);
            }
        }
    }
    async terminate(error) {
        this.#world.taskManager.delete(this);
        if (this.#timeout) {
            clearTimeout(this.#timeout);
        }
        if (error && !this.#result.finished()) {
            this.#result.reject(error);
        }
        if (this.#poller) {
            try {
                await this.#poller.evaluateHandle(async (poller) => {
                    await poller.stop();
                });
                if (this.#poller) {
                    await this.#poller.dispose();
                    this.#poller = undefined;
                }
            }
            catch {
                // Ignore errors since they most likely come from low-level cleanup.
            }
        }
    }
    /**
     * Not all errors lead to termination. They usually imply we need to rerun the task.
     */
    getBadError(error) {
        if ((0, ErrorLike_js_1$5.isErrorLike)(error)) {
            // When frame is detached the task should have been terminated by the IsolatedWorld.
            // This can fail if we were adding this task while the frame was detached,
            // so we terminate here instead.
            if (error.message.includes('Execution context is not available in detached frame')) {
                return new Error('Waiting failed: Frame detached');
            }
            // When the page is navigated, the promise is rejected.
            // We will try again in the new execution context.
            if (error.message.includes('Execution context was destroyed')) {
                return;
            }
            // We could have tried to evaluate in a context which was already
            // destroyed.
            if (error.message.includes('Cannot find context with specified id')) {
                return;
            }
            return error;
        }
        return new Error('WaitTask failed with an error', {
            cause: error,
        });
    }
}
WaitTask$1.WaitTask = WaitTask;
/**
 * @internal
 */
class TaskManager {
    #tasks = new Set();
    add(task) {
        this.#tasks.add(task);
    }
    delete(task) {
        this.#tasks.delete(task);
    }
    terminateAll(error) {
        for (const task of this.#tasks) {
            void task.terminate(error);
        }
        this.#tasks.clear();
    }
    async rerunAll() {
        await Promise.all([...this.#tasks].map(task => {
            return task.rerun();
        }));
    }
}
WaitTask$1.TaskManager = TaskManager;

/**
 * Copyright 2023 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(Realm$2, "__esModule", { value: true });
Realm$2.Realm = void 0;
const WaitTask_js_1 = WaitTask$1;
/**
 * @internal
 */
let Realm$1 = class Realm {
    timeoutSettings;
    taskManager = new WaitTask_js_1.TaskManager();
    constructor(timeoutSettings) {
        this.timeoutSettings = timeoutSettings;
    }
    async waitForFunction(pageFunction, options = {}, ...args) {
        const { polling = 'raf', timeout = this.timeoutSettings.timeout(), root, signal, } = options;
        if (typeof polling === 'number' && polling < 0) {
            throw new Error('Cannot poll with non-positive interval');
        }
        const waitTask = new WaitTask_js_1.WaitTask(this, {
            polling,
            root,
            timeout,
            signal,
        }, pageFunction, ...args);
        return await waitTask.result;
    }
    get disposed() {
        return this.#disposed;
    }
    #disposed = false;
    [Symbol.dispose]() {
        this.#disposed = true;
        this.taskManager.terminateAll(new Error('waitForFunction failed: frame got detached.'));
    }
};
Realm$2.Realm = Realm$1;

var Target$3 = {};

/**
 * Copyright 2023 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(Target$3, "__esModule", { value: true });
Target$3.Target = Target$3.TargetType = void 0;
/**
 * @public
 */
var TargetType;
(function (TargetType) {
    TargetType["PAGE"] = "page";
    TargetType["BACKGROUND_PAGE"] = "background_page";
    TargetType["SERVICE_WORKER"] = "service_worker";
    TargetType["SHARED_WORKER"] = "shared_worker";
    TargetType["BROWSER"] = "browser";
    TargetType["WEBVIEW"] = "webview";
    TargetType["OTHER"] = "other";
    /**
     * @internal
     */
    TargetType["TAB"] = "tab";
})(TargetType || (Target$3.TargetType = TargetType = {}));
/**
 * Target represents a
 * {@link https://chromedevtools.github.io/devtools-protocol/tot/Target/ | CDP target}.
 * In CDP a target is something that can be debugged such a frame, a page or a
 * worker.
 * @public
 */
let Target$2 = class Target {
    /**
     * @internal
     */
    constructor() { }
    /**
     * If the target is not of type `"service_worker"` or `"shared_worker"`, returns `null`.
     */
    async worker() {
        return null;
    }
    /**
     * If the target is not of type `"page"`, `"webview"` or `"background_page"`,
     * returns `null`.
     */
    async page() {
        return null;
    }
    url() {
        throw new Error('not implemented');
    }
    /**
     * Creates a Chrome Devtools Protocol session attached to the target.
     */
    createCDPSession() {
        throw new Error('not implemented');
    }
    /**
     * Identifies what kind of target this is.
     *
     * @remarks
     *
     * See {@link https://developer.chrome.com/extensions/background_pages | docs} for more info about background pages.
     */
    type() {
        throw new Error('not implemented');
    }
    /**
     * Get the browser the target belongs to.
     */
    browser() {
        throw new Error('not implemented');
    }
    /**
     * Get the browser context the target belongs to.
     */
    browserContext() {
        throw new Error('not implemented');
    }
    /**
     * Get the target that opened this target. Top-level targets return `null`.
     */
    opener() {
        throw new Error('not implemented');
    }
};
Target$3.Target = Target$2;

(function (exports) {
	/**
	 * Copyright 2022 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	__exportStar(Browser$3, exports);
	__exportStar(BrowserContext$2, exports);
	__exportStar(Dialog$3, exports);
	__exportStar(requireElementHandle$2(), exports);
	__exportStar(Environment, exports);
	__exportStar(Frame$2, exports);
	__exportStar(HTTPRequest$4, exports);
	__exportStar(HTTPResponse$4, exports);
	__exportStar(Input$2, exports);
	__exportStar(requireJSHandle$2(), exports);
	__exportStar(requireLocators(), exports);
	__exportStar(Page$2, exports);
	__exportStar(Realm$2, exports);
	__exportStar(Target$3, exports);
	
} (api));

var common = {};

var Accessibility$1 = {};

/**
 * Copyright 2018 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(Accessibility$1, "__esModule", { value: true });
Accessibility$1.Accessibility = void 0;
/**
 * The Accessibility class provides methods for inspecting the browser's
 * accessibility tree. The accessibility tree is used by assistive technology
 * such as {@link https://en.wikipedia.org/wiki/Screen_reader | screen readers} or
 * {@link https://en.wikipedia.org/wiki/Switch_access | switches}.
 *
 * @remarks
 *
 * Accessibility is a very platform-specific thing. On different platforms,
 * there are different screen readers that might have wildly different output.
 *
 * Blink - Chrome's rendering engine - has a concept of "accessibility tree",
 * which is then translated into different platform-specific APIs. Accessibility
 * namespace gives users access to the Blink Accessibility Tree.
 *
 * Most of the accessibility tree gets filtered out when converting from Blink
 * AX Tree to Platform-specific AX-Tree or by assistive technologies themselves.
 * By default, Puppeteer tries to approximate this filtering, exposing only
 * the "interesting" nodes of the tree.
 *
 * @public
 */
class Accessibility {
    #client;
    /**
     * @internal
     */
    constructor(client) {
        this.#client = client;
    }
    /**
     * @internal
     */
    updateClient(client) {
        this.#client = client;
    }
    /**
     * Captures the current state of the accessibility tree.
     * The returned object represents the root accessible node of the page.
     *
     * @remarks
     *
     * **NOTE** The Chrome accessibility tree contains nodes that go unused on
     * most platforms and by most screen readers. Puppeteer will discard them as
     * well for an easier to process tree, unless `interestingOnly` is set to
     * `false`.
     *
     * @example
     * An example of dumping the entire accessibility tree:
     *
     * ```ts
     * const snapshot = await page.accessibility.snapshot();
     * console.log(snapshot);
     * ```
     *
     * @example
     * An example of logging the focused node's name:
     *
     * ```ts
     * const snapshot = await page.accessibility.snapshot();
     * const node = findFocusedNode(snapshot);
     * console.log(node && node.name);
     *
     * function findFocusedNode(node) {
     *   if (node.focused) return node;
     *   for (const child of node.children || []) {
     *     const foundNode = findFocusedNode(child);
     *     return foundNode;
     *   }
     *   return null;
     * }
     * ```
     *
     * @returns An AXNode object representing the snapshot.
     */
    async snapshot(options = {}) {
        const { interestingOnly = true, root = null } = options;
        const { nodes } = await this.#client.send('Accessibility.getFullAXTree');
        let backendNodeId;
        if (root) {
            const { node } = await this.#client.send('DOM.describeNode', {
                objectId: root.id,
            });
            backendNodeId = node.backendNodeId;
        }
        const defaultRoot = AXNode.createTree(nodes);
        let needle = defaultRoot;
        if (backendNodeId) {
            needle = defaultRoot.find(node => {
                return node.payload.backendDOMNodeId === backendNodeId;
            });
            if (!needle) {
                return null;
            }
        }
        if (!interestingOnly) {
            return this.serializeTree(needle)[0] ?? null;
        }
        const interestingNodes = new Set();
        this.collectInterestingNodes(interestingNodes, defaultRoot, false);
        if (!interestingNodes.has(needle)) {
            return null;
        }
        return this.serializeTree(needle, interestingNodes)[0] ?? null;
    }
    serializeTree(node, interestingNodes) {
        const children = [];
        for (const child of node.children) {
            children.push(...this.serializeTree(child, interestingNodes));
        }
        if (interestingNodes && !interestingNodes.has(node)) {
            return children;
        }
        const serializedNode = node.serialize();
        if (children.length) {
            serializedNode.children = children;
        }
        return [serializedNode];
    }
    collectInterestingNodes(collection, node, insideControl) {
        if (node.isInteresting(insideControl)) {
            collection.add(node);
        }
        if (node.isLeafNode()) {
            return;
        }
        insideControl = insideControl || node.isControl();
        for (const child of node.children) {
            this.collectInterestingNodes(collection, child, insideControl);
        }
    }
}
Accessibility$1.Accessibility = Accessibility;
class AXNode {
    payload;
    children = [];
    #richlyEditable = false;
    #editable = false;
    #focusable = false;
    #hidden = false;
    #name;
    #role;
    #ignored;
    #cachedHasFocusableChild;
    constructor(payload) {
        this.payload = payload;
        this.#name = this.payload.name ? this.payload.name.value : '';
        this.#role = this.payload.role ? this.payload.role.value : 'Unknown';
        this.#ignored = this.payload.ignored;
        for (const property of this.payload.properties || []) {
            if (property.name === 'editable') {
                this.#richlyEditable = property.value.value === 'richtext';
                this.#editable = true;
            }
            if (property.name === 'focusable') {
                this.#focusable = property.value.value;
            }
            if (property.name === 'hidden') {
                this.#hidden = property.value.value;
            }
        }
    }
    #isPlainTextField() {
        if (this.#richlyEditable) {
            return false;
        }
        if (this.#editable) {
            return true;
        }
        return this.#role === 'textbox' || this.#role === 'searchbox';
    }
    #isTextOnlyObject() {
        const role = this.#role;
        return role === 'LineBreak' || role === 'text' || role === 'InlineTextBox';
    }
    #hasFocusableChild() {
        if (this.#cachedHasFocusableChild === undefined) {
            this.#cachedHasFocusableChild = false;
            for (const child of this.children) {
                if (child.#focusable || child.#hasFocusableChild()) {
                    this.#cachedHasFocusableChild = true;
                    break;
                }
            }
        }
        return this.#cachedHasFocusableChild;
    }
    find(predicate) {
        if (predicate(this)) {
            return this;
        }
        for (const child of this.children) {
            const result = child.find(predicate);
            if (result) {
                return result;
            }
        }
        return null;
    }
    isLeafNode() {
        if (!this.children.length) {
            return true;
        }
        // These types of objects may have children that we use as internal
        // implementation details, but we want to expose them as leaves to platform
        // accessibility APIs because screen readers might be confused if they find
        // any children.
        if (this.#isPlainTextField() || this.#isTextOnlyObject()) {
            return true;
        }
        // Roles whose children are only presentational according to the ARIA and
        // HTML5 Specs should be hidden from screen readers.
        // (Note that whilst ARIA buttons can have only presentational children, HTML5
        // buttons are allowed to have content.)
        switch (this.#role) {
            case 'doc-cover':
            case 'graphics-symbol':
            case 'img':
            case 'Meter':
            case 'scrollbar':
            case 'slider':
            case 'separator':
            case 'progressbar':
                return true;
        }
        // Here and below: Android heuristics
        if (this.#hasFocusableChild()) {
            return false;
        }
        if (this.#focusable && this.#name) {
            return true;
        }
        if (this.#role === 'heading' && this.#name) {
            return true;
        }
        return false;
    }
    isControl() {
        switch (this.#role) {
            case 'button':
            case 'checkbox':
            case 'ColorWell':
            case 'combobox':
            case 'DisclosureTriangle':
            case 'listbox':
            case 'menu':
            case 'menubar':
            case 'menuitem':
            case 'menuitemcheckbox':
            case 'menuitemradio':
            case 'radio':
            case 'scrollbar':
            case 'searchbox':
            case 'slider':
            case 'spinbutton':
            case 'switch':
            case 'tab':
            case 'textbox':
            case 'tree':
            case 'treeitem':
                return true;
            default:
                return false;
        }
    }
    isInteresting(insideControl) {
        const role = this.#role;
        if (role === 'Ignored' || this.#hidden || this.#ignored) {
            return false;
        }
        if (this.#focusable || this.#richlyEditable) {
            return true;
        }
        // If it's not focusable but has a control role, then it's interesting.
        if (this.isControl()) {
            return true;
        }
        // A non focusable child of a control is not interesting
        if (insideControl) {
            return false;
        }
        return this.isLeafNode() && !!this.#name;
    }
    serialize() {
        const properties = new Map();
        for (const property of this.payload.properties || []) {
            properties.set(property.name.toLowerCase(), property.value.value);
        }
        if (this.payload.name) {
            properties.set('name', this.payload.name.value);
        }
        if (this.payload.value) {
            properties.set('value', this.payload.value.value);
        }
        if (this.payload.description) {
            properties.set('description', this.payload.description.value);
        }
        const node = {
            role: this.#role,
        };
        const userStringProperties = [
            'name',
            'value',
            'description',
            'keyshortcuts',
            'roledescription',
            'valuetext',
        ];
        const getUserStringPropertyValue = (key) => {
            return properties.get(key);
        };
        for (const userStringProperty of userStringProperties) {
            if (!properties.has(userStringProperty)) {
                continue;
            }
            node[userStringProperty] = getUserStringPropertyValue(userStringProperty);
        }
        const booleanProperties = [
            'disabled',
            'expanded',
            'focused',
            'modal',
            'multiline',
            'multiselectable',
            'readonly',
            'required',
            'selected',
        ];
        const getBooleanPropertyValue = (key) => {
            return properties.get(key);
        };
        for (const booleanProperty of booleanProperties) {
            // RootWebArea's treat focus differently than other nodes. They report whether
            // their frame  has focus, not whether focus is specifically on the root
            // node.
            if (booleanProperty === 'focused' && this.#role === 'RootWebArea') {
                continue;
            }
            const value = getBooleanPropertyValue(booleanProperty);
            if (!value) {
                continue;
            }
            node[booleanProperty] = getBooleanPropertyValue(booleanProperty);
        }
        const tristateProperties = ['checked', 'pressed'];
        for (const tristateProperty of tristateProperties) {
            if (!properties.has(tristateProperty)) {
                continue;
            }
            const value = properties.get(tristateProperty);
            node[tristateProperty] =
                value === 'mixed' ? 'mixed' : value === 'true' ? true : false;
        }
        const numericalProperties = [
            'level',
            'valuemax',
            'valuemin',
        ];
        const getNumericalPropertyValue = (key) => {
            return properties.get(key);
        };
        for (const numericalProperty of numericalProperties) {
            if (!properties.has(numericalProperty)) {
                continue;
            }
            node[numericalProperty] = getNumericalPropertyValue(numericalProperty);
        }
        const tokenProperties = [
            'autocomplete',
            'haspopup',
            'invalid',
            'orientation',
        ];
        const getTokenPropertyValue = (key) => {
            return properties.get(key);
        };
        for (const tokenProperty of tokenProperties) {
            const value = getTokenPropertyValue(tokenProperty);
            if (!value || value === 'false') {
                continue;
            }
            node[tokenProperty] = getTokenPropertyValue(tokenProperty);
        }
        return node;
    }
    static createTree(payloads) {
        const nodeById = new Map();
        for (const payload of payloads) {
            nodeById.set(payload.nodeId, new AXNode(payload));
        }
        for (const node of nodeById.values()) {
            for (const childId of node.payload.childIds || []) {
                const child = nodeById.get(childId);
                if (child) {
                    node.children.push(child);
                }
            }
        }
        return nodeById.values().next().value;
    }
}

var Binding$1 = {};

var __addDisposableResource$1 = (commonjsGlobal && commonjsGlobal.__addDisposableResource) || function (env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        env.stack.push({ value: value, dispose: dispose, async: async });
    }
    else if (async) {
        env.stack.push({ async: true });
    }
    return value;
};
var __disposeResources$1 = (commonjsGlobal && commonjsGlobal.__disposeResources) || (function (SuppressedError) {
    return function (env) {
        function fail(e) {
            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        function next() {
            while (env.stack.length) {
                var rec = env.stack.pop();
                try {
                    var result = rec.dispose && rec.dispose.call(rec.value);
                    if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
                }
                catch (e) {
                    fail(e);
                }
            }
            if (env.hasError) throw env.error;
        }
        return next();
    };
})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
Object.defineProperty(Binding$1, "__esModule", { value: true });
Binding$1.Binding = void 0;
const JSHandle_js_1$2 = requireJSHandle$2();
const ErrorLike_js_1$4 = ErrorLike;
const util_js_1$d = requireUtil();
/**
 * @internal
 */
class Binding {
    #name;
    #fn;
    constructor(name, fn) {
        this.#name = name;
        this.#fn = fn;
    }
    get name() {
        return this.#name;
    }
    /**
     * @param context - Context to run the binding in; the context should have
     * the binding added to it beforehand.
     * @param id - ID of the call. This should come from the CDP
     * `onBindingCalled` response.
     * @param args - Plain arguments from CDP.
     */
    async run(context, id, args, isTrivial) {
        const stack = new DisposableStack();
        try {
            if (!isTrivial) {
                const env_1 = { stack: [], error: void 0, hasError: false };
                try {
                    // Getting non-trivial arguments.
                    const handles = __addDisposableResource$1(env_1, await context.evaluateHandle((name, seq) => {
                        // @ts-expect-error Code is evaluated in a different context.
                        return globalThis[name].args.get(seq);
                    }, this.#name, id), false);
                    const properties = await handles.getProperties();
                    for (const [index, handle] of properties) {
                        // This is not straight-forward since some arguments can stringify, but
                        // aren't plain objects so add subtypes when the use-case arises.
                        if (index in args) {
                            switch (handle.remoteObject().subtype) {
                                case 'node':
                                    args[+index] = handle;
                                    break;
                                default:
                                    stack.use(handle);
                            }
                        }
                        else {
                            stack.use(handle);
                        }
                    }
                }
                catch (e_1) {
                    env_1.error = e_1;
                    env_1.hasError = true;
                }
                finally {
                    __disposeResources$1(env_1);
                }
            }
            await context.evaluate((name, seq, result) => {
                // @ts-expect-error Code is evaluated in a different context.
                const callbacks = globalThis[name].callbacks;
                callbacks.get(seq).resolve(result);
                callbacks.delete(seq);
            }, this.#name, id, await this.#fn(...args));
            for (const arg of args) {
                if (arg instanceof JSHandle_js_1$2.JSHandle) {
                    stack.use(arg);
                }
            }
        }
        catch (error) {
            if ((0, ErrorLike_js_1$4.isErrorLike)(error)) {
                await context
                    .evaluate((name, seq, message, stack) => {
                    const error = new Error(message);
                    error.stack = stack;
                    // @ts-expect-error Code is evaluated in a different context.
                    const callbacks = globalThis[name].callbacks;
                    callbacks.get(seq).reject(error);
                    callbacks.delete(seq);
                }, this.#name, id, error.message, error.stack)
                    .catch(util_js_1$d.debugError);
            }
            else {
                await context
                    .evaluate((name, seq, error) => {
                    // @ts-expect-error Code is evaluated in a different context.
                    const callbacks = globalThis[name].callbacks;
                    callbacks.get(seq).reject(error);
                    callbacks.delete(seq);
                }, this.#name, id, error)
                    .catch(util_js_1$d.debugError);
            }
        }
    }
}
Binding$1.Binding = Binding;

var Browser$1 = {};

var ChromeTargetManager$1 = {};

var Target$1 = {};

var Page$1 = {};

var ConsoleMessage$1 = {};

/**
 * Copyright 2020 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(ConsoleMessage$1, "__esModule", { value: true });
ConsoleMessage$1.ConsoleMessage = void 0;
/**
 * ConsoleMessage objects are dispatched by page via the 'console' event.
 * @public
 */
class ConsoleMessage {
    #type;
    #text;
    #args;
    #stackTraceLocations;
    /**
     * @public
     */
    constructor(type, text, args, stackTraceLocations) {
        this.#type = type;
        this.#text = text;
        this.#args = args;
        this.#stackTraceLocations = stackTraceLocations;
    }
    /**
     * The type of the console message.
     */
    type() {
        return this.#type;
    }
    /**
     * The text of the console message.
     */
    text() {
        return this.#text;
    }
    /**
     * An array of arguments passed to the console.
     */
    args() {
        return this.#args;
    }
    /**
     * The location of the console message.
     */
    location() {
        return this.#stackTraceLocations[0] ?? {};
    }
    /**
     * The array of locations on the stack of the console message.
     */
    stackTrace() {
        return this.#stackTraceLocations;
    }
}
ConsoleMessage$1.ConsoleMessage = ConsoleMessage;

var Coverage$1 = {};

/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(Coverage$1, "__esModule", { value: true });
Coverage$1.CSSCoverage = Coverage$1.JSCoverage = Coverage$1.Coverage = void 0;
const assert_js_1$d = assert$1;
const util_js_1$c = requireUtil();
/**
 * The Coverage class provides methods to gather information about parts of
 * JavaScript and CSS that were used by the page.
 *
 * @remarks
 * To output coverage in a form consumable by {@link https://github.com/istanbuljs | Istanbul},
 * see {@link https://github.com/istanbuljs/puppeteer-to-istanbul | puppeteer-to-istanbul}.
 *
 * @example
 * An example of using JavaScript and CSS coverage to get percentage of initially
 * executed code:
 *
 * ```ts
 * // Enable both JavaScript and CSS coverage
 * await Promise.all([
 *   page.coverage.startJSCoverage(),
 *   page.coverage.startCSSCoverage(),
 * ]);
 * // Navigate to page
 * await page.goto('https://example.com');
 * // Disable both JavaScript and CSS coverage
 * const [jsCoverage, cssCoverage] = await Promise.all([
 *   page.coverage.stopJSCoverage(),
 *   page.coverage.stopCSSCoverage(),
 * ]);
 * let totalBytes = 0;
 * let usedBytes = 0;
 * const coverage = [...jsCoverage, ...cssCoverage];
 * for (const entry of coverage) {
 *   totalBytes += entry.text.length;
 *   for (const range of entry.ranges) usedBytes += range.end - range.start - 1;
 * }
 * console.log(`Bytes used: ${(usedBytes / totalBytes) * 100}%`);
 * ```
 *
 * @public
 */
class Coverage {
    #jsCoverage;
    #cssCoverage;
    constructor(client) {
        this.#jsCoverage = new JSCoverage(client);
        this.#cssCoverage = new CSSCoverage(client);
    }
    /**
     * @internal
     */
    updateClient(client) {
        this.#jsCoverage.updateClient(client);
        this.#cssCoverage.updateClient(client);
    }
    /**
     * @param options - Set of configurable options for coverage defaults to
     * `resetOnNavigation : true, reportAnonymousScripts : false,`
     * `includeRawScriptCoverage : false, useBlockCoverage : true`
     * @returns Promise that resolves when coverage is started.
     *
     * @remarks
     * Anonymous scripts are ones that don't have an associated url. These are
     * scripts that are dynamically created on the page using `eval` or
     * `new Function`. If `reportAnonymousScripts` is set to `true`, anonymous
     * scripts URL will start with `debugger://VM` (unless a magic //# sourceURL
     * comment is present, in which case that will the be URL).
     */
    async startJSCoverage(options = {}) {
        return await this.#jsCoverage.start(options);
    }
    /**
     * Promise that resolves to the array of coverage reports for
     * all scripts.
     *
     * @remarks
     * JavaScript Coverage doesn't include anonymous scripts by default.
     * However, scripts with sourceURLs are reported.
     */
    async stopJSCoverage() {
        return await this.#jsCoverage.stop();
    }
    /**
     * @param options - Set of configurable options for coverage, defaults to
     * `resetOnNavigation : true`
     * @returns Promise that resolves when coverage is started.
     */
    async startCSSCoverage(options = {}) {
        return await this.#cssCoverage.start(options);
    }
    /**
     * Promise that resolves to the array of coverage reports
     * for all stylesheets.
     *
     * @remarks
     * CSS Coverage doesn't include dynamically injected style tags
     * without sourceURLs.
     */
    async stopCSSCoverage() {
        return await this.#cssCoverage.stop();
    }
}
Coverage$1.Coverage = Coverage;
/**
 * @public
 */
class JSCoverage {
    #client;
    #enabled = false;
    #scriptURLs = new Map();
    #scriptSources = new Map();
    #eventListeners = [];
    #resetOnNavigation = false;
    #reportAnonymousScripts = false;
    #includeRawScriptCoverage = false;
    constructor(client) {
        this.#client = client;
    }
    /**
     * @internal
     */
    updateClient(client) {
        this.#client = client;
    }
    async start(options = {}) {
        (0, assert_js_1$d.assert)(!this.#enabled, 'JSCoverage is already enabled');
        const { resetOnNavigation = true, reportAnonymousScripts = false, includeRawScriptCoverage = false, useBlockCoverage = true, } = options;
        this.#resetOnNavigation = resetOnNavigation;
        this.#reportAnonymousScripts = reportAnonymousScripts;
        this.#includeRawScriptCoverage = includeRawScriptCoverage;
        this.#enabled = true;
        this.#scriptURLs.clear();
        this.#scriptSources.clear();
        this.#eventListeners = [
            (0, util_js_1$c.addEventListener)(this.#client, 'Debugger.scriptParsed', this.#onScriptParsed.bind(this)),
            (0, util_js_1$c.addEventListener)(this.#client, 'Runtime.executionContextsCleared', this.#onExecutionContextsCleared.bind(this)),
        ];
        await Promise.all([
            this.#client.send('Profiler.enable'),
            this.#client.send('Profiler.startPreciseCoverage', {
                callCount: this.#includeRawScriptCoverage,
                detailed: useBlockCoverage,
            }),
            this.#client.send('Debugger.enable'),
            this.#client.send('Debugger.setSkipAllPauses', { skip: true }),
        ]);
    }
    #onExecutionContextsCleared() {
        if (!this.#resetOnNavigation) {
            return;
        }
        this.#scriptURLs.clear();
        this.#scriptSources.clear();
    }
    async #onScriptParsed(event) {
        // Ignore puppeteer-injected scripts
        if (util_js_1$c.PuppeteerURL.isPuppeteerURL(event.url)) {
            return;
        }
        // Ignore other anonymous scripts unless the reportAnonymousScripts option is true.
        if (!event.url && !this.#reportAnonymousScripts) {
            return;
        }
        try {
            const response = await this.#client.send('Debugger.getScriptSource', {
                scriptId: event.scriptId,
            });
            this.#scriptURLs.set(event.scriptId, event.url);
            this.#scriptSources.set(event.scriptId, response.scriptSource);
        }
        catch (error) {
            // This might happen if the page has already navigated away.
            (0, util_js_1$c.debugError)(error);
        }
    }
    async stop() {
        (0, assert_js_1$d.assert)(this.#enabled, 'JSCoverage is not enabled');
        this.#enabled = false;
        const result = await Promise.all([
            this.#client.send('Profiler.takePreciseCoverage'),
            this.#client.send('Profiler.stopPreciseCoverage'),
            this.#client.send('Profiler.disable'),
            this.#client.send('Debugger.disable'),
        ]);
        (0, util_js_1$c.removeEventListeners)(this.#eventListeners);
        const coverage = [];
        const profileResponse = result[0];
        for (const entry of profileResponse.result) {
            let url = this.#scriptURLs.get(entry.scriptId);
            if (!url && this.#reportAnonymousScripts) {
                url = 'debugger://VM' + entry.scriptId;
            }
            const text = this.#scriptSources.get(entry.scriptId);
            if (text === undefined || url === undefined) {
                continue;
            }
            const flattenRanges = [];
            for (const func of entry.functions) {
                flattenRanges.push(...func.ranges);
            }
            const ranges = convertToDisjointRanges(flattenRanges);
            if (!this.#includeRawScriptCoverage) {
                coverage.push({ url, ranges, text });
            }
            else {
                coverage.push({ url, ranges, text, rawScriptCoverage: entry });
            }
        }
        return coverage;
    }
}
Coverage$1.JSCoverage = JSCoverage;
/**
 * @public
 */
class CSSCoverage {
    #client;
    #enabled = false;
    #stylesheetURLs = new Map();
    #stylesheetSources = new Map();
    #eventListeners = [];
    #resetOnNavigation = false;
    constructor(client) {
        this.#client = client;
    }
    /**
     * @internal
     */
    updateClient(client) {
        this.#client = client;
    }
    async start(options = {}) {
        (0, assert_js_1$d.assert)(!this.#enabled, 'CSSCoverage is already enabled');
        const { resetOnNavigation = true } = options;
        this.#resetOnNavigation = resetOnNavigation;
        this.#enabled = true;
        this.#stylesheetURLs.clear();
        this.#stylesheetSources.clear();
        this.#eventListeners = [
            (0, util_js_1$c.addEventListener)(this.#client, 'CSS.styleSheetAdded', this.#onStyleSheet.bind(this)),
            (0, util_js_1$c.addEventListener)(this.#client, 'Runtime.executionContextsCleared', this.#onExecutionContextsCleared.bind(this)),
        ];
        await Promise.all([
            this.#client.send('DOM.enable'),
            this.#client.send('CSS.enable'),
            this.#client.send('CSS.startRuleUsageTracking'),
        ]);
    }
    #onExecutionContextsCleared() {
        if (!this.#resetOnNavigation) {
            return;
        }
        this.#stylesheetURLs.clear();
        this.#stylesheetSources.clear();
    }
    async #onStyleSheet(event) {
        const header = event.header;
        // Ignore anonymous scripts
        if (!header.sourceURL) {
            return;
        }
        try {
            const response = await this.#client.send('CSS.getStyleSheetText', {
                styleSheetId: header.styleSheetId,
            });
            this.#stylesheetURLs.set(header.styleSheetId, header.sourceURL);
            this.#stylesheetSources.set(header.styleSheetId, response.text);
        }
        catch (error) {
            // This might happen if the page has already navigated away.
            (0, util_js_1$c.debugError)(error);
        }
    }
    async stop() {
        (0, assert_js_1$d.assert)(this.#enabled, 'CSSCoverage is not enabled');
        this.#enabled = false;
        const ruleTrackingResponse = await this.#client.send('CSS.stopRuleUsageTracking');
        await Promise.all([
            this.#client.send('CSS.disable'),
            this.#client.send('DOM.disable'),
        ]);
        (0, util_js_1$c.removeEventListeners)(this.#eventListeners);
        // aggregate by styleSheetId
        const styleSheetIdToCoverage = new Map();
        for (const entry of ruleTrackingResponse.ruleUsage) {
            let ranges = styleSheetIdToCoverage.get(entry.styleSheetId);
            if (!ranges) {
                ranges = [];
                styleSheetIdToCoverage.set(entry.styleSheetId, ranges);
            }
            ranges.push({
                startOffset: entry.startOffset,
                endOffset: entry.endOffset,
                count: entry.used ? 1 : 0,
            });
        }
        const coverage = [];
        for (const styleSheetId of this.#stylesheetURLs.keys()) {
            const url = this.#stylesheetURLs.get(styleSheetId);
            (0, assert_js_1$d.assert)(typeof url !== 'undefined', `Stylesheet URL is undefined (styleSheetId=${styleSheetId})`);
            const text = this.#stylesheetSources.get(styleSheetId);
            (0, assert_js_1$d.assert)(typeof text !== 'undefined', `Stylesheet text is undefined (styleSheetId=${styleSheetId})`);
            const ranges = convertToDisjointRanges(styleSheetIdToCoverage.get(styleSheetId) || []);
            coverage.push({ url, ranges, text });
        }
        return coverage;
    }
}
Coverage$1.CSSCoverage = CSSCoverage;
function convertToDisjointRanges(nestedRanges) {
    const points = [];
    for (const range of nestedRanges) {
        points.push({ offset: range.startOffset, type: 0, range });
        points.push({ offset: range.endOffset, type: 1, range });
    }
    // Sort points to form a valid parenthesis sequence.
    points.sort((a, b) => {
        // Sort with increasing offsets.
        if (a.offset !== b.offset) {
            return a.offset - b.offset;
        }
        // All "end" points should go before "start" points.
        if (a.type !== b.type) {
            return b.type - a.type;
        }
        const aLength = a.range.endOffset - a.range.startOffset;
        const bLength = b.range.endOffset - b.range.startOffset;
        // For two "start" points, the one with longer range goes first.
        if (a.type === 0) {
            return bLength - aLength;
        }
        // For two "end" points, the one with shorter range goes first.
        return aLength - bLength;
    });
    const hitCountStack = [];
    const results = [];
    let lastOffset = 0;
    // Run scanning line to intersect all ranges.
    for (const point of points) {
        if (hitCountStack.length &&
            lastOffset < point.offset &&
            hitCountStack[hitCountStack.length - 1] > 0) {
            const lastResult = results[results.length - 1];
            if (lastResult && lastResult.end === lastOffset) {
                lastResult.end = point.offset;
            }
            else {
                results.push({ start: lastOffset, end: point.offset });
            }
        }
        lastOffset = point.offset;
        if (point.type === 0) {
            hitCountStack.push(point.range.count);
        }
        else {
            hitCountStack.pop();
        }
    }
    // Filter out empty ranges.
    return results.filter(range => {
        return range.end - range.start > 0;
    });
}

var Dialog$1 = {};

/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(Dialog$1, "__esModule", { value: true });
Dialog$1.CDPDialog = void 0;
const Dialog_js_1$1 = Dialog$3;
/**
 * @internal
 */
class CDPDialog extends Dialog_js_1$1.Dialog {
    #client;
    constructor(client, type, message, defaultValue = '') {
        super(type, message, defaultValue);
        this.#client = client;
    }
    async sendCommand(options) {
        await this.#client.send('Page.handleJavaScriptDialog', {
            accept: options.accept,
            promptText: options.text,
        });
    }
}
Dialog$1.CDPDialog = CDPDialog;

var EmulationManager$2 = {};

var __runInitializers = (commonjsGlobal && commonjsGlobal.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (commonjsGlobal && commonjsGlobal.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __setFunctionName = (commonjsGlobal && commonjsGlobal.__setFunctionName) || function (f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};
Object.defineProperty(EmulationManager$2, "__esModule", { value: true });
EmulationManager$2.EmulationManager = void 0;
const assert_js_1$c = assert$1;
const decorators_js_1 = decorators;
const ErrorLike_js_1$3 = ErrorLike;
const Connection_js_1$7 = Connection$1;
const util_js_1$b = requireUtil();
class EmulatedState {
    #state;
    #clientProvider;
    #updater;
    constructor(initialState, clientProvider, updater) {
        this.#state = initialState;
        this.#clientProvider = clientProvider;
        this.#updater = updater;
    }
    async setState(state) {
        this.#state = state;
        await this.sync();
    }
    async sync() {
        await Promise.all(this.#clientProvider.clients().map(client => {
            return this.#updater(client, this.#state);
        }));
    }
}
/**
 * @internal
 */
let EmulationManager$1 = (() => {
    let _instanceExtraInitializers = [];
    let _private_applyViewport_decorators;
    let _private_applyViewport_descriptor;
    let _private_emulateIdleState_decorators;
    let _private_emulateIdleState_descriptor;
    let _private_emulateTimezone_decorators;
    let _private_emulateTimezone_descriptor;
    let _private_emulateVisionDeficiency_decorators;
    let _private_emulateVisionDeficiency_descriptor;
    let _private_emulateCpuThrottling_decorators;
    let _private_emulateCpuThrottling_descriptor;
    let _private_emulateMediaFeatures_decorators;
    let _private_emulateMediaFeatures_descriptor;
    let _private_emulateMediaType_decorators;
    let _private_emulateMediaType_descriptor;
    let _private_setGeolocation_decorators;
    let _private_setGeolocation_descriptor;
    let _private_setDefaultBackgroundColor_decorators;
    let _private_setDefaultBackgroundColor_descriptor;
    let _private_setJavaScriptEnabled_decorators;
    let _private_setJavaScriptEnabled_descriptor;
    return class EmulationManager {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
            _private_applyViewport_decorators = [decorators_js_1.invokeAtMostOnceForArguments];
            _private_emulateIdleState_decorators = [decorators_js_1.invokeAtMostOnceForArguments];
            _private_emulateTimezone_decorators = [decorators_js_1.invokeAtMostOnceForArguments];
            _private_emulateVisionDeficiency_decorators = [decorators_js_1.invokeAtMostOnceForArguments];
            _private_emulateCpuThrottling_decorators = [decorators_js_1.invokeAtMostOnceForArguments];
            _private_emulateMediaFeatures_decorators = [decorators_js_1.invokeAtMostOnceForArguments];
            _private_emulateMediaType_decorators = [decorators_js_1.invokeAtMostOnceForArguments];
            _private_setGeolocation_decorators = [decorators_js_1.invokeAtMostOnceForArguments];
            _private_setDefaultBackgroundColor_decorators = [decorators_js_1.invokeAtMostOnceForArguments];
            _private_setJavaScriptEnabled_decorators = [decorators_js_1.invokeAtMostOnceForArguments];
            __esDecorate(this, _private_applyViewport_descriptor = { value: __setFunctionName(async function (client, viewportState) {
                    if (!viewportState.viewport) {
                        return;
                    }
                    const { viewport } = viewportState;
                    const mobile = viewport.isMobile || false;
                    const width = viewport.width;
                    const height = viewport.height;
                    const deviceScaleFactor = viewport.deviceScaleFactor ?? 1;
                    const screenOrientation = viewport.isLandscape
                        ? { angle: 90, type: 'landscapePrimary' }
                        : { angle: 0, type: 'portraitPrimary' };
                    const hasTouch = viewport.hasTouch || false;
                    await Promise.all([
                        client.send('Emulation.setDeviceMetricsOverride', {
                            mobile,
                            width,
                            height,
                            deviceScaleFactor,
                            screenOrientation,
                        }),
                        client.send('Emulation.setTouchEmulationEnabled', {
                            enabled: hasTouch,
                        }),
                    ]);
                }, "#applyViewport") }, _private_applyViewport_decorators, { kind: "method", name: "#applyViewport", static: false, private: true, access: { has: obj => #applyViewport in obj, get: obj => obj.#applyViewport }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, _private_emulateIdleState_descriptor = { value: __setFunctionName(async function (client, idleStateState) {
                    if (!idleStateState.active) {
                        return;
                    }
                    if (idleStateState.overrides) {
                        await client.send('Emulation.setIdleOverride', {
                            isUserActive: idleStateState.overrides.isUserActive,
                            isScreenUnlocked: idleStateState.overrides.isScreenUnlocked,
                        });
                    }
                    else {
                        await client.send('Emulation.clearIdleOverride');
                    }
                }, "#emulateIdleState") }, _private_emulateIdleState_decorators, { kind: "method", name: "#emulateIdleState", static: false, private: true, access: { has: obj => #emulateIdleState in obj, get: obj => obj.#emulateIdleState }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, _private_emulateTimezone_descriptor = { value: __setFunctionName(async function (client, timezoneState) {
                    if (!timezoneState.active) {
                        return;
                    }
                    try {
                        await client.send('Emulation.setTimezoneOverride', {
                            timezoneId: timezoneState.timezoneId || '',
                        });
                    }
                    catch (error) {
                        if ((0, ErrorLike_js_1$3.isErrorLike)(error) && error.message.includes('Invalid timezone')) {
                            throw new Error(`Invalid timezone ID: ${timezoneState.timezoneId}`);
                        }
                        throw error;
                    }
                }, "#emulateTimezone") }, _private_emulateTimezone_decorators, { kind: "method", name: "#emulateTimezone", static: false, private: true, access: { has: obj => #emulateTimezone in obj, get: obj => obj.#emulateTimezone }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, _private_emulateVisionDeficiency_descriptor = { value: __setFunctionName(async function (client, visionDeficiency) {
                    if (!visionDeficiency.active) {
                        return;
                    }
                    await client.send('Emulation.setEmulatedVisionDeficiency', {
                        type: visionDeficiency.visionDeficiency || 'none',
                    });
                }, "#emulateVisionDeficiency") }, _private_emulateVisionDeficiency_decorators, { kind: "method", name: "#emulateVisionDeficiency", static: false, private: true, access: { has: obj => #emulateVisionDeficiency in obj, get: obj => obj.#emulateVisionDeficiency }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, _private_emulateCpuThrottling_descriptor = { value: __setFunctionName(async function (client, state) {
                    if (!state.active) {
                        return;
                    }
                    await client.send('Emulation.setCPUThrottlingRate', {
                        rate: state.factor ?? 1,
                    });
                }, "#emulateCpuThrottling") }, _private_emulateCpuThrottling_decorators, { kind: "method", name: "#emulateCpuThrottling", static: false, private: true, access: { has: obj => #emulateCpuThrottling in obj, get: obj => obj.#emulateCpuThrottling }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, _private_emulateMediaFeatures_descriptor = { value: __setFunctionName(async function (client, state) {
                    if (!state.active) {
                        return;
                    }
                    await client.send('Emulation.setEmulatedMedia', {
                        features: state.mediaFeatures,
                    });
                }, "#emulateMediaFeatures") }, _private_emulateMediaFeatures_decorators, { kind: "method", name: "#emulateMediaFeatures", static: false, private: true, access: { has: obj => #emulateMediaFeatures in obj, get: obj => obj.#emulateMediaFeatures }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, _private_emulateMediaType_descriptor = { value: __setFunctionName(async function (client, state) {
                    if (!state.active) {
                        return;
                    }
                    await client.send('Emulation.setEmulatedMedia', {
                        media: state.type || '',
                    });
                }, "#emulateMediaType") }, _private_emulateMediaType_decorators, { kind: "method", name: "#emulateMediaType", static: false, private: true, access: { has: obj => #emulateMediaType in obj, get: obj => obj.#emulateMediaType }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, _private_setGeolocation_descriptor = { value: __setFunctionName(async function (client, state) {
                    if (!state.active) {
                        return;
                    }
                    await client.send('Emulation.setGeolocationOverride', state.geoLocation
                        ? {
                            longitude: state.geoLocation.longitude,
                            latitude: state.geoLocation.latitude,
                            accuracy: state.geoLocation.accuracy,
                        }
                        : undefined);
                }, "#setGeolocation") }, _private_setGeolocation_decorators, { kind: "method", name: "#setGeolocation", static: false, private: true, access: { has: obj => #setGeolocation in obj, get: obj => obj.#setGeolocation }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, _private_setDefaultBackgroundColor_descriptor = { value: __setFunctionName(async function (client, state) {
                    if (!state.active) {
                        return;
                    }
                    await client.send('Emulation.setDefaultBackgroundColorOverride', {
                        color: state.color,
                    });
                }, "#setDefaultBackgroundColor") }, _private_setDefaultBackgroundColor_decorators, { kind: "method", name: "#setDefaultBackgroundColor", static: false, private: true, access: { has: obj => #setDefaultBackgroundColor in obj, get: obj => obj.#setDefaultBackgroundColor }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, _private_setJavaScriptEnabled_descriptor = { value: __setFunctionName(async function (client, state) {
                    if (!state.active) {
                        return;
                    }
                    await client.send('Emulation.setScriptExecutionDisabled', {
                        value: !state.javaScriptEnabled,
                    });
                }, "#setJavaScriptEnabled") }, _private_setJavaScriptEnabled_decorators, { kind: "method", name: "#setJavaScriptEnabled", static: false, private: true, access: { has: obj => #setJavaScriptEnabled in obj, get: obj => obj.#setJavaScriptEnabled }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        #client = (__runInitializers(this, _instanceExtraInitializers), void 0);
        #emulatingMobile = false;
        #hasTouch = false;
        #viewportState = new EmulatedState({
            active: false,
        }, this, this.#applyViewport);
        #idleOverridesState = {
            active: false,
        };
        #timezoneState = {
            active: false,
        };
        #visionDeficiencyState = {
            active: false,
        };
        #cpuThrottlingState = {
            active: false,
        };
        #mediaFeaturesState = {
            active: false,
        };
        #mediaTypeState = {
            active: false,
        };
        #geoLocationState = {
            active: false,
        };
        #defaultBackgroundColorState = {
            active: false,
        };
        #javascriptEnabledState = {
            javaScriptEnabled: true,
            active: false,
        };
        #secondaryClients = new Set();
        constructor(client) {
            this.#client = client;
        }
        updateClient(client) {
            this.#client = client;
            this.#secondaryClients.delete(client);
        }
        async registerSpeculativeSession(client) {
            this.#secondaryClients.add(client);
            client.once(Connection_js_1$7.CDPSessionEmittedEvents.Disconnected, () => {
                return this.#secondaryClients.delete(client);
            });
            // We don't await here because we want to register all state changes before
            // the target is unpaused.
            void this.#viewportState.sync().catch(util_js_1$b.debugError);
            void this.#syncIdleState().catch(util_js_1$b.debugError);
            void this.#syncTimezoneState().catch(util_js_1$b.debugError);
            void this.#syncVisionDeficiencyState().catch(util_js_1$b.debugError);
            void this.#syncCpuThrottlingState().catch(util_js_1$b.debugError);
            void this.#syncMediaFeaturesState().catch(util_js_1$b.debugError);
            void this.#syncMediaTypeState().catch(util_js_1$b.debugError);
            void this.#syncGeoLocationState().catch(util_js_1$b.debugError);
            void this.#syncDefaultBackgroundColorState().catch(util_js_1$b.debugError);
            void this.#syncJavaScriptEnabledState().catch(util_js_1$b.debugError);
        }
        get javascriptEnabled() {
            return this.#javascriptEnabledState.javaScriptEnabled;
        }
        clients() {
            return [this.#client, ...Array.from(this.#secondaryClients)];
        }
        async emulateViewport(viewport) {
            await this.#viewportState.setState({
                viewport,
                active: true,
            });
            const mobile = viewport.isMobile || false;
            const hasTouch = viewport.hasTouch || false;
            const reloadNeeded = this.#emulatingMobile !== mobile || this.#hasTouch !== hasTouch;
            this.#emulatingMobile = mobile;
            this.#hasTouch = hasTouch;
            return reloadNeeded;
        }
        get #applyViewport() { return _private_applyViewport_descriptor.value; }
        async emulateIdleState(overrides) {
            this.#idleOverridesState = {
                active: true,
                overrides,
            };
            await this.#syncIdleState();
        }
        async #syncIdleState() {
            await Promise.all([
                this.#emulateIdleState(this.#client, this.#idleOverridesState),
                ...Array.from(this.#secondaryClients).map(client => {
                    return this.#emulateIdleState(client, this.#idleOverridesState);
                }),
            ]);
        }
        get #emulateIdleState() { return _private_emulateIdleState_descriptor.value; }
        get #emulateTimezone() { return _private_emulateTimezone_descriptor.value; }
        async #syncTimezoneState() {
            await Promise.all([
                this.#emulateTimezone(this.#client, this.#timezoneState),
                ...Array.from(this.#secondaryClients).map(client => {
                    return this.#emulateTimezone(client, this.#timezoneState);
                }),
            ]);
        }
        async emulateTimezone(timezoneId) {
            this.#timezoneState = {
                timezoneId,
                active: true,
            };
            await this.#syncTimezoneState();
        }
        get #emulateVisionDeficiency() { return _private_emulateVisionDeficiency_descriptor.value; }
        async #syncVisionDeficiencyState() {
            await Promise.all([
                this.#emulateVisionDeficiency(this.#client, this.#visionDeficiencyState),
                ...Array.from(this.#secondaryClients).map(client => {
                    return this.#emulateVisionDeficiency(client, this.#visionDeficiencyState);
                }),
            ]);
        }
        async emulateVisionDeficiency(type) {
            const visionDeficiencies = new Set([
                'none',
                'achromatopsia',
                'blurredVision',
                'deuteranopia',
                'protanopia',
                'tritanopia',
            ]);
            (0, assert_js_1$c.assert)(!type || visionDeficiencies.has(type), `Unsupported vision deficiency: ${type}`);
            this.#visionDeficiencyState = {
                active: true,
                visionDeficiency: type,
            };
            await this.#syncVisionDeficiencyState();
        }
        get #emulateCpuThrottling() { return _private_emulateCpuThrottling_descriptor.value; }
        async #syncCpuThrottlingState() {
            await Promise.all([
                this.#emulateCpuThrottling(this.#client, this.#cpuThrottlingState),
                ...Array.from(this.#secondaryClients).map(client => {
                    return this.#emulateCpuThrottling(client, this.#cpuThrottlingState);
                }),
            ]);
        }
        async emulateCPUThrottling(factor) {
            (0, assert_js_1$c.assert)(factor === null || factor >= 1, 'Throttling rate should be greater or equal to 1');
            this.#cpuThrottlingState = {
                active: true,
                factor: factor ?? undefined,
            };
            await this.#syncCpuThrottlingState();
        }
        get #emulateMediaFeatures() { return _private_emulateMediaFeatures_descriptor.value; }
        async #syncMediaFeaturesState() {
            await Promise.all([
                this.#emulateMediaFeatures(this.#client, this.#mediaFeaturesState),
                ...Array.from(this.#secondaryClients).map(client => {
                    return this.#emulateMediaFeatures(client, this.#mediaFeaturesState);
                }),
            ]);
        }
        async emulateMediaFeatures(features) {
            if (Array.isArray(features)) {
                for (const mediaFeature of features) {
                    const name = mediaFeature.name;
                    (0, assert_js_1$c.assert)(/^(?:prefers-(?:color-scheme|reduced-motion)|color-gamut)$/.test(name), 'Unsupported media feature: ' + name);
                }
            }
            this.#mediaFeaturesState = {
                active: true,
                mediaFeatures: features,
            };
            await this.#syncMediaFeaturesState();
        }
        get #emulateMediaType() { return _private_emulateMediaType_descriptor.value; }
        async #syncMediaTypeState() {
            await Promise.all([
                this.#emulateMediaType(this.#client, this.#mediaTypeState),
                ...Array.from(this.#secondaryClients).map(client => {
                    return this.#emulateMediaType(client, this.#mediaTypeState);
                }),
            ]);
        }
        async emulateMediaType(type) {
            (0, assert_js_1$c.assert)(type === 'screen' ||
                type === 'print' ||
                (type ?? undefined) === undefined, 'Unsupported media type: ' + type);
            this.#mediaTypeState = {
                type,
                active: true,
            };
            await this.#syncMediaTypeState();
        }
        get #setGeolocation() { return _private_setGeolocation_descriptor.value; }
        async #syncGeoLocationState() {
            await Promise.all([
                this.#setGeolocation(this.#client, this.#geoLocationState),
                ...Array.from(this.#secondaryClients).map(client => {
                    return this.#setGeolocation(client, this.#geoLocationState);
                }),
            ]);
        }
        async setGeolocation(options) {
            const { longitude, latitude, accuracy = 0 } = options;
            if (longitude < -180 || longitude > 180) {
                throw new Error(`Invalid longitude "${longitude}": precondition -180 <= LONGITUDE <= 180 failed.`);
            }
            if (latitude < -90 || latitude > 90) {
                throw new Error(`Invalid latitude "${latitude}": precondition -90 <= LATITUDE <= 90 failed.`);
            }
            if (accuracy < 0) {
                throw new Error(`Invalid accuracy "${accuracy}": precondition 0 <= ACCURACY failed.`);
            }
            this.#geoLocationState = {
                active: true,
                geoLocation: {
                    longitude,
                    latitude,
                    accuracy,
                },
            };
            await this.#syncGeoLocationState();
        }
        get #setDefaultBackgroundColor() { return _private_setDefaultBackgroundColor_descriptor.value; }
        async #syncDefaultBackgroundColorState() {
            await Promise.all([
                this.#setDefaultBackgroundColor(this.#client, this.#defaultBackgroundColorState),
                ...Array.from(this.#secondaryClients).map(client => {
                    return this.#setDefaultBackgroundColor(client, this.#defaultBackgroundColorState);
                }),
            ]);
        }
        /**
         * Resets default white background
         */
        async resetDefaultBackgroundColor() {
            this.#defaultBackgroundColorState = {
                active: true,
                color: undefined,
            };
            await this.#syncDefaultBackgroundColorState();
        }
        /**
         * Hides default white background
         */
        async setTransparentBackgroundColor() {
            this.#defaultBackgroundColorState = {
                active: true,
                color: { r: 0, g: 0, b: 0, a: 0 },
            };
            await this.#syncDefaultBackgroundColorState();
        }
        get #setJavaScriptEnabled() { return _private_setJavaScriptEnabled_descriptor.value; }
        async #syncJavaScriptEnabledState() {
            await Promise.all([
                this.#setJavaScriptEnabled(this.#client, this.#javascriptEnabledState),
                ...Array.from(this.#secondaryClients).map(client => {
                    return this.#setJavaScriptEnabled(client, this.#javascriptEnabledState);
                }),
            ]);
        }
        async setJavaScriptEnabled(enabled) {
            this.#javascriptEnabledState = {
                active: true,
                javaScriptEnabled: enabled,
            };
            await this.#syncJavaScriptEnabledState();
        }
    };
})();
EmulationManager$2.EmulationManager = EmulationManager$1;

var FileChooser$1 = {};

/**
 * Copyright 2020 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(FileChooser$1, "__esModule", { value: true });
FileChooser$1.FileChooser = void 0;
const assert_js_1$b = assert$1;
/**
 * File choosers let you react to the page requesting for a file.
 *
 * @remarks
 * `FileChooser` instances are returned via the {@link Page.waitForFileChooser} method.
 *
 * In browsers, only one file chooser can be opened at a time.
 * All file choosers must be accepted or canceled. Not doing so will prevent
 * subsequent file choosers from appearing.
 *
 * @example
 *
 * ```ts
 * const [fileChooser] = await Promise.all([
 *   page.waitForFileChooser(),
 *   page.click('#upload-file-button'), // some button that triggers file selection
 * ]);
 * await fileChooser.accept(['/tmp/myfile.pdf']);
 * ```
 *
 * @public
 */
class FileChooser {
    #element;
    #multiple;
    #handled = false;
    /**
     * @internal
     */
    constructor(element, event) {
        this.#element = element;
        this.#multiple = event.mode !== 'selectSingle';
    }
    /**
     * Whether file chooser allow for
     * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file#attr-multiple | multiple}
     * file selection.
     */
    isMultiple() {
        return this.#multiple;
    }
    /**
     * Accept the file chooser request with the given file paths.
     *
     * @remarks This will not validate whether the file paths exists. Also, if a
     * path is relative, then it is resolved against the
     * {@link https://nodejs.org/api/process.html#process_process_cwd | current working directory}.
     * For locals script connecting to remote chrome environments, paths must be
     * absolute.
     */
    async accept(paths) {
        (0, assert_js_1$b.assert)(!this.#handled, 'Cannot accept FileChooser which is already handled!');
        this.#handled = true;
        await this.#element.uploadFile(...paths);
    }
    /**
     * Closes the file chooser without selecting any files.
     */
    cancel() {
        (0, assert_js_1$b.assert)(!this.#handled, 'Cannot cancel FileChooser which is already handled!');
        this.#handled = true;
    }
}
FileChooser$1.FileChooser = FileChooser;

var FrameManager = {};

var DeviceRequestPrompt$1 = {};

/**
 * Copyright 2022 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(DeviceRequestPrompt$1, "__esModule", { value: true });
DeviceRequestPrompt$1.DeviceRequestPromptManager = DeviceRequestPrompt$1.DeviceRequestPrompt = DeviceRequestPrompt$1.DeviceRequestPromptDevice = void 0;
const assert_js_1$a = assert$1;
const Deferred_js_1$7 = Deferred$1;
/**
 * Device in a request prompt.
 *
 * @public
 */
class DeviceRequestPromptDevice {
    /**
     * Device id during a prompt.
     */
    id;
    /**
     * Device name as it appears in a prompt.
     */
    name;
    /**
     * @internal
     */
    constructor(id, name) {
        this.id = id;
        this.name = name;
    }
}
DeviceRequestPrompt$1.DeviceRequestPromptDevice = DeviceRequestPromptDevice;
/**
 * Device request prompts let you respond to the page requesting for a device
 * through an API like WebBluetooth.
 *
 * @remarks
 * `DeviceRequestPrompt` instances are returned via the
 * {@link Page.waitForDevicePrompt} method.
 *
 * @example
 *
 * ```ts
 * const [deviceRequest] = Promise.all([
 *   page.waitForDevicePrompt(),
 *   page.click('#connect-bluetooth'),
 * ]);
 * await devicePrompt.select(
 *   await devicePrompt.waitForDevice(({name}) => name.includes('My Device'))
 * );
 * ```
 *
 * @public
 */
class DeviceRequestPrompt {
    #client;
    #timeoutSettings;
    #id;
    #handled = false;
    #updateDevicesHandle = this.#updateDevices.bind(this);
    #waitForDevicePromises = new Set();
    /**
     * Current list of selectable devices.
     */
    devices = [];
    /**
     * @internal
     */
    constructor(client, timeoutSettings, firstEvent) {
        this.#client = client;
        this.#timeoutSettings = timeoutSettings;
        this.#id = firstEvent.id;
        this.#client.on('DeviceAccess.deviceRequestPrompted', this.#updateDevicesHandle);
        this.#client.on('Target.detachedFromTarget', () => {
            this.#client = null;
        });
        this.#updateDevices(firstEvent);
    }
    #updateDevices(event) {
        if (event.id !== this.#id) {
            return;
        }
        for (const rawDevice of event.devices) {
            if (this.devices.some(device => {
                return device.id === rawDevice.id;
            })) {
                continue;
            }
            const newDevice = new DeviceRequestPromptDevice(rawDevice.id, rawDevice.name);
            this.devices.push(newDevice);
            for (const waitForDevicePromise of this.#waitForDevicePromises) {
                if (waitForDevicePromise.filter(newDevice)) {
                    waitForDevicePromise.promise.resolve(newDevice);
                }
            }
        }
    }
    /**
     * Resolve to the first device in the prompt matching a filter.
     */
    async waitForDevice(filter, options = {}) {
        for (const device of this.devices) {
            if (filter(device)) {
                return device;
            }
        }
        const { timeout = this.#timeoutSettings.timeout() } = options;
        const deferred = Deferred_js_1$7.Deferred.create({
            message: `Waiting for \`DeviceRequestPromptDevice\` failed: ${timeout}ms exceeded`,
            timeout,
        });
        const handle = { filter, promise: deferred };
        this.#waitForDevicePromises.add(handle);
        try {
            return await deferred.valueOrThrow();
        }
        finally {
            this.#waitForDevicePromises.delete(handle);
        }
    }
    /**
     * Select a device in the prompt's list.
     */
    async select(device) {
        (0, assert_js_1$a.assert)(this.#client !== null, 'Cannot select device through detached session!');
        (0, assert_js_1$a.assert)(this.devices.includes(device), 'Cannot select unknown device!');
        (0, assert_js_1$a.assert)(!this.#handled, 'Cannot select DeviceRequestPrompt which is already handled!');
        this.#client.off('DeviceAccess.deviceRequestPrompted', this.#updateDevicesHandle);
        this.#handled = true;
        return await this.#client.send('DeviceAccess.selectPrompt', {
            id: this.#id,
            deviceId: device.id,
        });
    }
    /**
     * Cancel the prompt.
     */
    async cancel() {
        (0, assert_js_1$a.assert)(this.#client !== null, 'Cannot cancel prompt through detached session!');
        (0, assert_js_1$a.assert)(!this.#handled, 'Cannot cancel DeviceRequestPrompt which is already handled!');
        this.#client.off('DeviceAccess.deviceRequestPrompted', this.#updateDevicesHandle);
        this.#handled = true;
        return await this.#client.send('DeviceAccess.cancelPrompt', { id: this.#id });
    }
}
DeviceRequestPrompt$1.DeviceRequestPrompt = DeviceRequestPrompt;
/**
 * @internal
 */
class DeviceRequestPromptManager {
    #client;
    #timeoutSettings;
    #deviceRequestPrompDeferreds = new Set();
    /**
     * @internal
     */
    constructor(client, timeoutSettings) {
        this.#client = client;
        this.#timeoutSettings = timeoutSettings;
        this.#client.on('DeviceAccess.deviceRequestPrompted', event => {
            this.#onDeviceRequestPrompted(event);
        });
        this.#client.on('Target.detachedFromTarget', () => {
            this.#client = null;
        });
    }
    /**
     * Wait for device prompt created by an action like calling WebBluetooth's
     * requestDevice.
     */
    async waitForDevicePrompt(options = {}) {
        (0, assert_js_1$a.assert)(this.#client !== null, 'Cannot wait for device prompt through detached session!');
        const needsEnable = this.#deviceRequestPrompDeferreds.size === 0;
        let enablePromise;
        if (needsEnable) {
            enablePromise = this.#client.send('DeviceAccess.enable');
        }
        const { timeout = this.#timeoutSettings.timeout() } = options;
        const deferred = Deferred_js_1$7.Deferred.create({
            message: `Waiting for \`DeviceRequestPrompt\` failed: ${timeout}ms exceeded`,
            timeout,
        });
        this.#deviceRequestPrompDeferreds.add(deferred);
        try {
            const [result] = await Promise.all([
                deferred.valueOrThrow(),
                enablePromise,
            ]);
            return result;
        }
        finally {
            this.#deviceRequestPrompDeferreds.delete(deferred);
        }
    }
    /**
     * @internal
     */
    #onDeviceRequestPrompted(event) {
        if (!this.#deviceRequestPrompDeferreds.size) {
            return;
        }
        (0, assert_js_1$a.assert)(this.#client !== null);
        const devicePrompt = new DeviceRequestPrompt(this.#client, this.#timeoutSettings, event);
        for (const promise of this.#deviceRequestPrompDeferreds) {
            promise.resolve(devicePrompt);
        }
        this.#deviceRequestPrompDeferreds.clear();
    }
}
DeviceRequestPrompt$1.DeviceRequestPromptManager = DeviceRequestPromptManager;

var ExecutionContext$1 = {};

/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(ExecutionContext$1, "__esModule", { value: true });
ExecutionContext$1.ExecutionContext = void 0;
const AsyncIterableUtil_js_1 = AsyncIterableUtil$1;
const Function_js_1 = _Function;
const AriaQueryHandler_js_1 = requireAriaQueryHandler();
const Binding_js_1$1 = Binding$1;
const ElementHandle_js_1 = requireElementHandle$1();
const JSHandle_js_1$1 = requireJSHandle$1();
const LazyArg_js_1 = LazyArg$1;
const ScriptInjector_js_1 = ScriptInjector$1;
const util_js_1$a = requireUtil();
const SOURCE_URL_REGEX = /^[\040\t]*\/\/[@#] sourceURL=\s*(\S*?)\s*$/m;
const getSourceUrlComment = (url) => {
    return `//# sourceURL=${url}`;
};
/**
 * Represents a context for JavaScript execution.
 *
 * @example
 * A {@link Page} can have several execution contexts:
 *
 * - Each {@link Frame} of a {@link Page | page} has a "default" execution
 *   context that is always created after frame is attached to DOM. This context
 *   is returned by the {@link Frame.realm} method.
 * - Each {@link https://developer.chrome.com/extensions | Chrome extensions}
 *   creates additional execution contexts to isolate their code.
 *
 * @remarks
 * By definition, each context is isolated from one another, however they are
 * all able to manipulate non-JavaScript resources (such as DOM).
 *
 * @remarks
 * Besides pages, execution contexts can be found in
 * {@link WebWorker | workers}.
 *
 * @internal
 */
class ExecutionContext {
    _client;
    _world;
    _contextId;
    _contextName;
    constructor(client, contextPayload, world) {
        this._client = client;
        this._world = world;
        this._contextId = contextPayload.id;
        if (contextPayload.name) {
            this._contextName = contextPayload.name;
        }
    }
    #bindingsInstalled = false;
    #puppeteerUtil;
    get puppeteerUtil() {
        let promise = Promise.resolve();
        if (!this.#bindingsInstalled) {
            promise = Promise.all([
                this.#installGlobalBinding(new Binding_js_1$1.Binding('__ariaQuerySelector', AriaQueryHandler_js_1.ARIAQueryHandler.queryOne)),
                this.#installGlobalBinding(new Binding_js_1$1.Binding('__ariaQuerySelectorAll', (async (element, selector) => {
                    const results = AriaQueryHandler_js_1.ARIAQueryHandler.queryAll(element, selector);
                    return await element.realm.evaluateHandle((...elements) => {
                        return elements;
                    }, ...(await AsyncIterableUtil_js_1.AsyncIterableUtil.collect(results)));
                }))),
            ]);
            this.#bindingsInstalled = true;
        }
        ScriptInjector_js_1.scriptInjector.inject(script => {
            if (this.#puppeteerUtil) {
                void this.#puppeteerUtil.then(handle => {
                    void handle.dispose();
                });
            }
            this.#puppeteerUtil = promise.then(() => {
                return this.evaluateHandle(script);
            });
        }, !this.#puppeteerUtil);
        return this.#puppeteerUtil;
    }
    async #installGlobalBinding(binding) {
        try {
            if (this._world) {
                this._world._bindings.set(binding.name, binding);
                await this._world._addBindingToContext(this, binding.name);
            }
        }
        catch {
            // If the binding cannot be added, then either the browser doesn't support
            // bindings (e.g. Firefox) or the context is broken. Either breakage is
            // okay, so we ignore the error.
        }
    }
    /**
     * Evaluates the given function.
     *
     * @example
     *
     * ```ts
     * const executionContext = await page.mainFrame().executionContext();
     * const result = await executionContext.evaluate(() => Promise.resolve(8 * 7))* ;
     * console.log(result); // prints "56"
     * ```
     *
     * @example
     * A string can also be passed in instead of a function:
     *
     * ```ts
     * console.log(await executionContext.evaluate('1 + 2')); // prints "3"
     * ```
     *
     * @example
     * Handles can also be passed as `args`. They resolve to their referenced object:
     *
     * ```ts
     * const oneHandle = await executionContext.evaluateHandle(() => 1);
     * const twoHandle = await executionContext.evaluateHandle(() => 2);
     * const result = await executionContext.evaluate(
     *   (a, b) => a + b,
     *   oneHandle,
     *   twoHandle
     * );
     * await oneHandle.dispose();
     * await twoHandle.dispose();
     * console.log(result); // prints '3'.
     * ```
     *
     * @param pageFunction - The function to evaluate.
     * @param args - Additional arguments to pass into the function.
     * @returns The result of evaluating the function. If the result is an object,
     * a vanilla object containing the serializable properties of the result is
     * returned.
     */
    async evaluate(pageFunction, ...args) {
        return await this.#evaluate(true, pageFunction, ...args);
    }
    /**
     * Evaluates the given function.
     *
     * Unlike {@link ExecutionContext.evaluate | evaluate}, this method returns a
     * handle to the result of the function.
     *
     * This method may be better suited if the object cannot be serialized (e.g.
     * `Map`) and requires further manipulation.
     *
     * @example
     *
     * ```ts
     * const context = await page.mainFrame().executionContext();
     * const handle: JSHandle<typeof globalThis> = await context.evaluateHandle(
     *   () => Promise.resolve(self)
     * );
     * ```
     *
     * @example
     * A string can also be passed in instead of a function.
     *
     * ```ts
     * const handle: JSHandle<number> = await context.evaluateHandle('1 + 2');
     * ```
     *
     * @example
     * Handles can also be passed as `args`. They resolve to their referenced object:
     *
     * ```ts
     * const bodyHandle: ElementHandle<HTMLBodyElement> =
     *   await context.evaluateHandle(() => {
     *     return document.body;
     *   });
     * const stringHandle: JSHandle<string> = await context.evaluateHandle(
     *   body => body.innerHTML,
     *   body
     * );
     * console.log(await stringHandle.jsonValue()); // prints body's innerHTML
     * // Always dispose your garbage! :)
     * await bodyHandle.dispose();
     * await stringHandle.dispose();
     * ```
     *
     * @param pageFunction - The function to evaluate.
     * @param args - Additional arguments to pass into the function.
     * @returns A {@link JSHandle | handle} to the result of evaluating the
     * function. If the result is a `Node`, then this will return an
     * {@link ElementHandle | element handle}.
     */
    async evaluateHandle(pageFunction, ...args) {
        return await this.#evaluate(false, pageFunction, ...args);
    }
    async #evaluate(returnByValue, pageFunction, ...args) {
        const sourceUrlComment = getSourceUrlComment((0, util_js_1$a.getSourcePuppeteerURLIfAvailable)(pageFunction)?.toString() ??
            util_js_1$a.PuppeteerURL.INTERNAL_URL);
        if ((0, util_js_1$a.isString)(pageFunction)) {
            const contextId = this._contextId;
            const expression = pageFunction;
            const expressionWithSourceUrl = SOURCE_URL_REGEX.test(expression)
                ? expression
                : `${expression}\n${sourceUrlComment}\n`;
            const { exceptionDetails, result: remoteObject } = await this._client
                .send('Runtime.evaluate', {
                expression: expressionWithSourceUrl,
                contextId,
                returnByValue,
                awaitPromise: true,
                userGesture: true,
            })
                .catch(rewriteError);
            if (exceptionDetails) {
                throw (0, util_js_1$a.createEvaluationError)(exceptionDetails);
            }
            return returnByValue
                ? (0, util_js_1$a.valueFromRemoteObject)(remoteObject)
                : (0, util_js_1$a.createCdpHandle)(this._world, remoteObject);
        }
        const functionDeclaration = (0, Function_js_1.stringifyFunction)(pageFunction);
        const functionDeclarationWithSourceUrl = SOURCE_URL_REGEX.test(functionDeclaration)
            ? functionDeclaration
            : `${functionDeclaration}\n${sourceUrlComment}\n`;
        let callFunctionOnPromise;
        try {
            callFunctionOnPromise = this._client.send('Runtime.callFunctionOn', {
                functionDeclaration: functionDeclarationWithSourceUrl,
                executionContextId: this._contextId,
                arguments: await Promise.all(args.map(convertArgument.bind(this))),
                returnByValue,
                awaitPromise: true,
                userGesture: true,
            });
        }
        catch (error) {
            if (error instanceof TypeError &&
                error.message.startsWith('Converting circular structure to JSON')) {
                error.message += ' Recursive objects are not allowed.';
            }
            throw error;
        }
        const { exceptionDetails, result: remoteObject } = await callFunctionOnPromise.catch(rewriteError);
        if (exceptionDetails) {
            throw (0, util_js_1$a.createEvaluationError)(exceptionDetails);
        }
        return returnByValue
            ? (0, util_js_1$a.valueFromRemoteObject)(remoteObject)
            : (0, util_js_1$a.createCdpHandle)(this._world, remoteObject);
        async function convertArgument(arg) {
            if (arg instanceof LazyArg_js_1.LazyArg) {
                arg = await arg.get(this);
            }
            if (typeof arg === 'bigint') {
                // eslint-disable-line valid-typeof
                return { unserializableValue: `${arg.toString()}n` };
            }
            if (Object.is(arg, -0)) {
                return { unserializableValue: '-0' };
            }
            if (Object.is(arg, Infinity)) {
                return { unserializableValue: 'Infinity' };
            }
            if (Object.is(arg, -Infinity)) {
                return { unserializableValue: '-Infinity' };
            }
            if (Object.is(arg, NaN)) {
                return { unserializableValue: 'NaN' };
            }
            const objectHandle = arg && (arg instanceof JSHandle_js_1$1.CDPJSHandle || arg instanceof ElementHandle_js_1.CDPElementHandle)
                ? arg
                : null;
            if (objectHandle) {
                if (objectHandle.realm !== this._world) {
                    throw new Error('JSHandles can be evaluated only in the context they were created!');
                }
                if (objectHandle.disposed) {
                    throw new Error('JSHandle is disposed!');
                }
                if (objectHandle.remoteObject().unserializableValue) {
                    return {
                        unserializableValue: objectHandle.remoteObject().unserializableValue,
                    };
                }
                if (!objectHandle.remoteObject().objectId) {
                    return { value: objectHandle.remoteObject().value };
                }
                return { objectId: objectHandle.remoteObject().objectId };
            }
            return { value: arg };
        }
    }
}
ExecutionContext$1.ExecutionContext = ExecutionContext;
const rewriteError = (error) => {
    if (error.message.includes('Object reference chain is too long')) {
        return { result: { type: 'undefined' } };
    }
    if (error.message.includes("Object couldn't be returned by value")) {
        return { result: { type: 'undefined' } };
    }
    if (error.message.endsWith('Cannot find context with specified id') ||
        error.message.endsWith('Inspected target navigated or closed')) {
        throw new Error('Execution context was destroyed, most likely because of a navigation.');
    }
    throw error;
};

var Frame$1 = {};

var IsolatedWorld = {};

var IsolatedWorlds = {};

/**
 * Copyright 2022 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(IsolatedWorlds, "__esModule", { value: true });
IsolatedWorlds.PUPPETEER_WORLD = IsolatedWorlds.MAIN_WORLD = void 0;
/**
 * A unique key for {@link IsolatedWorldChart} to denote the default world.
 * Execution contexts are automatically created in the default world.
 *
 * @internal
 */
IsolatedWorlds.MAIN_WORLD = Symbol('mainWorld');
/**
 * A unique key for {@link IsolatedWorldChart} to denote the puppeteer world.
 * This world contains all puppeteer-internal bindings/code.
 *
 * @internal
 */
IsolatedWorlds.PUPPETEER_WORLD = Symbol('puppeteerWorld');

var hasRequiredIsolatedWorld;

function requireIsolatedWorld () {
	if (hasRequiredIsolatedWorld) return IsolatedWorld;
	hasRequiredIsolatedWorld = 1;
	/**
	 * Copyright 2019 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var __addDisposableResource = (commonjsGlobal && commonjsGlobal.__addDisposableResource) || function (env, value, async) {
	    if (value !== null && value !== void 0) {
	        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
	        var dispose;
	        if (async) {
	            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
	            dispose = value[Symbol.asyncDispose];
	        }
	        if (dispose === void 0) {
	            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
	            dispose = value[Symbol.dispose];
	        }
	        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
	        env.stack.push({ value: value, dispose: dispose, async: async });
	    }
	    else if (async) {
	        env.stack.push({ async: true });
	    }
	    return value;
	};
	var __disposeResources = (commonjsGlobal && commonjsGlobal.__disposeResources) || (function (SuppressedError) {
	    return function (env) {
	        function fail(e) {
	            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
	            env.hasError = true;
	        }
	        function next() {
	            while (env.stack.length) {
	                var rec = env.stack.pop();
	                try {
	                    var result = rec.dispose && rec.dispose.call(rec.value);
	                    if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
	                }
	                catch (e) {
	                    fail(e);
	                }
	            }
	            if (env.hasError) throw env.error;
	        }
	        return next();
	    };
	})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
	    var e = new Error(message);
	    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
	});
	Object.defineProperty(IsolatedWorld, "__esModule", { value: true });
	IsolatedWorld.IsolatedWorld = void 0;
	const Realm_js_1 = Realm$2;
	const Deferred_js_1 = Deferred$1;
	const Frame_js_1 = requireFrame$1();
	const util_js_1 = requireUtil();
	/**
	 * @internal
	 */
	let IsolatedWorld$1 = class IsolatedWorld extends Realm_js_1.Realm {
	    #context = Deferred_js_1.Deferred.create();
	    // Set of bindings that have been registered in the current context.
	    #contextBindings = new Set();
	    // Contains mapping from functions that should be bound to Puppeteer functions.
	    #bindings = new Map();
	    get _bindings() {
	        return this.#bindings;
	    }
	    #frameOrWorker;
	    constructor(frameOrWorker, timeoutSettings) {
	        super(timeoutSettings);
	        this.#frameOrWorker = frameOrWorker;
	        this.frameUpdated();
	    }
	    get environment() {
	        return this.#frameOrWorker;
	    }
	    frameUpdated() {
	        this.client.on('Runtime.bindingCalled', this.#onBindingCalled);
	    }
	    get client() {
	        return this.#frameOrWorker.client;
	    }
	    clearContext() {
	        this.#context = Deferred_js_1.Deferred.create();
	        if (this.#frameOrWorker instanceof Frame_js_1.CDPFrame) {
	            this.#frameOrWorker.clearDocumentHandle();
	        }
	    }
	    setContext(context) {
	        this.#contextBindings.clear();
	        this.#context.resolve(context);
	        void this.taskManager.rerunAll();
	    }
	    hasContext() {
	        return this.#context.resolved();
	    }
	    #executionContext() {
	        if (this.disposed) {
	            throw new Error(`Execution context is not available in detached frame "${this.environment.url()}" (are you trying to evaluate?)`);
	        }
	        if (this.#context === null) {
	            throw new Error(`Execution content promise is missing`);
	        }
	        return this.#context.valueOrThrow();
	    }
	    async evaluateHandle(pageFunction, ...args) {
	        pageFunction = (0, util_js_1.withSourcePuppeteerURLIfNone)(this.evaluateHandle.name, pageFunction);
	        const context = await this.#executionContext();
	        return await context.evaluateHandle(pageFunction, ...args);
	    }
	    async evaluate(pageFunction, ...args) {
	        pageFunction = (0, util_js_1.withSourcePuppeteerURLIfNone)(this.evaluate.name, pageFunction);
	        const context = await this.#executionContext();
	        return await context.evaluate(pageFunction, ...args);
	    }
	    // If multiple waitFor are set up asynchronously, we need to wait for the
	    // first one to set up the binding in the page before running the others.
	    #mutex = new util_js_1.Mutex();
	    async _addBindingToContext(context, name) {
	        const env_1 = { stack: [], error: void 0, hasError: false };
	        try {
	            if (this.#contextBindings.has(name)) {
	                return;
	            }
	            // eslint-disable-next-line @typescript-eslint/no-unused-vars
	            const _ = __addDisposableResource(env_1, await this.#mutex.acquire(), false);
	            try {
	                await context._client.send('Runtime.addBinding', context._contextName
	                    ? {
	                        name,
	                        executionContextName: context._contextName,
	                    }
	                    : {
	                        name,
	                        executionContextId: context._contextId,
	                    });
	                await context.evaluate(util_js_1.addPageBinding, 'internal', name);
	                this.#contextBindings.add(name);
	            }
	            catch (error) {
	                // We could have tried to evaluate in a context which was already
	                // destroyed. This happens, for example, if the page is navigated while
	                // we are trying to add the binding
	                if (error instanceof Error) {
	                    // Destroyed context.
	                    if (error.message.includes('Execution context was destroyed')) {
	                        return;
	                    }
	                    // Missing context.
	                    if (error.message.includes('Cannot find context with specified id')) {
	                        return;
	                    }
	                }
	                (0, util_js_1.debugError)(error);
	            }
	        }
	        catch (e_1) {
	            env_1.error = e_1;
	            env_1.hasError = true;
	        }
	        finally {
	            __disposeResources(env_1);
	        }
	    }
	    #onBindingCalled = async (event) => {
	        let payload;
	        try {
	            payload = JSON.parse(event.payload);
	        }
	        catch {
	            // The binding was either called by something in the page or it was
	            // called before our wrapper was initialized.
	            return;
	        }
	        const { type, name, seq, args, isTrivial } = payload;
	        if (type !== 'internal') {
	            return;
	        }
	        if (!this.#contextBindings.has(name)) {
	            return;
	        }
	        try {
	            const context = await this.#context.valueOrThrow();
	            if (event.executionContextId !== context._contextId) {
	                return;
	            }
	            const binding = this._bindings.get(name);
	            await binding?.run(context, seq, args, isTrivial);
	        }
	        catch (err) {
	            (0, util_js_1.debugError)(err);
	        }
	    };
	    async adoptBackendNode(backendNodeId) {
	        const executionContext = await this.#executionContext();
	        const { object } = await this.client.send('DOM.resolveNode', {
	            backendNodeId: backendNodeId,
	            executionContextId: executionContext._contextId,
	        });
	        return (0, util_js_1.createCdpHandle)(this, object);
	    }
	    async adoptHandle(handle) {
	        if (handle.realm === this) {
	            // If the context has already adopted this handle, clone it so downstream
	            // disposal doesn't become an issue.
	            return (await handle.evaluateHandle(value => {
	                return value;
	            }));
	        }
	        const nodeInfo = await this.client.send('DOM.describeNode', {
	            objectId: handle.id,
	        });
	        return (await this.adoptBackendNode(nodeInfo.node.backendNodeId));
	    }
	    async transferHandle(handle) {
	        if (handle.realm === this) {
	            return handle;
	        }
	        // Implies it's a primitive value, probably.
	        if (handle.remoteObject().objectId === undefined) {
	            return handle;
	        }
	        const info = await this.client.send('DOM.describeNode', {
	            objectId: handle.remoteObject().objectId,
	        });
	        const newHandle = (await this.adoptBackendNode(info.node.backendNodeId));
	        await handle.dispose();
	        return newHandle;
	    }
	    [Symbol.dispose]() {
	        super[Symbol.dispose]();
	        this.client.off('Runtime.bindingCalled', this.#onBindingCalled);
	    }
	};
	IsolatedWorld.IsolatedWorld = IsolatedWorld$1;
	
	return IsolatedWorld;
}

var LifecycleWatcher = {};

var hasRequiredLifecycleWatcher;

function requireLifecycleWatcher () {
	if (hasRequiredLifecycleWatcher) return LifecycleWatcher;
	hasRequiredLifecycleWatcher = 1;
	/**
	 * Copyright 2019 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(LifecycleWatcher, "__esModule", { value: true });
	LifecycleWatcher.LifecycleWatcher = void 0;
	const assert_js_1 = assert$1;
	const Deferred_js_1 = Deferred$1;
	const Frame_js_1 = requireFrame$1();
	const FrameManager_js_1 = requireFrameManager();
	const NetworkManager_js_1 = NetworkManager$1;
	const util_js_1 = requireUtil();
	const puppeteerToProtocolLifecycle = new Map([
	    ['load', 'load'],
	    ['domcontentloaded', 'DOMContentLoaded'],
	    ['networkidle0', 'networkIdle'],
	    ['networkidle2', 'networkAlmostIdle'],
	]);
	/**
	 * @internal
	 */
	let LifecycleWatcher$1 = class LifecycleWatcher {
	    #expectedLifecycle;
	    #frame;
	    #timeout;
	    #navigationRequest = null;
	    #eventListeners;
	    #initialLoaderId;
	    #terminationDeferred;
	    #sameDocumentNavigationDeferred = Deferred_js_1.Deferred.create();
	    #lifecycleDeferred = Deferred_js_1.Deferred.create();
	    #newDocumentNavigationDeferred = Deferred_js_1.Deferred.create();
	    #hasSameDocumentNavigation;
	    #swapped;
	    #navigationResponseReceived;
	    constructor(networkManager, frame, waitUntil, timeout) {
	        if (Array.isArray(waitUntil)) {
	            waitUntil = waitUntil.slice();
	        }
	        else if (typeof waitUntil === 'string') {
	            waitUntil = [waitUntil];
	        }
	        this.#initialLoaderId = frame._loaderId;
	        this.#expectedLifecycle = waitUntil.map(value => {
	            const protocolEvent = puppeteerToProtocolLifecycle.get(value);
	            (0, assert_js_1.assert)(protocolEvent, 'Unknown value for options.waitUntil: ' + value);
	            return protocolEvent;
	        });
	        this.#frame = frame;
	        this.#timeout = timeout;
	        this.#eventListeners = [
	            (0, util_js_1.addEventListener)(
	            // Revert if TODO #1 is done
	            frame._frameManager, FrameManager_js_1.FrameManagerEmittedEvents.LifecycleEvent, this.#checkLifecycleComplete.bind(this)),
	            (0, util_js_1.addEventListener)(frame, Frame_js_1.FrameEmittedEvents.FrameNavigatedWithinDocument, this.#navigatedWithinDocument.bind(this)),
	            (0, util_js_1.addEventListener)(frame, Frame_js_1.FrameEmittedEvents.FrameNavigated, this.#navigated.bind(this)),
	            (0, util_js_1.addEventListener)(frame, Frame_js_1.FrameEmittedEvents.FrameSwapped, this.#frameSwapped.bind(this)),
	            (0, util_js_1.addEventListener)(frame, Frame_js_1.FrameEmittedEvents.FrameSwappedByActivation, this.#frameSwapped.bind(this)),
	            (0, util_js_1.addEventListener)(frame, Frame_js_1.FrameEmittedEvents.FrameDetached, this.#onFrameDetached.bind(this)),
	            (0, util_js_1.addEventListener)(networkManager, NetworkManager_js_1.NetworkManagerEmittedEvents.Request, this.#onRequest.bind(this)),
	            (0, util_js_1.addEventListener)(networkManager, NetworkManager_js_1.NetworkManagerEmittedEvents.Response, this.#onResponse.bind(this)),
	            (0, util_js_1.addEventListener)(networkManager, NetworkManager_js_1.NetworkManagerEmittedEvents.RequestFailed, this.#onRequestFailed.bind(this)),
	        ];
	        this.#terminationDeferred = Deferred_js_1.Deferred.create({
	            timeout: this.#timeout,
	            message: `Navigation timeout of ${this.#timeout} ms exceeded`,
	        });
	        this.#checkLifecycleComplete();
	    }
	    #onRequest(request) {
	        if (request.frame() !== this.#frame || !request.isNavigationRequest()) {
	            return;
	        }
	        this.#navigationRequest = request;
	        // Resolve previous navigation response in case there are multiple
	        // navigation requests reported by the backend. This generally should not
	        // happen by it looks like it's possible.
	        this.#navigationResponseReceived?.resolve();
	        this.#navigationResponseReceived = Deferred_js_1.Deferred.create();
	        if (request.response() !== null) {
	            this.#navigationResponseReceived?.resolve();
	        }
	    }
	    #onRequestFailed(request) {
	        if (this.#navigationRequest?._requestId !== request._requestId) {
	            return;
	        }
	        this.#navigationResponseReceived?.resolve();
	    }
	    #onResponse(response) {
	        if (this.#navigationRequest?._requestId !== response.request()._requestId) {
	            return;
	        }
	        this.#navigationResponseReceived?.resolve();
	    }
	    #onFrameDetached(frame) {
	        if (this.#frame === frame) {
	            this.#terminationDeferred.resolve(new Error('Navigating frame was detached'));
	            return;
	        }
	        this.#checkLifecycleComplete();
	    }
	    async navigationResponse() {
	        // Continue with a possibly null response.
	        await this.#navigationResponseReceived?.valueOrThrow();
	        return this.#navigationRequest ? this.#navigationRequest.response() : null;
	    }
	    sameDocumentNavigationPromise() {
	        return this.#sameDocumentNavigationDeferred.valueOrThrow();
	    }
	    newDocumentNavigationPromise() {
	        return this.#newDocumentNavigationDeferred.valueOrThrow();
	    }
	    lifecyclePromise() {
	        return this.#lifecycleDeferred.valueOrThrow();
	    }
	    terminationPromise() {
	        return this.#terminationDeferred.valueOrThrow();
	    }
	    #navigatedWithinDocument() {
	        this.#hasSameDocumentNavigation = true;
	        this.#checkLifecycleComplete();
	    }
	    #navigated(navigationType) {
	        if (navigationType === 'BackForwardCacheRestore') {
	            return this.#frameSwapped();
	        }
	        this.#checkLifecycleComplete();
	    }
	    #frameSwapped() {
	        this.#swapped = true;
	        this.#checkLifecycleComplete();
	    }
	    #checkLifecycleComplete() {
	        // We expect navigation to commit.
	        if (!checkLifecycle(this.#frame, this.#expectedLifecycle)) {
	            return;
	        }
	        this.#lifecycleDeferred.resolve();
	        if (this.#hasSameDocumentNavigation) {
	            this.#sameDocumentNavigationDeferred.resolve(undefined);
	        }
	        if (this.#swapped || this.#frame._loaderId !== this.#initialLoaderId) {
	            this.#newDocumentNavigationDeferred.resolve(undefined);
	        }
	        function checkLifecycle(frame, expectedLifecycle) {
	            for (const event of expectedLifecycle) {
	                if (!frame._lifecycleEvents.has(event)) {
	                    return false;
	                }
	            }
	            // TODO(#1): Its possible we don't need this check
	            // CDP provided the correct order for Loading Events
	            // And NetworkIdle is a global state
	            // Consider removing
	            for (const child of frame.childFrames()) {
	                if (child._hasStartedLoading &&
	                    !checkLifecycle(child, expectedLifecycle)) {
	                    return false;
	                }
	            }
	            return true;
	        }
	    }
	    dispose() {
	        (0, util_js_1.removeEventListeners)(this.#eventListeners);
	        this.#terminationDeferred.resolve(new Error('LifecycleWatcher disposed'));
	    }
	};
	LifecycleWatcher.LifecycleWatcher = LifecycleWatcher$1;
	
	return LifecycleWatcher;
}

var hasRequiredFrame$1;

function requireFrame$1 () {
	if (hasRequiredFrame$1) return Frame$1;
	hasRequiredFrame$1 = 1;
	(function (exports) {
		/**
		 * Copyright 2017 Google Inc. All rights reserved.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *     http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		var __runInitializers = (commonjsGlobal && commonjsGlobal.__runInitializers) || function (thisArg, initializers, value) {
		    var useValue = arguments.length > 2;
		    for (var i = 0; i < initializers.length; i++) {
		        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
		    }
		    return useValue ? value : void 0;
		};
		var __esDecorate = (commonjsGlobal && commonjsGlobal.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
		    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
		    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
		    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
		    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
		    var _, done = false;
		    for (var i = decorators.length - 1; i >= 0; i--) {
		        var context = {};
		        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
		        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
		        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
		        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
		        if (kind === "accessor") {
		            if (result === void 0) continue;
		            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
		            if (_ = accept(result.get)) descriptor.get = _;
		            if (_ = accept(result.set)) descriptor.set = _;
		            if (_ = accept(result.init)) initializers.unshift(_);
		        }
		        else if (_ = accept(result)) {
		            if (kind === "field") initializers.unshift(_);
		            else descriptor[key] = _;
		        }
		    }
		    if (target) Object.defineProperty(target, contextIn.name, descriptor);
		    done = true;
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.CDPFrame = exports.FrameEmittedEvents = void 0;
		const Frame_js_1 = Frame$2;
		const assert_js_1 = assert$1;
		const Deferred_js_1 = Deferred$1;
		const ErrorLike_js_1 = ErrorLike;
		const IsolatedWorld_js_1 = requireIsolatedWorld();
		const IsolatedWorlds_js_1 = IsolatedWorlds;
		const LifecycleWatcher_js_1 = requireLifecycleWatcher();
		const util_js_1 = requireUtil();
		/**
		 * We use symbols to prevent external parties listening to these events.
		 * They are internal to Puppeteer.
		 *
		 * @internal
		 */
		exports.FrameEmittedEvents = {
		    FrameNavigated: Symbol('Frame.FrameNavigated'),
		    FrameSwapped: Symbol('Frame.FrameSwapped'),
		    LifecycleEvent: Symbol('Frame.LifecycleEvent'),
		    FrameNavigatedWithinDocument: Symbol('Frame.FrameNavigatedWithinDocument'),
		    FrameDetached: Symbol('Frame.FrameDetached'),
		    FrameSwappedByActivation: Symbol('Frame.FrameSwappedByActivation'),
		};
		/**
		 * @internal
		 */
		let CDPFrame = (() => {
		    let _classSuper = Frame_js_1.Frame;
		    let _instanceExtraInitializers = [];
		    let _goto_decorators;
		    let _waitForNavigation_decorators;
		    let _setContent_decorators;
		    let _waitForDevicePrompt_decorators;
		    return class CDPFrame extends _classSuper {
		        static {
		            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
		            __esDecorate(this, null, _goto_decorators, { kind: "method", name: "goto", static: false, private: false, access: { has: obj => "goto" in obj, get: obj => obj.goto }, metadata: _metadata }, null, _instanceExtraInitializers);
		            __esDecorate(this, null, _waitForNavigation_decorators, { kind: "method", name: "waitForNavigation", static: false, private: false, access: { has: obj => "waitForNavigation" in obj, get: obj => obj.waitForNavigation }, metadata: _metadata }, null, _instanceExtraInitializers);
		            __esDecorate(this, null, _setContent_decorators, { kind: "method", name: "setContent", static: false, private: false, access: { has: obj => "setContent" in obj, get: obj => obj.setContent }, metadata: _metadata }, null, _instanceExtraInitializers);
		            __esDecorate(this, null, _waitForDevicePrompt_decorators, { kind: "method", name: "waitForDevicePrompt", static: false, private: false, access: { has: obj => "waitForDevicePrompt" in obj, get: obj => obj.waitForDevicePrompt }, metadata: _metadata }, null, _instanceExtraInitializers);
		            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
		        }
		        #url = (__runInitializers(this, _instanceExtraInitializers), '');
		        #detached = false;
		        #client;
		        _frameManager;
		        _id;
		        _loaderId = '';
		        _lifecycleEvents = new Set();
		        _parentId;
		        constructor(frameManager, frameId, parentFrameId, client) {
		            super();
		            this._frameManager = frameManager;
		            this.#url = '';
		            this._id = frameId;
		            this._parentId = parentFrameId;
		            this.#detached = false;
		            this._loaderId = '';
		            this.updateClient(client);
		            this.on(exports.FrameEmittedEvents.FrameSwappedByActivation, () => {
		                // Emulate loading process for swapped frames.
		                this._onLoadingStarted();
		                this._onLoadingStopped();
		            });
		        }
		        /**
		         * Updates the frame ID with the new ID. This happens when the main frame is
		         * replaced by a different frame.
		         */
		        updateId(id) {
		            this._id = id;
		        }
		        updateClient(client, keepWorlds = false) {
		            this.#client = client;
		            if (!keepWorlds) {
		                this.worlds = {
		                    [IsolatedWorlds_js_1.MAIN_WORLD]: new IsolatedWorld_js_1.IsolatedWorld(this, this._frameManager.timeoutSettings),
		                    [IsolatedWorlds_js_1.PUPPETEER_WORLD]: new IsolatedWorld_js_1.IsolatedWorld(this, this._frameManager.timeoutSettings),
		                };
		            }
		            else {
		                this.worlds[IsolatedWorlds_js_1.MAIN_WORLD].frameUpdated();
		                this.worlds[IsolatedWorlds_js_1.PUPPETEER_WORLD].frameUpdated();
		            }
		        }
		        page() {
		            return this._frameManager.page();
		        }
		        isOOPFrame() {
		            return this.#client !== this._frameManager.client;
		        }
		        async goto(url, options = {}) {
		            const { referer = this._frameManager.networkManager.extraHTTPHeaders()['referer'], referrerPolicy = this._frameManager.networkManager.extraHTTPHeaders()['referer-policy'], waitUntil = ['load'], timeout = this._frameManager.timeoutSettings.navigationTimeout(), } = options;
		            let ensureNewDocumentNavigation = false;
		            const watcher = new LifecycleWatcher_js_1.LifecycleWatcher(this._frameManager.networkManager, this, waitUntil, timeout);
		            let error = await Deferred_js_1.Deferred.race([
		                navigate(this.#client, url, referer, referrerPolicy, this._id),
		                watcher.terminationPromise(),
		            ]);
		            if (!error) {
		                error = await Deferred_js_1.Deferred.race([
		                    watcher.terminationPromise(),
		                    ensureNewDocumentNavigation
		                        ? watcher.newDocumentNavigationPromise()
		                        : watcher.sameDocumentNavigationPromise(),
		                ]);
		            }
		            try {
		                if (error) {
		                    throw error;
		                }
		                return await watcher.navigationResponse();
		            }
		            finally {
		                watcher.dispose();
		            }
		            async function navigate(client, url, referrer, referrerPolicy, frameId) {
		                try {
		                    const response = await client.send('Page.navigate', {
		                        url,
		                        referrer,
		                        frameId,
		                        referrerPolicy,
		                    });
		                    ensureNewDocumentNavigation = !!response.loaderId;
		                    if (response.errorText === 'net::ERR_HTTP_RESPONSE_CODE_FAILURE') {
		                        return null;
		                    }
		                    return response.errorText
		                        ? new Error(`${response.errorText} at ${url}`)
		                        : null;
		                }
		                catch (error) {
		                    if ((0, ErrorLike_js_1.isErrorLike)(error)) {
		                        return error;
		                    }
		                    throw error;
		                }
		            }
		        }
		        async waitForNavigation(options = {}) {
		            const { waitUntil = ['load'], timeout = this._frameManager.timeoutSettings.navigationTimeout(), } = options;
		            const watcher = new LifecycleWatcher_js_1.LifecycleWatcher(this._frameManager.networkManager, this, waitUntil, timeout);
		            const error = await Deferred_js_1.Deferred.race([
		                watcher.terminationPromise(),
		                watcher.sameDocumentNavigationPromise(),
		                watcher.newDocumentNavigationPromise(),
		            ]);
		            try {
		                if (error) {
		                    throw error;
		                }
		                return await watcher.navigationResponse();
		            }
		            finally {
		                watcher.dispose();
		            }
		        }
		        get client() {
		            return this.#client;
		        }
		        mainRealm() {
		            return this.worlds[IsolatedWorlds_js_1.MAIN_WORLD];
		        }
		        isolatedRealm() {
		            return this.worlds[IsolatedWorlds_js_1.PUPPETEER_WORLD];
		        }
		        async setContent(html, options = {}) {
		            const { waitUntil = ['load'], timeout = this._frameManager.timeoutSettings.navigationTimeout(), } = options;
		            await (0, util_js_1.setPageContent)(this.isolatedRealm(), html);
		            const watcher = new LifecycleWatcher_js_1.LifecycleWatcher(this._frameManager.networkManager, this, waitUntil, timeout);
		            const error = await Deferred_js_1.Deferred.race([
		                watcher.terminationPromise(),
		                watcher.lifecyclePromise(),
		            ]);
		            watcher.dispose();
		            if (error) {
		                throw error;
		            }
		        }
		        url() {
		            return this.#url;
		        }
		        parentFrame() {
		            return this._frameManager._frameTree.parentFrame(this._id) || null;
		        }
		        childFrames() {
		            return this._frameManager._frameTree.childFrames(this._id);
		        }
		        #deviceRequestPromptManager() {
		            if (this.isOOPFrame()) {
		                return this._frameManager._deviceRequestPromptManager(this.#client);
		            }
		            const parentFrame = this.parentFrame();
		            (0, assert_js_1.assert)(parentFrame !== null);
		            return parentFrame.#deviceRequestPromptManager();
		        }
		        async waitForDevicePrompt(options = {}) {
		            return await this.#deviceRequestPromptManager().waitForDevicePrompt(options);
		        }
		        _navigated(framePayload) {
		            this._name = framePayload.name;
		            this.#url = `${framePayload.url}${framePayload.urlFragment || ''}`;
		        }
		        _navigatedWithinDocument(url) {
		            this.#url = url;
		        }
		        _onLifecycleEvent(loaderId, name) {
		            if (name === 'init') {
		                this._loaderId = loaderId;
		                this._lifecycleEvents.clear();
		            }
		            this._lifecycleEvents.add(name);
		        }
		        _onLoadingStopped() {
		            this._lifecycleEvents.add('DOMContentLoaded');
		            this._lifecycleEvents.add('load');
		        }
		        _onLoadingStarted() {
		            this._hasStartedLoading = true;
		        }
		        get detached() {
		            return this.#detached;
		        }
		        [(_goto_decorators = [Frame_js_1.throwIfDetached], _waitForNavigation_decorators = [Frame_js_1.throwIfDetached], _setContent_decorators = [Frame_js_1.throwIfDetached], _waitForDevicePrompt_decorators = [Frame_js_1.throwIfDetached], Symbol.dispose)]() {
		            if (this.#detached) {
		                return;
		            }
		            this.#detached = true;
		            this.worlds[IsolatedWorlds_js_1.MAIN_WORLD][Symbol.dispose]();
		            this.worlds[IsolatedWorlds_js_1.PUPPETEER_WORLD][Symbol.dispose]();
		        }
		    };
		})();
		exports.CDPFrame = CDPFrame;
		
	} (Frame$1));
	return Frame$1;
}

var FrameTree$1 = {};

/**
 * Copyright 2022 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(FrameTree$1, "__esModule", { value: true });
FrameTree$1.FrameTree = void 0;
const Deferred_js_1$6 = Deferred$1;
/**
 * Keeps track of the page frame tree and it's is managed by
 * {@link FrameManager}. FrameTree uses frame IDs to reference frame and it
 * means that referenced frames might not be in the tree anymore. Thus, the tree
 * structure is eventually consistent.
 * @internal
 */
class FrameTree {
    #frames = new Map();
    // frameID -> parentFrameID
    #parentIds = new Map();
    // frameID -> childFrameIDs
    #childIds = new Map();
    #mainFrame;
    #waitRequests = new Map();
    getMainFrame() {
        return this.#mainFrame;
    }
    getById(frameId) {
        return this.#frames.get(frameId);
    }
    /**
     * Returns a promise that is resolved once the frame with
     * the given ID is added to the tree.
     */
    waitForFrame(frameId) {
        const frame = this.getById(frameId);
        if (frame) {
            return Promise.resolve(frame);
        }
        const deferred = Deferred_js_1$6.Deferred.create();
        const callbacks = this.#waitRequests.get(frameId) || new Set();
        callbacks.add(deferred);
        return deferred.valueOrThrow();
    }
    frames() {
        return Array.from(this.#frames.values());
    }
    addFrame(frame) {
        this.#frames.set(frame._id, frame);
        if (frame._parentId) {
            this.#parentIds.set(frame._id, frame._parentId);
            if (!this.#childIds.has(frame._parentId)) {
                this.#childIds.set(frame._parentId, new Set());
            }
            this.#childIds.get(frame._parentId).add(frame._id);
        }
        else if (!this.#mainFrame) {
            this.#mainFrame = frame;
        }
        this.#waitRequests.get(frame._id)?.forEach(request => {
            return request.resolve(frame);
        });
    }
    removeFrame(frame) {
        this.#frames.delete(frame._id);
        this.#parentIds.delete(frame._id);
        if (frame._parentId) {
            this.#childIds.get(frame._parentId)?.delete(frame._id);
        }
        else {
            this.#mainFrame = undefined;
        }
    }
    childFrames(frameId) {
        const childIds = this.#childIds.get(frameId);
        if (!childIds) {
            return [];
        }
        return Array.from(childIds)
            .map(id => {
            return this.getById(id);
        })
            .filter((frame) => {
            return frame !== undefined;
        });
    }
    parentFrame(frameId) {
        const parentId = this.#parentIds.get(frameId);
        return parentId ? this.getById(parentId) : undefined;
    }
}
FrameTree$1.FrameTree = FrameTree;

var hasRequiredFrameManager;

function requireFrameManager () {
	if (hasRequiredFrameManager) return FrameManager;
	hasRequiredFrameManager = 1;
	(function (exports) {
		/**
		 * Copyright 2017 Google Inc. All rights reserved.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *     http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.FrameManager = exports.FrameManagerEmittedEvents = exports.UTILITY_WORLD_NAME = void 0;
		const assert_js_1 = assert$1;
		const Deferred_js_1 = Deferred$1;
		const ErrorLike_js_1 = ErrorLike;
		const Connection_js_1 = Connection$1;
		const DeviceRequestPrompt_js_1 = DeviceRequestPrompt$1;
		const EventEmitter_js_1 = EventEmitter$1;
		const ExecutionContext_js_1 = ExecutionContext$1;
		const Frame_js_1 = requireFrame$1();
		const FrameTree_js_1 = FrameTree$1;
		const IsolatedWorlds_js_1 = IsolatedWorlds;
		const NetworkManager_js_1 = NetworkManager$1;
		const util_js_1 = requireUtil();
		/**
		 * @internal
		 */
		exports.UTILITY_WORLD_NAME = '__puppeteer_utility_world__';
		/**
		 * We use symbols to prevent external parties listening to these events.
		 * They are internal to Puppeteer.
		 *
		 * @internal
		 */
		exports.FrameManagerEmittedEvents = {
		    FrameAttached: Symbol('FrameManager.FrameAttached'),
		    FrameNavigated: Symbol('FrameManager.FrameNavigated'),
		    FrameDetached: Symbol('FrameManager.FrameDetached'),
		    FrameSwapped: Symbol('FrameManager.FrameSwapped'),
		    LifecycleEvent: Symbol('FrameManager.LifecycleEvent'),
		    FrameNavigatedWithinDocument: Symbol('FrameManager.FrameNavigatedWithinDocument'),
		};
		const TIME_FOR_WAITING_FOR_SWAP = 100; // ms.
		/**
		 * A frame manager manages the frames for a given {@link Page | page}.
		 *
		 * @internal
		 */
		class FrameManager extends EventEmitter_js_1.EventEmitter {
		    #page;
		    #networkManager;
		    #timeoutSettings;
		    #contextIdToContext = new Map();
		    #isolatedWorlds = new Set();
		    #client;
		    _frameTree = new FrameTree_js_1.FrameTree();
		    /**
		     * Set of frame IDs stored to indicate if a frame has received a
		     * frameNavigated event so that frame tree responses could be ignored as the
		     * frameNavigated event usually contains the latest information.
		     */
		    #frameNavigatedReceived = new Set();
		    #deviceRequestPromptManagerMap = new WeakMap();
		    get timeoutSettings() {
		        return this.#timeoutSettings;
		    }
		    get networkManager() {
		        return this.#networkManager;
		    }
		    get client() {
		        return this.#client;
		    }
		    constructor(client, page, ignoreHTTPSErrors, timeoutSettings) {
		        super();
		        this.#client = client;
		        this.#page = page;
		        this.#networkManager = new NetworkManager_js_1.NetworkManager(ignoreHTTPSErrors, this);
		        this.#timeoutSettings = timeoutSettings;
		        this.setupEventListeners(this.#client);
		        client.once(Connection_js_1.CDPSessionEmittedEvents.Disconnected, () => {
		            this.#onClientDisconnect().catch(util_js_1.debugError);
		        });
		    }
		    /**
		     * Called when the frame's client is disconnected. We don't know if the
		     * disconnect means that the frame is removed or if it will be replaced by a
		     * new frame. Therefore, we wait for a swap event.
		     */
		    async #onClientDisconnect() {
		        const mainFrame = this._frameTree.getMainFrame();
		        if (!mainFrame) {
		            return;
		        }
		        for (const child of mainFrame.childFrames()) {
		            this.#removeFramesRecursively(child);
		        }
		        const swapped = Deferred_js_1.Deferred.create({
		            timeout: TIME_FOR_WAITING_FOR_SWAP,
		            message: 'Frame was not swapped',
		        });
		        mainFrame.once(Frame_js_1.FrameEmittedEvents.FrameSwappedByActivation, () => {
		            swapped.resolve();
		        });
		        try {
		            await swapped.valueOrThrow();
		        }
		        catch (err) {
		            this.#removeFramesRecursively(mainFrame);
		        }
		    }
		    /**
		     * When the main frame is replaced by another main frame,
		     * we maintain the main frame object identity while updating
		     * its frame tree and ID.
		     */
		    async swapFrameTree(client) {
		        this.#onExecutionContextsCleared(this.#client);
		        this.#client = client;
		        (0, assert_js_1.assert)(this.#client instanceof Connection_js_1.CDPSessionImpl, 'CDPSession is not an instance of CDPSessionImpl.');
		        const frame = this._frameTree.getMainFrame();
		        if (frame) {
		            this.#frameNavigatedReceived.add(this.#client._target()._targetId);
		            this._frameTree.removeFrame(frame);
		            frame.updateId(this.#client._target()._targetId);
		            frame.mainRealm().clearContext();
		            frame.isolatedRealm().clearContext();
		            this._frameTree.addFrame(frame);
		            frame.updateClient(client, true);
		        }
		        this.setupEventListeners(client);
		        client.once(Connection_js_1.CDPSessionEmittedEvents.Disconnected, () => {
		            this.#onClientDisconnect().catch(util_js_1.debugError);
		        });
		        await this.initialize(client);
		        await this.#networkManager.addClient(client);
		        if (frame) {
		            frame.emit(Frame_js_1.FrameEmittedEvents.FrameSwappedByActivation);
		        }
		    }
		    async registerSpeculativeSession(client) {
		        await this.#networkManager.addClient(client);
		    }
		    setupEventListeners(session) {
		        session.on('Page.frameAttached', event => {
		            this.#onFrameAttached(session, event.frameId, event.parentFrameId);
		        });
		        session.on('Page.frameNavigated', event => {
		            this.#frameNavigatedReceived.add(event.frame.id);
		            void this.#onFrameNavigated(event.frame, event.type);
		        });
		        session.on('Page.navigatedWithinDocument', event => {
		            this.#onFrameNavigatedWithinDocument(event.frameId, event.url);
		        });
		        session.on('Page.frameDetached', (event) => {
		            this.#onFrameDetached(event.frameId, event.reason);
		        });
		        session.on('Page.frameStartedLoading', event => {
		            this.#onFrameStartedLoading(event.frameId);
		        });
		        session.on('Page.frameStoppedLoading', event => {
		            this.#onFrameStoppedLoading(event.frameId);
		        });
		        session.on('Runtime.executionContextCreated', event => {
		            this.#onExecutionContextCreated(event.context, session);
		        });
		        session.on('Runtime.executionContextDestroyed', event => {
		            this.#onExecutionContextDestroyed(event.executionContextId, session);
		        });
		        session.on('Runtime.executionContextsCleared', () => {
		            this.#onExecutionContextsCleared(session);
		        });
		        session.on('Page.lifecycleEvent', event => {
		            this.#onLifecycleEvent(event);
		        });
		    }
		    async initialize(client) {
		        try {
		            const networkInit = this.#networkManager.addClient(client);
		            const result = await Promise.all([
		                client.send('Page.enable'),
		                client.send('Page.getFrameTree'),
		            ]);
		            const { frameTree } = result[1];
		            this.#handleFrameTree(client, frameTree);
		            await Promise.all([
		                client.send('Page.setLifecycleEventsEnabled', { enabled: true }),
		                client.send('Runtime.enable').then(() => {
		                    return this.#createIsolatedWorld(client, exports.UTILITY_WORLD_NAME);
		                }),
		                networkInit,
		            ]);
		        }
		        catch (error) {
		            // The target might have been closed before the initialization finished.
		            if ((0, ErrorLike_js_1.isErrorLike)(error) && (0, Connection_js_1.isTargetClosedError)(error)) {
		                return;
		            }
		            throw error;
		        }
		    }
		    executionContextById(contextId, session = this.#client) {
		        const context = this.getExecutionContextById(contextId, session);
		        (0, assert_js_1.assert)(context, 'INTERNAL ERROR: missing context with id = ' + contextId);
		        return context;
		    }
		    getExecutionContextById(contextId, session = this.#client) {
		        return this.#contextIdToContext.get(`${session.id()}:${contextId}`);
		    }
		    page() {
		        return this.#page;
		    }
		    mainFrame() {
		        const mainFrame = this._frameTree.getMainFrame();
		        (0, assert_js_1.assert)(mainFrame, 'Requesting main frame too early!');
		        return mainFrame;
		    }
		    frames() {
		        return Array.from(this._frameTree.frames());
		    }
		    frame(frameId) {
		        return this._frameTree.getById(frameId) || null;
		    }
		    onAttachedToTarget(target) {
		        if (target._getTargetInfo().type !== 'iframe') {
		            return;
		        }
		        const frame = this.frame(target._getTargetInfo().targetId);
		        if (frame) {
		            frame.updateClient(target._session());
		        }
		        this.setupEventListeners(target._session());
		        void this.initialize(target._session());
		    }
		    _deviceRequestPromptManager(client) {
		        let manager = this.#deviceRequestPromptManagerMap.get(client);
		        if (manager === undefined) {
		            manager = new DeviceRequestPrompt_js_1.DeviceRequestPromptManager(client, this.#timeoutSettings);
		            this.#deviceRequestPromptManagerMap.set(client, manager);
		        }
		        return manager;
		    }
		    #onLifecycleEvent(event) {
		        const frame = this.frame(event.frameId);
		        if (!frame) {
		            return;
		        }
		        frame._onLifecycleEvent(event.loaderId, event.name);
		        this.emit(exports.FrameManagerEmittedEvents.LifecycleEvent, frame);
		        frame.emit(Frame_js_1.FrameEmittedEvents.LifecycleEvent);
		    }
		    #onFrameStartedLoading(frameId) {
		        const frame = this.frame(frameId);
		        if (!frame) {
		            return;
		        }
		        frame._onLoadingStarted();
		    }
		    #onFrameStoppedLoading(frameId) {
		        const frame = this.frame(frameId);
		        if (!frame) {
		            return;
		        }
		        frame._onLoadingStopped();
		        this.emit(exports.FrameManagerEmittedEvents.LifecycleEvent, frame);
		        frame.emit(Frame_js_1.FrameEmittedEvents.LifecycleEvent);
		    }
		    #handleFrameTree(session, frameTree) {
		        if (frameTree.frame.parentId) {
		            this.#onFrameAttached(session, frameTree.frame.id, frameTree.frame.parentId);
		        }
		        if (!this.#frameNavigatedReceived.has(frameTree.frame.id)) {
		            void this.#onFrameNavigated(frameTree.frame, 'Navigation');
		        }
		        else {
		            this.#frameNavigatedReceived.delete(frameTree.frame.id);
		        }
		        if (!frameTree.childFrames) {
		            return;
		        }
		        for (const child of frameTree.childFrames) {
		            this.#handleFrameTree(session, child);
		        }
		    }
		    #onFrameAttached(session, frameId, parentFrameId) {
		        let frame = this.frame(frameId);
		        if (frame) {
		            if (session && frame.isOOPFrame()) {
		                // If an OOP iframes becomes a normal iframe again
		                // it is first attached to the parent page before
		                // the target is removed.
		                frame.updateClient(session);
		            }
		            return;
		        }
		        frame = new Frame_js_1.CDPFrame(this, frameId, parentFrameId, session);
		        this._frameTree.addFrame(frame);
		        this.emit(exports.FrameManagerEmittedEvents.FrameAttached, frame);
		    }
		    async #onFrameNavigated(framePayload, navigationType) {
		        const frameId = framePayload.id;
		        const isMainFrame = !framePayload.parentId;
		        let frame = this._frameTree.getById(frameId);
		        // Detach all child frames first.
		        if (frame) {
		            for (const child of frame.childFrames()) {
		                this.#removeFramesRecursively(child);
		            }
		        }
		        // Update or create main frame.
		        if (isMainFrame) {
		            if (frame) {
		                // Update frame id to retain frame identity on cross-process navigation.
		                this._frameTree.removeFrame(frame);
		                frame._id = frameId;
		            }
		            else {
		                // Initial main frame navigation.
		                frame = new Frame_js_1.CDPFrame(this, frameId, undefined, this.#client);
		            }
		            this._frameTree.addFrame(frame);
		        }
		        frame = await this._frameTree.waitForFrame(frameId);
		        frame._navigated(framePayload);
		        this.emit(exports.FrameManagerEmittedEvents.FrameNavigated, frame);
		        frame.emit(Frame_js_1.FrameEmittedEvents.FrameNavigated, navigationType);
		    }
		    async #createIsolatedWorld(session, name) {
		        const key = `${session.id()}:${name}`;
		        if (this.#isolatedWorlds.has(key)) {
		            return;
		        }
		        await session.send('Page.addScriptToEvaluateOnNewDocument', {
		            source: `//# sourceURL=${util_js_1.PuppeteerURL.INTERNAL_URL}`,
		            worldName: name,
		        });
		        await Promise.all(this.frames()
		            .filter(frame => {
		            return frame.client === session;
		        })
		            .map(frame => {
		            // Frames might be removed before we send this, so we don't want to
		            // throw an error.
		            return session
		                .send('Page.createIsolatedWorld', {
		                frameId: frame._id,
		                worldName: name,
		                grantUniveralAccess: true,
		            })
		                .catch(util_js_1.debugError);
		        }));
		        this.#isolatedWorlds.add(key);
		    }
		    #onFrameNavigatedWithinDocument(frameId, url) {
		        const frame = this.frame(frameId);
		        if (!frame) {
		            return;
		        }
		        frame._navigatedWithinDocument(url);
		        this.emit(exports.FrameManagerEmittedEvents.FrameNavigatedWithinDocument, frame);
		        frame.emit(Frame_js_1.FrameEmittedEvents.FrameNavigatedWithinDocument);
		        this.emit(exports.FrameManagerEmittedEvents.FrameNavigated, frame);
		        frame.emit(Frame_js_1.FrameEmittedEvents.FrameNavigated);
		    }
		    #onFrameDetached(frameId, reason) {
		        const frame = this.frame(frameId);
		        if (reason === 'remove') {
		            // Only remove the frame if the reason for the detached event is
		            // an actual removement of the frame.
		            // For frames that become OOP iframes, the reason would be 'swap'.
		            if (frame) {
		                this.#removeFramesRecursively(frame);
		            }
		        }
		        else if (reason === 'swap') {
		            this.emit(exports.FrameManagerEmittedEvents.FrameSwapped, frame);
		            frame?.emit(Frame_js_1.FrameEmittedEvents.FrameSwapped);
		        }
		    }
		    #onExecutionContextCreated(contextPayload, session) {
		        const auxData = contextPayload.auxData;
		        const frameId = auxData && auxData.frameId;
		        const frame = typeof frameId === 'string' ? this.frame(frameId) : undefined;
		        let world;
		        if (frame) {
		            // Only care about execution contexts created for the current session.
		            if (frame.client !== session) {
		                return;
		            }
		            if (contextPayload.auxData && contextPayload.auxData['isDefault']) {
		                world = frame.worlds[IsolatedWorlds_js_1.MAIN_WORLD];
		            }
		            else if (contextPayload.name === exports.UTILITY_WORLD_NAME &&
		                !frame.worlds[IsolatedWorlds_js_1.PUPPETEER_WORLD].hasContext()) {
		                // In case of multiple sessions to the same target, there's a race between
		                // connections so we might end up creating multiple isolated worlds.
		                // We can use either.
		                world = frame.worlds[IsolatedWorlds_js_1.PUPPETEER_WORLD];
		            }
		        }
		        // If there is no world, the context is not meant to be handled by us.
		        if (!world) {
		            return;
		        }
		        const context = new ExecutionContext_js_1.ExecutionContext(frame?.client || this.#client, contextPayload, world);
		        if (world) {
		            world.setContext(context);
		        }
		        const key = `${session.id()}:${contextPayload.id}`;
		        this.#contextIdToContext.set(key, context);
		    }
		    #onExecutionContextDestroyed(executionContextId, session) {
		        const key = `${session.id()}:${executionContextId}`;
		        const context = this.#contextIdToContext.get(key);
		        if (!context) {
		            return;
		        }
		        this.#contextIdToContext.delete(key);
		        if (context._world) {
		            context._world.clearContext();
		        }
		    }
		    #onExecutionContextsCleared(session) {
		        for (const [key, context] of this.#contextIdToContext.entries()) {
		            // Make sure to only clear execution contexts that belong
		            // to the current session.
		            if (context._client !== session) {
		                continue;
		            }
		            if (context._world) {
		                context._world.clearContext();
		            }
		            this.#contextIdToContext.delete(key);
		        }
		    }
		    #removeFramesRecursively(frame) {
		        for (const child of frame.childFrames()) {
		            this.#removeFramesRecursively(child);
		        }
		        frame[Symbol.dispose]();
		        this._frameTree.removeFrame(frame);
		        this.emit(exports.FrameManagerEmittedEvents.FrameDetached, frame);
		        frame.emit(Frame_js_1.FrameEmittedEvents.FrameDetached, frame);
		    }
		}
		exports.FrameManager = FrameManager;
		
	} (FrameManager));
	return FrameManager;
}

var Input$1 = {};

var USKeyboardLayout = {};

/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(USKeyboardLayout, "__esModule", { value: true });
USKeyboardLayout._keyDefinitions = void 0;
/**
 * @internal
 */
USKeyboardLayout._keyDefinitions = {
    '0': { keyCode: 48, key: '0', code: 'Digit0' },
    '1': { keyCode: 49, key: '1', code: 'Digit1' },
    '2': { keyCode: 50, key: '2', code: 'Digit2' },
    '3': { keyCode: 51, key: '3', code: 'Digit3' },
    '4': { keyCode: 52, key: '4', code: 'Digit4' },
    '5': { keyCode: 53, key: '5', code: 'Digit5' },
    '6': { keyCode: 54, key: '6', code: 'Digit6' },
    '7': { keyCode: 55, key: '7', code: 'Digit7' },
    '8': { keyCode: 56, key: '8', code: 'Digit8' },
    '9': { keyCode: 57, key: '9', code: 'Digit9' },
    Power: { key: 'Power', code: 'Power' },
    Eject: { key: 'Eject', code: 'Eject' },
    Abort: { keyCode: 3, code: 'Abort', key: 'Cancel' },
    Help: { keyCode: 6, code: 'Help', key: 'Help' },
    Backspace: { keyCode: 8, code: 'Backspace', key: 'Backspace' },
    Tab: { keyCode: 9, code: 'Tab', key: 'Tab' },
    Numpad5: {
        keyCode: 12,
        shiftKeyCode: 101,
        key: 'Clear',
        code: 'Numpad5',
        shiftKey: '5',
        location: 3,
    },
    NumpadEnter: {
        keyCode: 13,
        code: 'NumpadEnter',
        key: 'Enter',
        text: '\r',
        location: 3,
    },
    Enter: { keyCode: 13, code: 'Enter', key: 'Enter', text: '\r' },
    '\r': { keyCode: 13, code: 'Enter', key: 'Enter', text: '\r' },
    '\n': { keyCode: 13, code: 'Enter', key: 'Enter', text: '\r' },
    ShiftLeft: { keyCode: 16, code: 'ShiftLeft', key: 'Shift', location: 1 },
    ShiftRight: { keyCode: 16, code: 'ShiftRight', key: 'Shift', location: 2 },
    ControlLeft: {
        keyCode: 17,
        code: 'ControlLeft',
        key: 'Control',
        location: 1,
    },
    ControlRight: {
        keyCode: 17,
        code: 'ControlRight',
        key: 'Control',
        location: 2,
    },
    AltLeft: { keyCode: 18, code: 'AltLeft', key: 'Alt', location: 1 },
    AltRight: { keyCode: 18, code: 'AltRight', key: 'Alt', location: 2 },
    Pause: { keyCode: 19, code: 'Pause', key: 'Pause' },
    CapsLock: { keyCode: 20, code: 'CapsLock', key: 'CapsLock' },
    Escape: { keyCode: 27, code: 'Escape', key: 'Escape' },
    Convert: { keyCode: 28, code: 'Convert', key: 'Convert' },
    NonConvert: { keyCode: 29, code: 'NonConvert', key: 'NonConvert' },
    Space: { keyCode: 32, code: 'Space', key: ' ' },
    Numpad9: {
        keyCode: 33,
        shiftKeyCode: 105,
        key: 'PageUp',
        code: 'Numpad9',
        shiftKey: '9',
        location: 3,
    },
    PageUp: { keyCode: 33, code: 'PageUp', key: 'PageUp' },
    Numpad3: {
        keyCode: 34,
        shiftKeyCode: 99,
        key: 'PageDown',
        code: 'Numpad3',
        shiftKey: '3',
        location: 3,
    },
    PageDown: { keyCode: 34, code: 'PageDown', key: 'PageDown' },
    End: { keyCode: 35, code: 'End', key: 'End' },
    Numpad1: {
        keyCode: 35,
        shiftKeyCode: 97,
        key: 'End',
        code: 'Numpad1',
        shiftKey: '1',
        location: 3,
    },
    Home: { keyCode: 36, code: 'Home', key: 'Home' },
    Numpad7: {
        keyCode: 36,
        shiftKeyCode: 103,
        key: 'Home',
        code: 'Numpad7',
        shiftKey: '7',
        location: 3,
    },
    ArrowLeft: { keyCode: 37, code: 'ArrowLeft', key: 'ArrowLeft' },
    Numpad4: {
        keyCode: 37,
        shiftKeyCode: 100,
        key: 'ArrowLeft',
        code: 'Numpad4',
        shiftKey: '4',
        location: 3,
    },
    Numpad8: {
        keyCode: 38,
        shiftKeyCode: 104,
        key: 'ArrowUp',
        code: 'Numpad8',
        shiftKey: '8',
        location: 3,
    },
    ArrowUp: { keyCode: 38, code: 'ArrowUp', key: 'ArrowUp' },
    ArrowRight: { keyCode: 39, code: 'ArrowRight', key: 'ArrowRight' },
    Numpad6: {
        keyCode: 39,
        shiftKeyCode: 102,
        key: 'ArrowRight',
        code: 'Numpad6',
        shiftKey: '6',
        location: 3,
    },
    Numpad2: {
        keyCode: 40,
        shiftKeyCode: 98,
        key: 'ArrowDown',
        code: 'Numpad2',
        shiftKey: '2',
        location: 3,
    },
    ArrowDown: { keyCode: 40, code: 'ArrowDown', key: 'ArrowDown' },
    Select: { keyCode: 41, code: 'Select', key: 'Select' },
    Open: { keyCode: 43, code: 'Open', key: 'Execute' },
    PrintScreen: { keyCode: 44, code: 'PrintScreen', key: 'PrintScreen' },
    Insert: { keyCode: 45, code: 'Insert', key: 'Insert' },
    Numpad0: {
        keyCode: 45,
        shiftKeyCode: 96,
        key: 'Insert',
        code: 'Numpad0',
        shiftKey: '0',
        location: 3,
    },
    Delete: { keyCode: 46, code: 'Delete', key: 'Delete' },
    NumpadDecimal: {
        keyCode: 46,
        shiftKeyCode: 110,
        code: 'NumpadDecimal',
        key: '\u0000',
        shiftKey: '.',
        location: 3,
    },
    Digit0: { keyCode: 48, code: 'Digit0', shiftKey: ')', key: '0' },
    Digit1: { keyCode: 49, code: 'Digit1', shiftKey: '!', key: '1' },
    Digit2: { keyCode: 50, code: 'Digit2', shiftKey: '@', key: '2' },
    Digit3: { keyCode: 51, code: 'Digit3', shiftKey: '#', key: '3' },
    Digit4: { keyCode: 52, code: 'Digit4', shiftKey: '$', key: '4' },
    Digit5: { keyCode: 53, code: 'Digit5', shiftKey: '%', key: '5' },
    Digit6: { keyCode: 54, code: 'Digit6', shiftKey: '^', key: '6' },
    Digit7: { keyCode: 55, code: 'Digit7', shiftKey: '&', key: '7' },
    Digit8: { keyCode: 56, code: 'Digit8', shiftKey: '*', key: '8' },
    Digit9: { keyCode: 57, code: 'Digit9', shiftKey: '(', key: '9' },
    KeyA: { keyCode: 65, code: 'KeyA', shiftKey: 'A', key: 'a' },
    KeyB: { keyCode: 66, code: 'KeyB', shiftKey: 'B', key: 'b' },
    KeyC: { keyCode: 67, code: 'KeyC', shiftKey: 'C', key: 'c' },
    KeyD: { keyCode: 68, code: 'KeyD', shiftKey: 'D', key: 'd' },
    KeyE: { keyCode: 69, code: 'KeyE', shiftKey: 'E', key: 'e' },
    KeyF: { keyCode: 70, code: 'KeyF', shiftKey: 'F', key: 'f' },
    KeyG: { keyCode: 71, code: 'KeyG', shiftKey: 'G', key: 'g' },
    KeyH: { keyCode: 72, code: 'KeyH', shiftKey: 'H', key: 'h' },
    KeyI: { keyCode: 73, code: 'KeyI', shiftKey: 'I', key: 'i' },
    KeyJ: { keyCode: 74, code: 'KeyJ', shiftKey: 'J', key: 'j' },
    KeyK: { keyCode: 75, code: 'KeyK', shiftKey: 'K', key: 'k' },
    KeyL: { keyCode: 76, code: 'KeyL', shiftKey: 'L', key: 'l' },
    KeyM: { keyCode: 77, code: 'KeyM', shiftKey: 'M', key: 'm' },
    KeyN: { keyCode: 78, code: 'KeyN', shiftKey: 'N', key: 'n' },
    KeyO: { keyCode: 79, code: 'KeyO', shiftKey: 'O', key: 'o' },
    KeyP: { keyCode: 80, code: 'KeyP', shiftKey: 'P', key: 'p' },
    KeyQ: { keyCode: 81, code: 'KeyQ', shiftKey: 'Q', key: 'q' },
    KeyR: { keyCode: 82, code: 'KeyR', shiftKey: 'R', key: 'r' },
    KeyS: { keyCode: 83, code: 'KeyS', shiftKey: 'S', key: 's' },
    KeyT: { keyCode: 84, code: 'KeyT', shiftKey: 'T', key: 't' },
    KeyU: { keyCode: 85, code: 'KeyU', shiftKey: 'U', key: 'u' },
    KeyV: { keyCode: 86, code: 'KeyV', shiftKey: 'V', key: 'v' },
    KeyW: { keyCode: 87, code: 'KeyW', shiftKey: 'W', key: 'w' },
    KeyX: { keyCode: 88, code: 'KeyX', shiftKey: 'X', key: 'x' },
    KeyY: { keyCode: 89, code: 'KeyY', shiftKey: 'Y', key: 'y' },
    KeyZ: { keyCode: 90, code: 'KeyZ', shiftKey: 'Z', key: 'z' },
    MetaLeft: { keyCode: 91, code: 'MetaLeft', key: 'Meta', location: 1 },
    MetaRight: { keyCode: 92, code: 'MetaRight', key: 'Meta', location: 2 },
    ContextMenu: { keyCode: 93, code: 'ContextMenu', key: 'ContextMenu' },
    NumpadMultiply: {
        keyCode: 106,
        code: 'NumpadMultiply',
        key: '*',
        location: 3,
    },
    NumpadAdd: { keyCode: 107, code: 'NumpadAdd', key: '+', location: 3 },
    NumpadSubtract: {
        keyCode: 109,
        code: 'NumpadSubtract',
        key: '-',
        location: 3,
    },
    NumpadDivide: { keyCode: 111, code: 'NumpadDivide', key: '/', location: 3 },
    F1: { keyCode: 112, code: 'F1', key: 'F1' },
    F2: { keyCode: 113, code: 'F2', key: 'F2' },
    F3: { keyCode: 114, code: 'F3', key: 'F3' },
    F4: { keyCode: 115, code: 'F4', key: 'F4' },
    F5: { keyCode: 116, code: 'F5', key: 'F5' },
    F6: { keyCode: 117, code: 'F6', key: 'F6' },
    F7: { keyCode: 118, code: 'F7', key: 'F7' },
    F8: { keyCode: 119, code: 'F8', key: 'F8' },
    F9: { keyCode: 120, code: 'F9', key: 'F9' },
    F10: { keyCode: 121, code: 'F10', key: 'F10' },
    F11: { keyCode: 122, code: 'F11', key: 'F11' },
    F12: { keyCode: 123, code: 'F12', key: 'F12' },
    F13: { keyCode: 124, code: 'F13', key: 'F13' },
    F14: { keyCode: 125, code: 'F14', key: 'F14' },
    F15: { keyCode: 126, code: 'F15', key: 'F15' },
    F16: { keyCode: 127, code: 'F16', key: 'F16' },
    F17: { keyCode: 128, code: 'F17', key: 'F17' },
    F18: { keyCode: 129, code: 'F18', key: 'F18' },
    F19: { keyCode: 130, code: 'F19', key: 'F19' },
    F20: { keyCode: 131, code: 'F20', key: 'F20' },
    F21: { keyCode: 132, code: 'F21', key: 'F21' },
    F22: { keyCode: 133, code: 'F22', key: 'F22' },
    F23: { keyCode: 134, code: 'F23', key: 'F23' },
    F24: { keyCode: 135, code: 'F24', key: 'F24' },
    NumLock: { keyCode: 144, code: 'NumLock', key: 'NumLock' },
    ScrollLock: { keyCode: 145, code: 'ScrollLock', key: 'ScrollLock' },
    AudioVolumeMute: {
        keyCode: 173,
        code: 'AudioVolumeMute',
        key: 'AudioVolumeMute',
    },
    AudioVolumeDown: {
        keyCode: 174,
        code: 'AudioVolumeDown',
        key: 'AudioVolumeDown',
    },
    AudioVolumeUp: { keyCode: 175, code: 'AudioVolumeUp', key: 'AudioVolumeUp' },
    MediaTrackNext: {
        keyCode: 176,
        code: 'MediaTrackNext',
        key: 'MediaTrackNext',
    },
    MediaTrackPrevious: {
        keyCode: 177,
        code: 'MediaTrackPrevious',
        key: 'MediaTrackPrevious',
    },
    MediaStop: { keyCode: 178, code: 'MediaStop', key: 'MediaStop' },
    MediaPlayPause: {
        keyCode: 179,
        code: 'MediaPlayPause',
        key: 'MediaPlayPause',
    },
    Semicolon: { keyCode: 186, code: 'Semicolon', shiftKey: ':', key: ';' },
    Equal: { keyCode: 187, code: 'Equal', shiftKey: '+', key: '=' },
    NumpadEqual: { keyCode: 187, code: 'NumpadEqual', key: '=', location: 3 },
    Comma: { keyCode: 188, code: 'Comma', shiftKey: '<', key: ',' },
    Minus: { keyCode: 189, code: 'Minus', shiftKey: '_', key: '-' },
    Period: { keyCode: 190, code: 'Period', shiftKey: '>', key: '.' },
    Slash: { keyCode: 191, code: 'Slash', shiftKey: '?', key: '/' },
    Backquote: { keyCode: 192, code: 'Backquote', shiftKey: '~', key: '`' },
    BracketLeft: { keyCode: 219, code: 'BracketLeft', shiftKey: '{', key: '[' },
    Backslash: { keyCode: 220, code: 'Backslash', shiftKey: '|', key: '\\' },
    BracketRight: { keyCode: 221, code: 'BracketRight', shiftKey: '}', key: ']' },
    Quote: { keyCode: 222, code: 'Quote', shiftKey: '"', key: "'" },
    AltGraph: { keyCode: 225, code: 'AltGraph', key: 'AltGraph' },
    Props: { keyCode: 247, code: 'Props', key: 'CrSel' },
    Cancel: { keyCode: 3, key: 'Cancel', code: 'Abort' },
    Clear: { keyCode: 12, key: 'Clear', code: 'Numpad5', location: 3 },
    Shift: { keyCode: 16, key: 'Shift', code: 'ShiftLeft', location: 1 },
    Control: { keyCode: 17, key: 'Control', code: 'ControlLeft', location: 1 },
    Alt: { keyCode: 18, key: 'Alt', code: 'AltLeft', location: 1 },
    Accept: { keyCode: 30, key: 'Accept' },
    ModeChange: { keyCode: 31, key: 'ModeChange' },
    ' ': { keyCode: 32, key: ' ', code: 'Space' },
    Print: { keyCode: 42, key: 'Print' },
    Execute: { keyCode: 43, key: 'Execute', code: 'Open' },
    '\u0000': { keyCode: 46, key: '\u0000', code: 'NumpadDecimal', location: 3 },
    a: { keyCode: 65, key: 'a', code: 'KeyA' },
    b: { keyCode: 66, key: 'b', code: 'KeyB' },
    c: { keyCode: 67, key: 'c', code: 'KeyC' },
    d: { keyCode: 68, key: 'd', code: 'KeyD' },
    e: { keyCode: 69, key: 'e', code: 'KeyE' },
    f: { keyCode: 70, key: 'f', code: 'KeyF' },
    g: { keyCode: 71, key: 'g', code: 'KeyG' },
    h: { keyCode: 72, key: 'h', code: 'KeyH' },
    i: { keyCode: 73, key: 'i', code: 'KeyI' },
    j: { keyCode: 74, key: 'j', code: 'KeyJ' },
    k: { keyCode: 75, key: 'k', code: 'KeyK' },
    l: { keyCode: 76, key: 'l', code: 'KeyL' },
    m: { keyCode: 77, key: 'm', code: 'KeyM' },
    n: { keyCode: 78, key: 'n', code: 'KeyN' },
    o: { keyCode: 79, key: 'o', code: 'KeyO' },
    p: { keyCode: 80, key: 'p', code: 'KeyP' },
    q: { keyCode: 81, key: 'q', code: 'KeyQ' },
    r: { keyCode: 82, key: 'r', code: 'KeyR' },
    s: { keyCode: 83, key: 's', code: 'KeyS' },
    t: { keyCode: 84, key: 't', code: 'KeyT' },
    u: { keyCode: 85, key: 'u', code: 'KeyU' },
    v: { keyCode: 86, key: 'v', code: 'KeyV' },
    w: { keyCode: 87, key: 'w', code: 'KeyW' },
    x: { keyCode: 88, key: 'x', code: 'KeyX' },
    y: { keyCode: 89, key: 'y', code: 'KeyY' },
    z: { keyCode: 90, key: 'z', code: 'KeyZ' },
    Meta: { keyCode: 91, key: 'Meta', code: 'MetaLeft', location: 1 },
    '*': { keyCode: 106, key: '*', code: 'NumpadMultiply', location: 3 },
    '+': { keyCode: 107, key: '+', code: 'NumpadAdd', location: 3 },
    '-': { keyCode: 109, key: '-', code: 'NumpadSubtract', location: 3 },
    '/': { keyCode: 111, key: '/', code: 'NumpadDivide', location: 3 },
    ';': { keyCode: 186, key: ';', code: 'Semicolon' },
    '=': { keyCode: 187, key: '=', code: 'Equal' },
    ',': { keyCode: 188, key: ',', code: 'Comma' },
    '.': { keyCode: 190, key: '.', code: 'Period' },
    '`': { keyCode: 192, key: '`', code: 'Backquote' },
    '[': { keyCode: 219, key: '[', code: 'BracketLeft' },
    '\\': { keyCode: 220, key: '\\', code: 'Backslash' },
    ']': { keyCode: 221, key: ']', code: 'BracketRight' },
    "'": { keyCode: 222, key: "'", code: 'Quote' },
    Attn: { keyCode: 246, key: 'Attn' },
    CrSel: { keyCode: 247, key: 'CrSel', code: 'Props' },
    ExSel: { keyCode: 248, key: 'ExSel' },
    EraseEof: { keyCode: 249, key: 'EraseEof' },
    Play: { keyCode: 250, key: 'Play' },
    ZoomOut: { keyCode: 251, key: 'ZoomOut' },
    ')': { keyCode: 48, key: ')', code: 'Digit0' },
    '!': { keyCode: 49, key: '!', code: 'Digit1' },
    '@': { keyCode: 50, key: '@', code: 'Digit2' },
    '#': { keyCode: 51, key: '#', code: 'Digit3' },
    $: { keyCode: 52, key: '$', code: 'Digit4' },
    '%': { keyCode: 53, key: '%', code: 'Digit5' },
    '^': { keyCode: 54, key: '^', code: 'Digit6' },
    '&': { keyCode: 55, key: '&', code: 'Digit7' },
    '(': { keyCode: 57, key: '(', code: 'Digit9' },
    A: { keyCode: 65, key: 'A', code: 'KeyA' },
    B: { keyCode: 66, key: 'B', code: 'KeyB' },
    C: { keyCode: 67, key: 'C', code: 'KeyC' },
    D: { keyCode: 68, key: 'D', code: 'KeyD' },
    E: { keyCode: 69, key: 'E', code: 'KeyE' },
    F: { keyCode: 70, key: 'F', code: 'KeyF' },
    G: { keyCode: 71, key: 'G', code: 'KeyG' },
    H: { keyCode: 72, key: 'H', code: 'KeyH' },
    I: { keyCode: 73, key: 'I', code: 'KeyI' },
    J: { keyCode: 74, key: 'J', code: 'KeyJ' },
    K: { keyCode: 75, key: 'K', code: 'KeyK' },
    L: { keyCode: 76, key: 'L', code: 'KeyL' },
    M: { keyCode: 77, key: 'M', code: 'KeyM' },
    N: { keyCode: 78, key: 'N', code: 'KeyN' },
    O: { keyCode: 79, key: 'O', code: 'KeyO' },
    P: { keyCode: 80, key: 'P', code: 'KeyP' },
    Q: { keyCode: 81, key: 'Q', code: 'KeyQ' },
    R: { keyCode: 82, key: 'R', code: 'KeyR' },
    S: { keyCode: 83, key: 'S', code: 'KeyS' },
    T: { keyCode: 84, key: 'T', code: 'KeyT' },
    U: { keyCode: 85, key: 'U', code: 'KeyU' },
    V: { keyCode: 86, key: 'V', code: 'KeyV' },
    W: { keyCode: 87, key: 'W', code: 'KeyW' },
    X: { keyCode: 88, key: 'X', code: 'KeyX' },
    Y: { keyCode: 89, key: 'Y', code: 'KeyY' },
    Z: { keyCode: 90, key: 'Z', code: 'KeyZ' },
    ':': { keyCode: 186, key: ':', code: 'Semicolon' },
    '<': { keyCode: 188, key: '<', code: 'Comma' },
    _: { keyCode: 189, key: '_', code: 'Minus' },
    '>': { keyCode: 190, key: '>', code: 'Period' },
    '?': { keyCode: 191, key: '?', code: 'Slash' },
    '~': { keyCode: 192, key: '~', code: 'Backquote' },
    '{': { keyCode: 219, key: '{', code: 'BracketLeft' },
    '|': { keyCode: 220, key: '|', code: 'Backslash' },
    '}': { keyCode: 221, key: '}', code: 'BracketRight' },
    '"': { keyCode: 222, key: '"', code: 'Quote' },
    SoftLeft: { key: 'SoftLeft', code: 'SoftLeft', location: 4 },
    SoftRight: { key: 'SoftRight', code: 'SoftRight', location: 4 },
    Camera: { keyCode: 44, key: 'Camera', code: 'Camera', location: 4 },
    Call: { key: 'Call', code: 'Call', location: 4 },
    EndCall: { keyCode: 95, key: 'EndCall', code: 'EndCall', location: 4 },
    VolumeDown: {
        keyCode: 182,
        key: 'VolumeDown',
        code: 'VolumeDown',
        location: 4,
    },
    VolumeUp: { keyCode: 183, key: 'VolumeUp', code: 'VolumeUp', location: 4 },
};

/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(Input$1, "__esModule", { value: true });
Input$1.CDPTouchscreen = Input$1.CDPMouse = Input$1.CDPKeyboard = void 0;
const Input_js_1$1 = Input$2;
const assert_js_1$9 = assert$1;
const USKeyboardLayout_js_1 = USKeyboardLayout;
/**
 * @internal
 */
class CDPKeyboard extends Input_js_1$1.Keyboard {
    #client;
    #pressedKeys = new Set();
    _modifiers = 0;
    constructor(client) {
        super();
        this.#client = client;
    }
    updateClient(client) {
        this.#client = client;
    }
    async down(key, options = {
        text: undefined,
        commands: [],
    }) {
        const description = this.#keyDescriptionForString(key);
        const autoRepeat = this.#pressedKeys.has(description.code);
        this.#pressedKeys.add(description.code);
        this._modifiers |= this.#modifierBit(description.key);
        const text = options.text === undefined ? description.text : options.text;
        await this.#client.send('Input.dispatchKeyEvent', {
            type: text ? 'keyDown' : 'rawKeyDown',
            modifiers: this._modifiers,
            windowsVirtualKeyCode: description.keyCode,
            code: description.code,
            key: description.key,
            text: text,
            unmodifiedText: text,
            autoRepeat,
            location: description.location,
            isKeypad: description.location === 3,
            commands: options.commands,
        });
    }
    #modifierBit(key) {
        if (key === 'Alt') {
            return 1;
        }
        if (key === 'Control') {
            return 2;
        }
        if (key === 'Meta') {
            return 4;
        }
        if (key === 'Shift') {
            return 8;
        }
        return 0;
    }
    #keyDescriptionForString(keyString) {
        const shift = this._modifiers & 8;
        const description = {
            key: '',
            keyCode: 0,
            code: '',
            text: '',
            location: 0,
        };
        const definition = USKeyboardLayout_js_1._keyDefinitions[keyString];
        (0, assert_js_1$9.assert)(definition, `Unknown key: "${keyString}"`);
        if (definition.key) {
            description.key = definition.key;
        }
        if (shift && definition.shiftKey) {
            description.key = definition.shiftKey;
        }
        if (definition.keyCode) {
            description.keyCode = definition.keyCode;
        }
        if (shift && definition.shiftKeyCode) {
            description.keyCode = definition.shiftKeyCode;
        }
        if (definition.code) {
            description.code = definition.code;
        }
        if (definition.location) {
            description.location = definition.location;
        }
        if (description.key.length === 1) {
            description.text = description.key;
        }
        if (definition.text) {
            description.text = definition.text;
        }
        if (shift && definition.shiftText) {
            description.text = definition.shiftText;
        }
        // if any modifiers besides shift are pressed, no text should be sent
        if (this._modifiers & ~8) {
            description.text = '';
        }
        return description;
    }
    async up(key) {
        const description = this.#keyDescriptionForString(key);
        this._modifiers &= ~this.#modifierBit(description.key);
        this.#pressedKeys.delete(description.code);
        await this.#client.send('Input.dispatchKeyEvent', {
            type: 'keyUp',
            modifiers: this._modifiers,
            key: description.key,
            windowsVirtualKeyCode: description.keyCode,
            code: description.code,
            location: description.location,
        });
    }
    async sendCharacter(char) {
        await this.#client.send('Input.insertText', { text: char });
    }
    charIsKey(char) {
        return !!USKeyboardLayout_js_1._keyDefinitions[char];
    }
    async type(text, options = {}) {
        const delay = options.delay || undefined;
        for (const char of text) {
            if (this.charIsKey(char)) {
                await this.press(char, { delay });
            }
            else {
                if (delay) {
                    await new Promise(f => {
                        return setTimeout(f, delay);
                    });
                }
                await this.sendCharacter(char);
            }
        }
    }
    async press(key, options = {}) {
        const { delay = null } = options;
        await this.down(key, options);
        if (delay) {
            await new Promise(f => {
                return setTimeout(f, options.delay);
            });
        }
        await this.up(key);
    }
}
Input$1.CDPKeyboard = CDPKeyboard;
const getFlag = (button) => {
    switch (button) {
        case Input_js_1$1.MouseButton.Left:
            return 1 /* MouseButtonFlag.Left */;
        case Input_js_1$1.MouseButton.Right:
            return 2 /* MouseButtonFlag.Right */;
        case Input_js_1$1.MouseButton.Middle:
            return 4 /* MouseButtonFlag.Middle */;
        case Input_js_1$1.MouseButton.Back:
            return 8 /* MouseButtonFlag.Back */;
        case Input_js_1$1.MouseButton.Forward:
            return 16 /* MouseButtonFlag.Forward */;
    }
};
/**
 * This should match
 * https://source.chromium.org/chromium/chromium/src/+/refs/heads/main:content/browser/renderer_host/input/web_input_event_builders_mac.mm;drc=a61b95c63b0b75c1cfe872d9c8cdf927c226046e;bpv=1;bpt=1;l=221.
 */
const getButtonFromPressedButtons = (buttons) => {
    if (buttons & 1 /* MouseButtonFlag.Left */) {
        return Input_js_1$1.MouseButton.Left;
    }
    else if (buttons & 2 /* MouseButtonFlag.Right */) {
        return Input_js_1$1.MouseButton.Right;
    }
    else if (buttons & 4 /* MouseButtonFlag.Middle */) {
        return Input_js_1$1.MouseButton.Middle;
    }
    else if (buttons & 8 /* MouseButtonFlag.Back */) {
        return Input_js_1$1.MouseButton.Back;
    }
    else if (buttons & 16 /* MouseButtonFlag.Forward */) {
        return Input_js_1$1.MouseButton.Forward;
    }
    return 'none';
};
/**
 * @internal
 */
class CDPMouse extends Input_js_1$1.Mouse {
    #client;
    #keyboard;
    constructor(client, keyboard) {
        super();
        this.#client = client;
        this.#keyboard = keyboard;
    }
    updateClient(client) {
        this.#client = client;
    }
    #_state = {
        position: { x: 0, y: 0 },
        buttons: 0 /* MouseButtonFlag.None */,
    };
    get #state() {
        return Object.assign({ ...this.#_state }, ...this.#transactions);
    }
    // Transactions can run in parallel, so we store each of thme in this array.
    #transactions = [];
    #createTransaction() {
        const transaction = {};
        this.#transactions.push(transaction);
        const popTransaction = () => {
            this.#transactions.splice(this.#transactions.indexOf(transaction), 1);
        };
        return {
            update: (updates) => {
                Object.assign(transaction, updates);
            },
            commit: () => {
                this.#_state = { ...this.#_state, ...transaction };
                popTransaction();
            },
            rollback: popTransaction,
        };
    }
    /**
     * This is a shortcut for a typical update, commit/rollback lifecycle based on
     * the error of the action.
     */
    async #withTransaction(action) {
        const { update, commit, rollback } = this.#createTransaction();
        try {
            await action(update);
            commit();
        }
        catch (error) {
            rollback();
            throw error;
        }
    }
    async reset() {
        const actions = [];
        for (const [flag, button] of [
            [1 /* MouseButtonFlag.Left */, Input_js_1$1.MouseButton.Left],
            [4 /* MouseButtonFlag.Middle */, Input_js_1$1.MouseButton.Middle],
            [2 /* MouseButtonFlag.Right */, Input_js_1$1.MouseButton.Right],
            [16 /* MouseButtonFlag.Forward */, Input_js_1$1.MouseButton.Forward],
            [8 /* MouseButtonFlag.Back */, Input_js_1$1.MouseButton.Back],
        ]) {
            if (this.#state.buttons & flag) {
                actions.push(this.up({ button: button }));
            }
        }
        if (this.#state.position.x !== 0 || this.#state.position.y !== 0) {
            actions.push(this.move(0, 0));
        }
        await Promise.all(actions);
    }
    async move(x, y, options = {}) {
        const { steps = 1 } = options;
        const from = this.#state.position;
        const to = { x, y };
        for (let i = 1; i <= steps; i++) {
            await this.#withTransaction(updateState => {
                updateState({
                    position: {
                        x: from.x + (to.x - from.x) * (i / steps),
                        y: from.y + (to.y - from.y) * (i / steps),
                    },
                });
                const { buttons, position } = this.#state;
                return this.#client.send('Input.dispatchMouseEvent', {
                    type: 'mouseMoved',
                    modifiers: this.#keyboard._modifiers,
                    buttons,
                    button: getButtonFromPressedButtons(buttons),
                    ...position,
                });
            });
        }
    }
    async down(options = {}) {
        const { button = Input_js_1$1.MouseButton.Left, clickCount = 1 } = options;
        const flag = getFlag(button);
        if (!flag) {
            throw new Error(`Unsupported mouse button: ${button}`);
        }
        if (this.#state.buttons & flag) {
            throw new Error(`'${button}' is already pressed.`);
        }
        await this.#withTransaction(updateState => {
            updateState({
                buttons: this.#state.buttons | flag,
            });
            const { buttons, position } = this.#state;
            return this.#client.send('Input.dispatchMouseEvent', {
                type: 'mousePressed',
                modifiers: this.#keyboard._modifiers,
                clickCount,
                buttons,
                button,
                ...position,
            });
        });
    }
    async up(options = {}) {
        const { button = Input_js_1$1.MouseButton.Left, clickCount = 1 } = options;
        const flag = getFlag(button);
        if (!flag) {
            throw new Error(`Unsupported mouse button: ${button}`);
        }
        if (!(this.#state.buttons & flag)) {
            throw new Error(`'${button}' is not pressed.`);
        }
        await this.#withTransaction(updateState => {
            updateState({
                buttons: this.#state.buttons & ~flag,
            });
            const { buttons, position } = this.#state;
            return this.#client.send('Input.dispatchMouseEvent', {
                type: 'mouseReleased',
                modifiers: this.#keyboard._modifiers,
                clickCount,
                buttons,
                button,
                ...position,
            });
        });
    }
    async click(x, y, options = {}) {
        const { delay, count = 1, clickCount = count } = options;
        if (count < 1) {
            throw new Error('Click must occur a positive number of times.');
        }
        const actions = [this.move(x, y)];
        if (clickCount === count) {
            for (let i = 1; i < count; ++i) {
                actions.push(this.down({ ...options, clickCount: i }), this.up({ ...options, clickCount: i }));
            }
        }
        actions.push(this.down({ ...options, clickCount }));
        if (typeof delay === 'number') {
            await Promise.all(actions);
            actions.length = 0;
            await new Promise(resolve => {
                setTimeout(resolve, delay);
            });
        }
        actions.push(this.up({ ...options, clickCount }));
        await Promise.all(actions);
    }
    async wheel(options = {}) {
        const { deltaX = 0, deltaY = 0 } = options;
        const { position, buttons } = this.#state;
        await this.#client.send('Input.dispatchMouseEvent', {
            type: 'mouseWheel',
            pointerType: 'mouse',
            modifiers: this.#keyboard._modifiers,
            deltaY,
            deltaX,
            buttons,
            ...position,
        });
    }
    async drag(start, target) {
        const promise = new Promise(resolve => {
            this.#client.once('Input.dragIntercepted', event => {
                return resolve(event.data);
            });
        });
        await this.move(start.x, start.y);
        await this.down();
        await this.move(target.x, target.y);
        return await promise;
    }
    async dragEnter(target, data) {
        await this.#client.send('Input.dispatchDragEvent', {
            type: 'dragEnter',
            x: target.x,
            y: target.y,
            modifiers: this.#keyboard._modifiers,
            data,
        });
    }
    async dragOver(target, data) {
        await this.#client.send('Input.dispatchDragEvent', {
            type: 'dragOver',
            x: target.x,
            y: target.y,
            modifiers: this.#keyboard._modifiers,
            data,
        });
    }
    async drop(target, data) {
        await this.#client.send('Input.dispatchDragEvent', {
            type: 'drop',
            x: target.x,
            y: target.y,
            modifiers: this.#keyboard._modifiers,
            data,
        });
    }
    async dragAndDrop(start, target, options = {}) {
        const { delay = null } = options;
        const data = await this.drag(start, target);
        await this.dragEnter(target, data);
        await this.dragOver(target, data);
        if (delay) {
            await new Promise(resolve => {
                return setTimeout(resolve, delay);
            });
        }
        await this.drop(target, data);
        await this.up();
    }
}
Input$1.CDPMouse = CDPMouse;
/**
 * @internal
 */
class CDPTouchscreen extends Input_js_1$1.Touchscreen {
    #client;
    #keyboard;
    constructor(client, keyboard) {
        super();
        this.#client = client;
        this.#keyboard = keyboard;
    }
    updateClient(client) {
        this.#client = client;
    }
    async tap(x, y) {
        await this.touchStart(x, y);
        await this.touchEnd();
    }
    async touchStart(x, y) {
        const touchPoints = [{ x: Math.round(x), y: Math.round(y) }];
        await this.#client.send('Input.dispatchTouchEvent', {
            type: 'touchStart',
            touchPoints,
            modifiers: this.#keyboard._modifiers,
        });
    }
    async touchMove(x, y) {
        const movePoints = [{ x: Math.round(x), y: Math.round(y) }];
        await this.#client.send('Input.dispatchTouchEvent', {
            type: 'touchMove',
            touchPoints: movePoints,
            modifiers: this.#keyboard._modifiers,
        });
    }
    async touchEnd() {
        await this.#client.send('Input.dispatchTouchEvent', {
            type: 'touchEnd',
            touchPoints: [],
            modifiers: this.#keyboard._modifiers,
        });
    }
}
Input$1.CDPTouchscreen = CDPTouchscreen;

var TimeoutSettings$1 = {};

/**
 * Copyright 2019 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(TimeoutSettings$1, "__esModule", { value: true });
TimeoutSettings$1.TimeoutSettings = void 0;
const DEFAULT_TIMEOUT = 30000;
/**
 * @internal
 */
class TimeoutSettings {
    #defaultTimeout;
    #defaultNavigationTimeout;
    constructor() {
        this.#defaultTimeout = null;
        this.#defaultNavigationTimeout = null;
    }
    setDefaultTimeout(timeout) {
        this.#defaultTimeout = timeout;
    }
    setDefaultNavigationTimeout(timeout) {
        this.#defaultNavigationTimeout = timeout;
    }
    navigationTimeout() {
        if (this.#defaultNavigationTimeout !== null) {
            return this.#defaultNavigationTimeout;
        }
        if (this.#defaultTimeout !== null) {
            return this.#defaultTimeout;
        }
        return DEFAULT_TIMEOUT;
    }
    timeout() {
        if (this.#defaultTimeout !== null) {
            return this.#defaultTimeout;
        }
        return DEFAULT_TIMEOUT;
    }
}
TimeoutSettings$1.TimeoutSettings = TimeoutSettings;

var Tracing$1 = {};

Object.defineProperty(Tracing$1, "__esModule", { value: true });
Tracing$1.Tracing = void 0;
/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const assert_js_1$8 = assert$1;
const Deferred_js_1$5 = Deferred$1;
const ErrorLike_js_1$2 = ErrorLike;
const util_js_1$9 = requireUtil();
/**
 * The Tracing class exposes the tracing audit interface.
 * @remarks
 * You can use `tracing.start` and `tracing.stop` to create a trace file
 * which can be opened in Chrome DevTools or {@link https://chromedevtools.github.io/timeline-viewer/ | timeline viewer}.
 *
 * @example
 *
 * ```ts
 * await page.tracing.start({path: 'trace.json'});
 * await page.goto('https://www.google.com');
 * await page.tracing.stop();
 * ```
 *
 * @public
 */
class Tracing {
    #client;
    #recording = false;
    #path;
    /**
     * @internal
     */
    constructor(client) {
        this.#client = client;
    }
    /**
     * @internal
     */
    updateClient(client) {
        this.#client = client;
    }
    /**
     * Starts a trace for the current page.
     * @remarks
     * Only one trace can be active at a time per browser.
     *
     * @param options - Optional `TracingOptions`.
     */
    async start(options = {}) {
        (0, assert_js_1$8.assert)(!this.#recording, 'Cannot start recording trace while already recording trace.');
        const defaultCategories = [
            '-*',
            'devtools.timeline',
            'v8.execute',
            'disabled-by-default-devtools.timeline',
            'disabled-by-default-devtools.timeline.frame',
            'toplevel',
            'blink.console',
            'blink.user_timing',
            'latencyInfo',
            'disabled-by-default-devtools.timeline.stack',
            'disabled-by-default-v8.cpu_profiler',
        ];
        const { path, screenshots = false, categories = defaultCategories } = options;
        if (screenshots) {
            categories.push('disabled-by-default-devtools.screenshot');
        }
        const excludedCategories = categories
            .filter(cat => {
            return cat.startsWith('-');
        })
            .map(cat => {
            return cat.slice(1);
        });
        const includedCategories = categories.filter(cat => {
            return !cat.startsWith('-');
        });
        this.#path = path;
        this.#recording = true;
        await this.#client.send('Tracing.start', {
            transferMode: 'ReturnAsStream',
            traceConfig: {
                excludedCategories,
                includedCategories,
            },
        });
    }
    /**
     * Stops a trace started with the `start` method.
     * @returns Promise which resolves to buffer with trace data.
     */
    async stop() {
        const contentDeferred = Deferred_js_1$5.Deferred.create();
        this.#client.once('Tracing.tracingComplete', async (event) => {
            try {
                const readable = await (0, util_js_1$9.getReadableFromProtocolStream)(this.#client, event.stream);
                const buffer = await (0, util_js_1$9.getReadableAsBuffer)(readable, this.#path);
                contentDeferred.resolve(buffer ?? undefined);
            }
            catch (error) {
                if ((0, ErrorLike_js_1$2.isErrorLike)(error)) {
                    contentDeferred.reject(error);
                }
                else {
                    contentDeferred.reject(new Error(`Unknown error: ${error}`));
                }
            }
        });
        await this.#client.send('Tracing.end');
        this.#recording = false;
        return await contentDeferred.valueOrThrow();
    }
}
Tracing$1.Tracing = Tracing;

var WebWorker$1 = {};

Object.defineProperty(WebWorker$1, "__esModule", { value: true });
WebWorker$1.WebWorker = void 0;
const EventEmitter_js_1$2 = EventEmitter$1;
const ExecutionContext_js_1 = ExecutionContext$1;
const IsolatedWorld_js_1 = requireIsolatedWorld();
const JSHandle_js_1 = requireJSHandle$1();
const TimeoutSettings_js_1$1 = TimeoutSettings$1;
const util_js_1$8 = requireUtil();
/**
 * This class represents a
 * {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API | WebWorker}.
 *
 * @remarks
 * The events `workercreated` and `workerdestroyed` are emitted on the page
 * object to signal the worker lifecycle.
 *
 * @example
 *
 * ```ts
 * page.on('workercreated', worker =>
 *   console.log('Worker created: ' + worker.url())
 * );
 * page.on('workerdestroyed', worker =>
 *   console.log('Worker destroyed: ' + worker.url())
 * );
 *
 * console.log('Current workers:');
 * for (const worker of page.workers()) {
 *   console.log('  ' + worker.url());
 * }
 * ```
 *
 * @public
 */
class WebWorker extends EventEmitter_js_1$2.EventEmitter {
    /**
     * @internal
     */
    timeoutSettings = new TimeoutSettings_js_1$1.TimeoutSettings();
    #world;
    #client;
    #url;
    /**
     * @internal
     */
    constructor(client, url, consoleAPICalled, exceptionThrown) {
        super();
        this.#client = client;
        this.#url = url;
        this.#world = new IsolatedWorld_js_1.IsolatedWorld(this, new TimeoutSettings_js_1$1.TimeoutSettings());
        this.#client.once('Runtime.executionContextCreated', async (event) => {
            this.#world.setContext(new ExecutionContext_js_1.ExecutionContext(client, event.context, this.#world));
        });
        this.#client.on('Runtime.consoleAPICalled', async (event) => {
            try {
                return consoleAPICalled(event.type, event.args.map((object) => {
                    return new JSHandle_js_1.CDPJSHandle(this.#world, object);
                }), event.stackTrace);
            }
            catch (err) {
                (0, util_js_1$8.debugError)(err);
            }
        });
        this.#client.on('Runtime.exceptionThrown', exceptionThrown);
        // This might fail if the target is closed before we receive all execution contexts.
        this.#client.send('Runtime.enable').catch(util_js_1$8.debugError);
    }
    /**
     * @internal
     */
    mainRealm() {
        return this.#world;
    }
    /**
     * The URL of this web worker.
     */
    url() {
        return this.#url;
    }
    /**
     * The CDP session client the WebWorker belongs to.
     */
    get client() {
        return this.#client;
    }
    /**
     * If the function passed to the `worker.evaluate` returns a Promise, then
     * `worker.evaluate` would wait for the promise to resolve and return its
     * value. If the function passed to the `worker.evaluate` returns a
     * non-serializable value, then `worker.evaluate` resolves to `undefined`.
     * DevTools Protocol also supports transferring some additional values that
     * are not serializable by `JSON`: `-0`, `NaN`, `Infinity`, `-Infinity`, and
     * bigint literals.
     * Shortcut for `await worker.executionContext()).evaluate(pageFunction, ...args)`.
     *
     * @param pageFunction - Function to be evaluated in the worker context.
     * @param args - Arguments to pass to `pageFunction`.
     * @returns Promise which resolves to the return value of `pageFunction`.
     */
    async evaluate(pageFunction, ...args) {
        pageFunction = (0, util_js_1$8.withSourcePuppeteerURLIfNone)(this.evaluate.name, pageFunction);
        return await this.mainRealm().evaluate(pageFunction, ...args);
    }
    /**
     * The only difference between `worker.evaluate` and `worker.evaluateHandle`
     * is that `worker.evaluateHandle` returns in-page object (JSHandle). If the
     * function passed to the `worker.evaluateHandle` returns a `Promise`, then
     * `worker.evaluateHandle` would wait for the promise to resolve and return
     * its value. Shortcut for
     * `await worker.executionContext()).evaluateHandle(pageFunction, ...args)`
     *
     * @param pageFunction - Function to be evaluated in the page context.
     * @param args - Arguments to pass to `pageFunction`.
     * @returns Promise which resolves to the return value of `pageFunction`.
     */
    async evaluateHandle(pageFunction, ...args) {
        pageFunction = (0, util_js_1$8.withSourcePuppeteerURLIfNone)(this.evaluateHandle.name, pageFunction);
        return await this.mainRealm().evaluateHandle(pageFunction, ...args);
    }
}
WebWorker$1.WebWorker = WebWorker;

/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __addDisposableResource = (commonjsGlobal && commonjsGlobal.__addDisposableResource) || function (env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        env.stack.push({ value: value, dispose: dispose, async: async });
    }
    else if (async) {
        env.stack.push({ async: true });
    }
    return value;
};
var __disposeResources = (commonjsGlobal && commonjsGlobal.__disposeResources) || (function (SuppressedError) {
    return function (env) {
        function fail(e) {
            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        function next() {
            while (env.stack.length) {
                var rec = env.stack.pop();
                try {
                    var result = rec.dispose && rec.dispose.call(rec.value);
                    if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
                }
                catch (e) {
                    fail(e);
                }
            }
            if (env.hasError) throw env.error;
        }
        return next();
    };
})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
Object.defineProperty(Page$1, "__esModule", { value: true });
Page$1.CDPPage = void 0;
const Page_js_1$1 = Page$2;
const assert_js_1$7 = assert$1;
const Deferred_js_1$4 = Deferred$1;
const ErrorLike_js_1$1 = ErrorLike;
const Accessibility_js_1 = Accessibility$1;
const Binding_js_1 = Binding$1;
const Connection_js_1$6 = Connection$1;
const ConsoleMessage_js_1 = ConsoleMessage$1;
const Coverage_js_1 = Coverage$1;
const Dialog_js_1 = Dialog$1;
const EmulationManager_js_1 = EmulationManager$2;
const Errors_js_1$1 = Errors;
const FileChooser_js_1 = FileChooser$1;
const FrameManager_js_1 = requireFrameManager();
const Input_js_1 = Input$1;
const IsolatedWorlds_js_1 = IsolatedWorlds;
const NetworkManager_js_1 = NetworkManager$1;
const TimeoutSettings_js_1 = TimeoutSettings$1;
const Tracing_js_1 = Tracing$1;
const util_js_1$7 = requireUtil();
const WebWorker_js_1$1 = WebWorker$1;
/**
 * @internal
 */
class CDPPage extends Page_js_1$1.Page {
    static async _create(client, target, ignoreHTTPSErrors, defaultViewport, screenshotTaskQueue) {
        const page = new CDPPage(client, target, ignoreHTTPSErrors, screenshotTaskQueue);
        await page.#initialize();
        if (defaultViewport) {
            try {
                await page.setViewport(defaultViewport);
            }
            catch (err) {
                if ((0, ErrorLike_js_1$1.isErrorLike)(err) && (0, Connection_js_1$6.isTargetClosedError)(err)) {
                    (0, util_js_1$7.debugError)(err);
                }
                else {
                    throw err;
                }
            }
        }
        return page;
    }
    #closed = false;
    #client;
    #tabSession;
    #target;
    #keyboard;
    #mouse;
    #timeoutSettings = new TimeoutSettings_js_1.TimeoutSettings();
    #touchscreen;
    #accessibility;
    #frameManager;
    #emulationManager;
    #tracing;
    #bindings = new Map();
    #exposedFunctions = new Map();
    #coverage;
    #viewport;
    #screenshotTaskQueue;
    #workers = new Map();
    #fileChooserDeferreds = new Set();
    #sessionCloseDeferred = Deferred_js_1$4.Deferred.create();
    #serviceWorkerBypassed = false;
    #userDragInterceptionEnabled = false;
    #frameManagerHandlers = new Map([
        [
            FrameManager_js_1.FrameManagerEmittedEvents.FrameAttached,
            this.emit.bind(this, "frameattached" /* PageEmittedEvents.FrameAttached */),
        ],
        [
            FrameManager_js_1.FrameManagerEmittedEvents.FrameDetached,
            this.emit.bind(this, "framedetached" /* PageEmittedEvents.FrameDetached */),
        ],
        [
            FrameManager_js_1.FrameManagerEmittedEvents.FrameNavigated,
            this.emit.bind(this, "framenavigated" /* PageEmittedEvents.FrameNavigated */),
        ],
    ]);
    #networkManagerHandlers = new Map([
        [
            NetworkManager_js_1.NetworkManagerEmittedEvents.Request,
            this.emit.bind(this, "request" /* PageEmittedEvents.Request */),
        ],
        [
            NetworkManager_js_1.NetworkManagerEmittedEvents.RequestServedFromCache,
            this.emit.bind(this, "requestservedfromcache" /* PageEmittedEvents.RequestServedFromCache */),
        ],
        [
            NetworkManager_js_1.NetworkManagerEmittedEvents.Response,
            this.emit.bind(this, "response" /* PageEmittedEvents.Response */),
        ],
        [
            NetworkManager_js_1.NetworkManagerEmittedEvents.RequestFailed,
            this.emit.bind(this, "requestfailed" /* PageEmittedEvents.RequestFailed */),
        ],
        [
            NetworkManager_js_1.NetworkManagerEmittedEvents.RequestFinished,
            this.emit.bind(this, "requestfinished" /* PageEmittedEvents.RequestFinished */),
        ],
    ]);
    #sessionHandlers = new Map([
        [
            Connection_js_1$6.CDPSessionEmittedEvents.Disconnected,
            () => {
                return this.#sessionCloseDeferred.resolve(new Errors_js_1$1.TargetCloseError('Target closed'));
            },
        ],
        [
            'Page.domContentEventFired',
            this.emit.bind(this, "domcontentloaded" /* PageEmittedEvents.DOMContentLoaded */),
        ],
        ['Page.loadEventFired', this.emit.bind(this, "load" /* PageEmittedEvents.Load */)],
        ['Runtime.consoleAPICalled', this.#onConsoleAPI.bind(this)],
        ['Runtime.bindingCalled', this.#onBindingCalled.bind(this)],
        ['Page.javascriptDialogOpening', this.#onDialog.bind(this)],
        ['Runtime.exceptionThrown', this.#handleException.bind(this)],
        ['Inspector.targetCrashed', this.#onTargetCrashed.bind(this)],
        ['Performance.metrics', this.#emitMetrics.bind(this)],
        ['Log.entryAdded', this.#onLogEntryAdded.bind(this)],
        ['Page.fileChooserOpened', this.#onFileChooser.bind(this)],
    ]);
    constructor(client, target, ignoreHTTPSErrors, screenshotTaskQueue) {
        super();
        this.#client = client;
        this.#tabSession = client.parentSession();
        this.#target = target;
        this.#keyboard = new Input_js_1.CDPKeyboard(client);
        this.#mouse = new Input_js_1.CDPMouse(client, this.#keyboard);
        this.#touchscreen = new Input_js_1.CDPTouchscreen(client, this.#keyboard);
        this.#accessibility = new Accessibility_js_1.Accessibility(client);
        this.#frameManager = new FrameManager_js_1.FrameManager(client, this, ignoreHTTPSErrors, this.#timeoutSettings);
        this.#emulationManager = new EmulationManager_js_1.EmulationManager(client);
        this.#tracing = new Tracing_js_1.Tracing(client);
        this.#coverage = new Coverage_js_1.Coverage(client);
        this.#screenshotTaskQueue = screenshotTaskQueue;
        this.#viewport = null;
        this.#setupEventListeners();
        this.#tabSession?.on(Connection_js_1$6.CDPSessionEmittedEvents.Swapped, async (newSession) => {
            this.#client = newSession;
            (0, assert_js_1$7.assert)(this.#client instanceof Connection_js_1$6.CDPSessionImpl, 'CDPSession is not instance of CDPSessionImpl');
            this.#target = this.#client._target();
            (0, assert_js_1$7.assert)(this.#target, 'Missing target on swap');
            this.#keyboard.updateClient(newSession);
            this.#mouse.updateClient(newSession);
            this.#touchscreen.updateClient(newSession);
            this.#accessibility.updateClient(newSession);
            this.#emulationManager.updateClient(newSession);
            this.#tracing.updateClient(newSession);
            this.#coverage.updateClient(newSession);
            await this.#frameManager.swapFrameTree(newSession);
            this.#setupEventListeners();
        });
        this.#tabSession?.on(Connection_js_1$6.CDPSessionEmittedEvents.Ready, (session) => {
            if (session._target()._subtype() !== 'prerender') {
                return;
            }
            this.#frameManager
                .registerSpeculativeSession(session)
                .catch(util_js_1$7.debugError);
            this.#emulationManager
                .registerSpeculativeSession(session)
                .catch(util_js_1$7.debugError);
        });
    }
    #setupEventListeners() {
        this.#client.on(Connection_js_1$6.CDPSessionEmittedEvents.Ready, this.#onAttachedToTarget);
        this.#target
            ._targetManager()
            .on("targetGone" /* TargetManagerEmittedEvents.TargetGone */, this.#onDetachedFromTarget);
        for (const [eventName, handler] of this.#frameManagerHandlers) {
            this.#frameManager.on(eventName, handler);
        }
        for (const [eventName, handler] of this.#networkManagerHandlers) {
            this.#frameManager.networkManager.on(eventName, handler);
        }
        for (const [eventName, handler] of this.#sessionHandlers) {
            this.#client.on(eventName, handler);
        }
        this.#target._isClosedDeferred
            .valueOrThrow()
            .then(() => {
            this.#client.off(Connection_js_1$6.CDPSessionEmittedEvents.Ready, this.#onAttachedToTarget);
            this.#target
                ._targetManager()
                .off("targetGone" /* TargetManagerEmittedEvents.TargetGone */, this.#onDetachedFromTarget);
            this.emit("close" /* PageEmittedEvents.Close */);
            this.#closed = true;
        })
            .catch(util_js_1$7.debugError);
    }
    #onDetachedFromTarget = (target) => {
        const sessionId = target._session()?.id();
        const worker = this.#workers.get(sessionId);
        if (!worker) {
            return;
        }
        this.#workers.delete(sessionId);
        this.emit("workerdestroyed" /* PageEmittedEvents.WorkerDestroyed */, worker);
    };
    #onAttachedToTarget = (session) => {
        this.#frameManager.onAttachedToTarget(session._target());
        if (session._target()._getTargetInfo().type === 'worker') {
            const worker = new WebWorker_js_1$1.WebWorker(session, session._target().url(), this.#addConsoleMessage.bind(this), this.#handleException.bind(this));
            this.#workers.set(session.id(), worker);
            this.emit("workercreated" /* PageEmittedEvents.WorkerCreated */, worker);
        }
        session.on(Connection_js_1$6.CDPSessionEmittedEvents.Ready, this.#onAttachedToTarget);
    };
    async #initialize() {
        try {
            await Promise.all([
                this.#frameManager.initialize(this.#client),
                this.#client.send('Performance.enable'),
                this.#client.send('Log.enable'),
            ]);
        }
        catch (err) {
            if ((0, ErrorLike_js_1$1.isErrorLike)(err) && (0, Connection_js_1$6.isTargetClosedError)(err)) {
                (0, util_js_1$7.debugError)(err);
            }
            else {
                throw err;
            }
        }
    }
    async #onFileChooser(event) {
        const env_1 = { stack: [], error: void 0, hasError: false };
        try {
            if (!this.#fileChooserDeferreds.size) {
                return;
            }
            const frame = this.#frameManager.frame(event.frameId);
            (0, assert_js_1$7.assert)(frame, 'This should never happen.');
            // This is guaranteed to be an HTMLInputElement handle by the event.
            const handle = __addDisposableResource(env_1, (await frame.worlds[IsolatedWorlds_js_1.MAIN_WORLD].adoptBackendNode(event.backendNodeId)), false);
            const fileChooser = new FileChooser_js_1.FileChooser(handle.move(), event);
            for (const promise of this.#fileChooserDeferreds) {
                promise.resolve(fileChooser);
            }
            this.#fileChooserDeferreds.clear();
        }
        catch (e_1) {
            env_1.error = e_1;
            env_1.hasError = true;
        }
        finally {
            __disposeResources(env_1);
        }
    }
    _client() {
        return this.#client;
    }
    isServiceWorkerBypassed() {
        return this.#serviceWorkerBypassed;
    }
    isDragInterceptionEnabled() {
        return this.#userDragInterceptionEnabled;
    }
    isJavaScriptEnabled() {
        return this.#emulationManager.javascriptEnabled;
    }
    async waitForFileChooser(options = {}) {
        const needsEnable = this.#fileChooserDeferreds.size === 0;
        const { timeout = this.#timeoutSettings.timeout() } = options;
        const deferred = Deferred_js_1$4.Deferred.create({
            message: `Waiting for \`FileChooser\` failed: ${timeout}ms exceeded`,
            timeout,
        });
        this.#fileChooserDeferreds.add(deferred);
        let enablePromise;
        if (needsEnable) {
            enablePromise = this.#client.send('Page.setInterceptFileChooserDialog', {
                enabled: true,
            });
        }
        try {
            const [result] = await Promise.all([
                deferred.valueOrThrow(),
                enablePromise,
            ]);
            return result;
        }
        catch (error) {
            this.#fileChooserDeferreds.delete(deferred);
            throw error;
        }
    }
    async setGeolocation(options) {
        return await this.#emulationManager.setGeolocation(options);
    }
    target() {
        return this.#target;
    }
    browser() {
        return this.#target.browser();
    }
    browserContext() {
        return this.#target.browserContext();
    }
    #onTargetCrashed() {
        this.emit('error', new Error('Page crashed!'));
    }
    #onLogEntryAdded(event) {
        const { level, text, args, source, url, lineNumber } = event.entry;
        if (args) {
            args.map(arg => {
                return (0, util_js_1$7.releaseObject)(this.#client, arg);
            });
        }
        if (source !== 'worker') {
            this.emit("console" /* PageEmittedEvents.Console */, new ConsoleMessage_js_1.ConsoleMessage(level, text, [], [{ url, lineNumber }]));
        }
    }
    mainFrame() {
        return this.#frameManager.mainFrame();
    }
    get keyboard() {
        return this.#keyboard;
    }
    get touchscreen() {
        return this.#touchscreen;
    }
    get coverage() {
        return this.#coverage;
    }
    get tracing() {
        return this.#tracing;
    }
    get accessibility() {
        return this.#accessibility;
    }
    frames() {
        return this.#frameManager.frames();
    }
    workers() {
        return Array.from(this.#workers.values());
    }
    async setRequestInterception(value) {
        return await this.#frameManager.networkManager.setRequestInterception(value);
    }
    async setBypassServiceWorker(bypass) {
        this.#serviceWorkerBypassed = bypass;
        return await this.#client.send('Network.setBypassServiceWorker', { bypass });
    }
    async setDragInterception(enabled) {
        this.#userDragInterceptionEnabled = enabled;
        return await this.#client.send('Input.setInterceptDrags', { enabled });
    }
    async setOfflineMode(enabled) {
        return await this.#frameManager.networkManager.setOfflineMode(enabled);
    }
    async emulateNetworkConditions(networkConditions) {
        return await this.#frameManager.networkManager.emulateNetworkConditions(networkConditions);
    }
    setDefaultNavigationTimeout(timeout) {
        this.#timeoutSettings.setDefaultNavigationTimeout(timeout);
    }
    setDefaultTimeout(timeout) {
        this.#timeoutSettings.setDefaultTimeout(timeout);
    }
    getDefaultTimeout() {
        return this.#timeoutSettings.timeout();
    }
    async queryObjects(prototypeHandle) {
        (0, assert_js_1$7.assert)(!prototypeHandle.disposed, 'Prototype JSHandle is disposed!');
        (0, assert_js_1$7.assert)(prototypeHandle.id, 'Prototype JSHandle must not be referencing primitive value');
        const response = await this.mainFrame().client.send('Runtime.queryObjects', {
            prototypeObjectId: prototypeHandle.id,
        });
        return (0, util_js_1$7.createCdpHandle)(this.mainFrame().mainRealm(), response.objects);
    }
    async cookies(...urls) {
        const originalCookies = (await this.#client.send('Network.getCookies', {
            urls: urls.length ? urls : [this.url()],
        })).cookies;
        const unsupportedCookieAttributes = ['priority'];
        const filterUnsupportedAttributes = (cookie) => {
            for (const attr of unsupportedCookieAttributes) {
                delete cookie[attr];
            }
            return cookie;
        };
        return originalCookies.map(filterUnsupportedAttributes);
    }
    async deleteCookie(...cookies) {
        const pageURL = this.url();
        for (const cookie of cookies) {
            const item = Object.assign({}, cookie);
            if (!cookie.url && pageURL.startsWith('http')) {
                item.url = pageURL;
            }
            await this.#client.send('Network.deleteCookies', item);
        }
    }
    async setCookie(...cookies) {
        const pageURL = this.url();
        const startsWithHTTP = pageURL.startsWith('http');
        const items = cookies.map(cookie => {
            const item = Object.assign({}, cookie);
            if (!item.url && startsWithHTTP) {
                item.url = pageURL;
            }
            (0, assert_js_1$7.assert)(item.url !== 'about:blank', `Blank page can not have cookie "${item.name}"`);
            (0, assert_js_1$7.assert)(!String.prototype.startsWith.call(item.url || '', 'data:'), `Data URL page can not have cookie "${item.name}"`);
            return item;
        });
        await this.deleteCookie(...items);
        if (items.length) {
            await this.#client.send('Network.setCookies', { cookies: items });
        }
    }
    async exposeFunction(name, pptrFunction) {
        if (this.#bindings.has(name)) {
            throw new Error(`Failed to add page binding with name ${name}: window['${name}'] already exists!`);
        }
        let binding;
        switch (typeof pptrFunction) {
            case 'function':
                binding = new Binding_js_1.Binding(name, pptrFunction);
                break;
            default:
                binding = new Binding_js_1.Binding(name, pptrFunction.default);
                break;
        }
        this.#bindings.set(name, binding);
        const expression = (0, util_js_1$7.pageBindingInitString)('exposedFun', name);
        await this.#client.send('Runtime.addBinding', { name });
        const { identifier } = await this.#client.send('Page.addScriptToEvaluateOnNewDocument', {
            source: expression,
        });
        this.#exposedFunctions.set(name, identifier);
        await Promise.all(this.frames().map(frame => {
            return frame.evaluate(expression).catch(util_js_1$7.debugError);
        }));
    }
    async removeExposedFunction(name) {
        const exposedFun = this.#exposedFunctions.get(name);
        if (!exposedFun) {
            throw new Error(`Failed to remove page binding with name ${name}: window['${name}'] does not exists!`);
        }
        await this.#client.send('Runtime.removeBinding', { name });
        await this.removeScriptToEvaluateOnNewDocument(exposedFun);
        await Promise.all(this.frames().map(frame => {
            return frame
                .evaluate(name => {
                // Removes the dangling Puppeteer binding wrapper.
                // @ts-expect-error: In a different context.
                globalThis[name] = undefined;
            }, name)
                .catch(util_js_1$7.debugError);
        }));
        this.#exposedFunctions.delete(name);
        this.#bindings.delete(name);
    }
    async authenticate(credentials) {
        return await this.#frameManager.networkManager.authenticate(credentials);
    }
    async setExtraHTTPHeaders(headers) {
        return await this.#frameManager.networkManager.setExtraHTTPHeaders(headers);
    }
    async setUserAgent(userAgent, userAgentMetadata) {
        return await this.#frameManager.networkManager.setUserAgent(userAgent, userAgentMetadata);
    }
    async metrics() {
        const response = await this.#client.send('Performance.getMetrics');
        return this.#buildMetricsObject(response.metrics);
    }
    #emitMetrics(event) {
        this.emit("metrics" /* PageEmittedEvents.Metrics */, {
            title: event.title,
            metrics: this.#buildMetricsObject(event.metrics),
        });
    }
    #buildMetricsObject(metrics) {
        const result = {};
        for (const metric of metrics || []) {
            if (supportedMetrics.has(metric.name)) {
                result[metric.name] = metric.value;
            }
        }
        return result;
    }
    #handleException(exception) {
        this.emit("pageerror" /* PageEmittedEvents.PageError */, (0, util_js_1$7.createClientError)(exception.exceptionDetails));
    }
    async #onConsoleAPI(event) {
        if (event.executionContextId === 0) {
            // DevTools protocol stores the last 1000 console messages. These
            // messages are always reported even for removed execution contexts. In
            // this case, they are marked with executionContextId = 0 and are
            // reported upon enabling Runtime agent.
            //
            // Ignore these messages since:
            // - there's no execution context we can use to operate with message
            //   arguments
            // - these messages are reported before Puppeteer clients can subscribe
            //   to the 'console'
            //   page event.
            //
            // @see https://github.com/puppeteer/puppeteer/issues/3865
            return;
        }
        const context = this.#frameManager.getExecutionContextById(event.executionContextId, this.#client);
        if (!context) {
            (0, util_js_1$7.debugError)(new Error(`ExecutionContext not found for a console message: ${JSON.stringify(event)}`));
            return;
        }
        const values = event.args.map(arg => {
            return (0, util_js_1$7.createCdpHandle)(context._world, arg);
        });
        this.#addConsoleMessage(event.type, values, event.stackTrace);
    }
    async #onBindingCalled(event) {
        let payload;
        try {
            payload = JSON.parse(event.payload);
        }
        catch {
            // The binding was either called by something in the page or it was
            // called before our wrapper was initialized.
            return;
        }
        const { type, name, seq, args, isTrivial } = payload;
        if (type !== 'exposedFun') {
            return;
        }
        const context = this.#frameManager.executionContextById(event.executionContextId, this.#client);
        if (!context) {
            return;
        }
        const binding = this.#bindings.get(name);
        await binding?.run(context, seq, args, isTrivial);
    }
    #addConsoleMessage(eventType, args, stackTrace) {
        if (!this.listenerCount("console" /* PageEmittedEvents.Console */)) {
            args.forEach(arg => {
                return arg.dispose();
            });
            return;
        }
        const textTokens = [];
        // eslint-disable-next-line max-len -- The comment is long.
        // eslint-disable-next-line rulesdir/use-using -- These are not owned by this function.
        for (const arg of args) {
            const remoteObject = arg.remoteObject();
            if (remoteObject.objectId) {
                textTokens.push(arg.toString());
            }
            else {
                textTokens.push((0, util_js_1$7.valueFromRemoteObject)(remoteObject));
            }
        }
        const stackTraceLocations = [];
        if (stackTrace) {
            for (const callFrame of stackTrace.callFrames) {
                stackTraceLocations.push({
                    url: callFrame.url,
                    lineNumber: callFrame.lineNumber,
                    columnNumber: callFrame.columnNumber,
                });
            }
        }
        const message = new ConsoleMessage_js_1.ConsoleMessage(eventType, textTokens.join(' '), args, stackTraceLocations);
        this.emit("console" /* PageEmittedEvents.Console */, message);
    }
    #onDialog(event) {
        const type = (0, util_js_1$7.validateDialogType)(event.type);
        const dialog = new Dialog_js_1.CDPDialog(this.#client, type, event.message, event.defaultPrompt);
        this.emit("dialog" /* PageEmittedEvents.Dialog */, dialog);
    }
    async reload(options) {
        const result = await Promise.all([
            this.waitForNavigation(options),
            this.#client.send('Page.reload'),
        ]);
        return result[0];
    }
    async createCDPSession() {
        return await this.target().createCDPSession();
    }
    async waitForRequest(urlOrPredicate, options = {}) {
        const { timeout = this.#timeoutSettings.timeout() } = options;
        return await (0, util_js_1$7.waitForEvent)(this.#frameManager.networkManager, NetworkManager_js_1.NetworkManagerEmittedEvents.Request, async (request) => {
            if ((0, util_js_1$7.isString)(urlOrPredicate)) {
                return urlOrPredicate === request.url();
            }
            if (typeof urlOrPredicate === 'function') {
                return !!(await urlOrPredicate(request));
            }
            return false;
        }, timeout, this.#sessionCloseDeferred.valueOrThrow());
    }
    async waitForResponse(urlOrPredicate, options = {}) {
        const { timeout = this.#timeoutSettings.timeout() } = options;
        return await (0, util_js_1$7.waitForEvent)(this.#frameManager.networkManager, NetworkManager_js_1.NetworkManagerEmittedEvents.Response, async (response) => {
            if ((0, util_js_1$7.isString)(urlOrPredicate)) {
                return urlOrPredicate === response.url();
            }
            if (typeof urlOrPredicate === 'function') {
                return !!(await urlOrPredicate(response));
            }
            return false;
        }, timeout, this.#sessionCloseDeferred.valueOrThrow());
    }
    async waitForNetworkIdle(options = {}) {
        const { idleTime = 500, timeout = this.#timeoutSettings.timeout() } = options;
        await this._waitForNetworkIdle(this.#frameManager.networkManager, idleTime, timeout, this.#sessionCloseDeferred);
    }
    async goBack(options = {}) {
        return await this.#go(-1, options);
    }
    async goForward(options = {}) {
        return await this.#go(+1, options);
    }
    async #go(delta, options) {
        const history = await this.#client.send('Page.getNavigationHistory');
        const entry = history.entries[history.currentIndex + delta];
        if (!entry) {
            return null;
        }
        const result = await Promise.all([
            this.waitForNavigation(options),
            this.#client.send('Page.navigateToHistoryEntry', { entryId: entry.id }),
        ]);
        return result[0];
    }
    async bringToFront() {
        await this.#client.send('Page.bringToFront');
    }
    async setJavaScriptEnabled(enabled) {
        return await this.#emulationManager.setJavaScriptEnabled(enabled);
    }
    async setBypassCSP(enabled) {
        await this.#client.send('Page.setBypassCSP', { enabled });
    }
    async emulateMediaType(type) {
        return await this.#emulationManager.emulateMediaType(type);
    }
    async emulateCPUThrottling(factor) {
        return await this.#emulationManager.emulateCPUThrottling(factor);
    }
    async emulateMediaFeatures(features) {
        return await this.#emulationManager.emulateMediaFeatures(features);
    }
    async emulateTimezone(timezoneId) {
        return await this.#emulationManager.emulateTimezone(timezoneId);
    }
    async emulateIdleState(overrides) {
        return await this.#emulationManager.emulateIdleState(overrides);
    }
    async emulateVisionDeficiency(type) {
        return await this.#emulationManager.emulateVisionDeficiency(type);
    }
    async setViewport(viewport) {
        const needsReload = await this.#emulationManager.emulateViewport(viewport);
        this.#viewport = viewport;
        if (needsReload) {
            await this.reload();
        }
    }
    viewport() {
        return this.#viewport;
    }
    async evaluateOnNewDocument(pageFunction, ...args) {
        const source = (0, util_js_1$7.evaluationString)(pageFunction, ...args);
        const { identifier } = await this.#client.send('Page.addScriptToEvaluateOnNewDocument', {
            source,
        });
        return { identifier };
    }
    async removeScriptToEvaluateOnNewDocument(identifier) {
        await this.#client.send('Page.removeScriptToEvaluateOnNewDocument', {
            identifier,
        });
    }
    async setCacheEnabled(enabled = true) {
        await this.#frameManager.networkManager.setCacheEnabled(enabled);
    }
    async screenshot(options = {}) {
        let screenshotType = "png" /* Protocol.Page.CaptureScreenshotRequestFormat.Png */;
        // options.type takes precedence over inferring the type from options.path
        // because it may be a 0-length file with no extension created beforehand
        // (i.e. as a temp file).
        if (options.type) {
            screenshotType =
                options.type;
        }
        else if (options.path) {
            const filePath = options.path;
            const extension = filePath
                .slice(filePath.lastIndexOf('.') + 1)
                .toLowerCase();
            switch (extension) {
                case 'png':
                    screenshotType = "png" /* Protocol.Page.CaptureScreenshotRequestFormat.Png */;
                    break;
                case 'jpeg':
                case 'jpg':
                    screenshotType = "jpeg" /* Protocol.Page.CaptureScreenshotRequestFormat.Jpeg */;
                    break;
                case 'webp':
                    screenshotType = "webp" /* Protocol.Page.CaptureScreenshotRequestFormat.Webp */;
                    break;
                default:
                    throw new Error(`Unsupported screenshot type for extension \`.${extension}\``);
            }
        }
        if (options.quality) {
            (0, assert_js_1$7.assert)(screenshotType === "jpeg" /* Protocol.Page.CaptureScreenshotRequestFormat.Jpeg */ ||
                screenshotType === "webp" /* Protocol.Page.CaptureScreenshotRequestFormat.Webp */, 'options.quality is unsupported for the ' +
                screenshotType +
                ' screenshots');
            (0, assert_js_1$7.assert)(typeof options.quality === 'number', 'Expected options.quality to be a number but found ' +
                typeof options.quality);
            (0, assert_js_1$7.assert)(Number.isInteger(options.quality), 'Expected options.quality to be an integer');
            (0, assert_js_1$7.assert)(options.quality >= 0 && options.quality <= 100, 'Expected options.quality to be between 0 and 100 (inclusive), got ' +
                options.quality);
        }
        (0, assert_js_1$7.assert)(!options.clip || !options.fullPage, 'options.clip and options.fullPage are exclusive');
        if (options.clip) {
            (0, assert_js_1$7.assert)(typeof options.clip.x === 'number', 'Expected options.clip.x to be a number but found ' +
                typeof options.clip.x);
            (0, assert_js_1$7.assert)(typeof options.clip.y === 'number', 'Expected options.clip.y to be a number but found ' +
                typeof options.clip.y);
            (0, assert_js_1$7.assert)(typeof options.clip.width === 'number', 'Expected options.clip.width to be a number but found ' +
                typeof options.clip.width);
            (0, assert_js_1$7.assert)(typeof options.clip.height === 'number', 'Expected options.clip.height to be a number but found ' +
                typeof options.clip.height);
            (0, assert_js_1$7.assert)(options.clip.width !== 0, 'Expected options.clip.width not to be 0.');
            (0, assert_js_1$7.assert)(options.clip.height !== 0, 'Expected options.clip.height not to be 0.');
        }
        return await this.#screenshotTaskQueue.postTask(() => {
            return this.#screenshotTask(screenshotType, options);
        });
    }
    async #screenshotTask(format, options = {}) {
        await this.#client.send('Target.activateTarget', {
            targetId: this.#target._targetId,
        });
        let clip = options.clip ? processClip(options.clip) : undefined;
        let captureBeyondViewport = options.captureBeyondViewport ?? true;
        const fromSurface = options.fromSurface;
        if (options.fullPage) {
            // Overwrite clip for full page.
            clip = undefined;
            if (!captureBeyondViewport) {
                const metrics = await this.#client.send('Page.getLayoutMetrics');
                // Fallback to `contentSize` in case of using Firefox.
                const { width, height } = metrics.cssContentSize || metrics.contentSize;
                const { isMobile = false, deviceScaleFactor = 1, isLandscape = false, } = this.#viewport || {};
                const screenOrientation = isLandscape
                    ? { angle: 90, type: 'landscapePrimary' }
                    : { angle: 0, type: 'portraitPrimary' };
                await this.#client.send('Emulation.setDeviceMetricsOverride', {
                    mobile: isMobile,
                    width,
                    height,
                    deviceScaleFactor,
                    screenOrientation,
                });
            }
        }
        else if (!clip) {
            captureBeyondViewport = false;
        }
        const shouldSetDefaultBackground = options.omitBackground && (format === 'png' || format === 'webp');
        if (shouldSetDefaultBackground) {
            await this.#emulationManager.setTransparentBackgroundColor();
        }
        const result = await this.#client.send('Page.captureScreenshot', {
            format,
            optimizeForSpeed: options.optimizeForSpeed,
            quality: options.quality,
            clip: clip && {
                ...clip,
                scale: clip.scale ?? 1,
            },
            captureBeyondViewport,
            fromSurface,
        });
        if (shouldSetDefaultBackground) {
            await this.#emulationManager.resetDefaultBackgroundColor();
        }
        if (options.fullPage && this.#viewport) {
            await this.setViewport(this.#viewport);
        }
        if (options.encoding === 'base64') {
            return result.data;
        }
        const buffer = Buffer.from(result.data, 'base64');
        await this._maybeWriteBufferToFile(options.path, buffer);
        return buffer;
        function processClip(clip) {
            const x = Math.round(clip.x);
            const y = Math.round(clip.y);
            const width = Math.round(clip.width + clip.x - x);
            const height = Math.round(clip.height + clip.y - y);
            return { x, y, width, height, scale: clip.scale };
        }
    }
    async createPDFStream(options = {}) {
        const { landscape, displayHeaderFooter, headerTemplate, footerTemplate, printBackground, scale, width: paperWidth, height: paperHeight, margin, pageRanges, preferCSSPageSize, omitBackground, timeout, } = this._getPDFOptions(options);
        if (omitBackground) {
            await this.#emulationManager.setTransparentBackgroundColor();
        }
        const printCommandPromise = this.#client.send('Page.printToPDF', {
            transferMode: 'ReturnAsStream',
            landscape,
            displayHeaderFooter,
            headerTemplate,
            footerTemplate,
            printBackground,
            scale,
            paperWidth,
            paperHeight,
            marginTop: margin.top,
            marginBottom: margin.bottom,
            marginLeft: margin.left,
            marginRight: margin.right,
            pageRanges,
            preferCSSPageSize,
        });
        const result = await (0, util_js_1$7.waitWithTimeout)(printCommandPromise, 'Page.printToPDF', timeout);
        if (omitBackground) {
            await this.#emulationManager.resetDefaultBackgroundColor();
        }
        (0, assert_js_1$7.assert)(result.stream, '`stream` is missing from `Page.printToPDF');
        return await (0, util_js_1$7.getReadableFromProtocolStream)(this.#client, result.stream);
    }
    async pdf(options = {}) {
        const { path = undefined } = options;
        const readable = await this.createPDFStream(options);
        const buffer = await (0, util_js_1$7.getReadableAsBuffer)(readable, path);
        (0, assert_js_1$7.assert)(buffer, 'Could not create buffer');
        return buffer;
    }
    async close(options = { runBeforeUnload: undefined }) {
        const connection = this.#client.connection();
        (0, assert_js_1$7.assert)(connection, 'Protocol error: Connection closed. Most likely the page has been closed.');
        const runBeforeUnload = !!options.runBeforeUnload;
        if (runBeforeUnload) {
            await this.#client.send('Page.close');
        }
        else {
            await connection.send('Target.closeTarget', {
                targetId: this.#target._targetId,
            });
            await this.#target._isClosedDeferred.valueOrThrow();
        }
    }
    isClosed() {
        return this.#closed;
    }
    get mouse() {
        return this.#mouse;
    }
    /**
     * This method is typically coupled with an action that triggers a device
     * request from an api such as WebBluetooth.
     *
     * :::caution
     *
     * This must be called before the device request is made. It will not return a
     * currently active device prompt.
     *
     * :::
     *
     * @example
     *
     * ```ts
     * const [devicePrompt] = Promise.all([
     *   page.waitForDevicePrompt(),
     *   page.click('#connect-bluetooth'),
     * ]);
     * await devicePrompt.select(
     *   await devicePrompt.waitForDevice(({name}) => name.includes('My Device'))
     * );
     * ```
     */
    async waitForDevicePrompt(options = {}) {
        return await this.mainFrame().waitForDevicePrompt(options);
    }
}
Page$1.CDPPage = CDPPage;
const supportedMetrics = new Set([
    'Timestamp',
    'Documents',
    'Frames',
    'JSEventListeners',
    'Nodes',
    'LayoutCount',
    'RecalcStyleCount',
    'LayoutDuration',
    'RecalcStyleDuration',
    'ScriptDuration',
    'TaskDuration',
    'JSHeapUsedSize',
    'JSHeapTotalSize',
]);

/**
 * Copyright 2019 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(Target$1, "__esModule", { value: true });
Target$1.OtherTarget = Target$1.WorkerTarget = Target$1.DevToolsTarget = Target$1.PageTarget = Target$1.CDPTarget = Target$1.InitializationStatus = void 0;
const Target_js_1$2 = Target$3;
const Deferred_js_1$3 = Deferred$1;
const Connection_js_1$5 = Connection$1;
const Page_js_1 = Page$1;
const util_js_1$6 = requireUtil();
const WebWorker_js_1 = WebWorker$1;
/**
 * @internal
 */
var InitializationStatus;
(function (InitializationStatus) {
    InitializationStatus["SUCCESS"] = "success";
    InitializationStatus["ABORTED"] = "aborted";
})(InitializationStatus || (Target$1.InitializationStatus = InitializationStatus = {}));
/**
 * @internal
 */
class CDPTarget extends Target_js_1$2.Target {
    #browserContext;
    #session;
    #targetInfo;
    #targetManager;
    #sessionFactory;
    _initializedDeferred = Deferred_js_1$3.Deferred.create();
    _isClosedDeferred = Deferred_js_1$3.Deferred.create();
    _targetId;
    /**
     * To initialize the target for use, call initialize.
     *
     * @internal
     */
    constructor(targetInfo, session, browserContext, targetManager, sessionFactory) {
        super();
        this.#session = session;
        this.#targetManager = targetManager;
        this.#targetInfo = targetInfo;
        this.#browserContext = browserContext;
        this._targetId = targetInfo.targetId;
        this.#sessionFactory = sessionFactory;
        if (this.#session && this.#session instanceof Connection_js_1$5.CDPSessionImpl) {
            this.#session._setTarget(this);
        }
    }
    _subtype() {
        return this.#targetInfo.subtype;
    }
    _session() {
        return this.#session;
    }
    _sessionFactory() {
        if (!this.#sessionFactory) {
            throw new Error('sessionFactory is not initialized');
        }
        return this.#sessionFactory;
    }
    createCDPSession() {
        if (!this.#sessionFactory) {
            throw new Error('sessionFactory is not initialized');
        }
        return this.#sessionFactory(false).then(session => {
            session._setTarget(this);
            return session;
        });
    }
    url() {
        return this.#targetInfo.url;
    }
    type() {
        const type = this.#targetInfo.type;
        switch (type) {
            case 'page':
                return Target_js_1$2.TargetType.PAGE;
            case 'background_page':
                return Target_js_1$2.TargetType.BACKGROUND_PAGE;
            case 'service_worker':
                return Target_js_1$2.TargetType.SERVICE_WORKER;
            case 'shared_worker':
                return Target_js_1$2.TargetType.SHARED_WORKER;
            case 'browser':
                return Target_js_1$2.TargetType.BROWSER;
            case 'webview':
                return Target_js_1$2.TargetType.WEBVIEW;
            case 'tab':
                return Target_js_1$2.TargetType.TAB;
            default:
                return Target_js_1$2.TargetType.OTHER;
        }
    }
    _targetManager() {
        if (!this.#targetManager) {
            throw new Error('targetManager is not initialized');
        }
        return this.#targetManager;
    }
    _getTargetInfo() {
        return this.#targetInfo;
    }
    browser() {
        if (!this.#browserContext) {
            throw new Error('browserContext is not initialised');
        }
        return this.#browserContext.browser();
    }
    browserContext() {
        if (!this.#browserContext) {
            throw new Error('browserContext is not initialised');
        }
        return this.#browserContext;
    }
    opener() {
        const { openerId } = this.#targetInfo;
        if (!openerId) {
            return;
        }
        return this.browser()._targets.get(openerId);
    }
    _targetInfoChanged(targetInfo) {
        this.#targetInfo = targetInfo;
        this._checkIfInitialized();
    }
    _initialize() {
        this._initializedDeferred.resolve(InitializationStatus.SUCCESS);
    }
    _checkIfInitialized() {
        if (!this._initializedDeferred.resolved()) {
            this._initializedDeferred.resolve(InitializationStatus.SUCCESS);
        }
    }
}
Target$1.CDPTarget = CDPTarget;
/**
 * @internal
 */
class PageTarget extends CDPTarget {
    #defaultViewport;
    pagePromise;
    #screenshotTaskQueue;
    #ignoreHTTPSErrors;
    constructor(targetInfo, session, browserContext, targetManager, sessionFactory, ignoreHTTPSErrors, defaultViewport, screenshotTaskQueue) {
        super(targetInfo, session, browserContext, targetManager, sessionFactory);
        this.#ignoreHTTPSErrors = ignoreHTTPSErrors;
        this.#defaultViewport = defaultViewport ?? undefined;
        this.#screenshotTaskQueue = screenshotTaskQueue;
    }
    _initialize() {
        this._initializedDeferred
            .valueOrThrow()
            .then(async (result) => {
            if (result === InitializationStatus.ABORTED) {
                return;
            }
            const opener = this.opener();
            if (!(opener instanceof PageTarget)) {
                return;
            }
            if (!opener || !opener.pagePromise || this.type() !== 'page') {
                return true;
            }
            const openerPage = await opener.pagePromise;
            if (!openerPage.listenerCount("popup" /* PageEmittedEvents.Popup */)) {
                return true;
            }
            const popupPage = await this.page();
            openerPage.emit("popup" /* PageEmittedEvents.Popup */, popupPage);
            return true;
        })
            .catch(util_js_1$6.debugError);
        this._checkIfInitialized();
    }
    async page() {
        if (!this.pagePromise) {
            const session = this._session();
            this.pagePromise = (session
                ? Promise.resolve(session)
                : this._sessionFactory()(/* isAutoAttachEmulated=*/ false)).then(client => {
                return Page_js_1.CDPPage._create(client, this, this.#ignoreHTTPSErrors, this.#defaultViewport ?? null, this.#screenshotTaskQueue);
            });
        }
        return (await this.pagePromise) ?? null;
    }
    _checkIfInitialized() {
        if (this._initializedDeferred.resolved()) {
            return;
        }
        if (this._getTargetInfo().url !== '') {
            this._initializedDeferred.resolve(InitializationStatus.SUCCESS);
        }
    }
}
Target$1.PageTarget = PageTarget;
/**
 * @internal
 */
class DevToolsTarget extends PageTarget {
}
Target$1.DevToolsTarget = DevToolsTarget;
/**
 * @internal
 */
class WorkerTarget extends CDPTarget {
    #workerPromise;
    async worker() {
        if (!this.#workerPromise) {
            const session = this._session();
            // TODO(einbinder): Make workers send their console logs.
            this.#workerPromise = (session
                ? Promise.resolve(session)
                : this._sessionFactory()(/* isAutoAttachEmulated=*/ false)).then(client => {
                return new WebWorker_js_1.WebWorker(client, this._getTargetInfo().url, () => { } /* consoleAPICalled */, () => { } /* exceptionThrown */);
            });
        }
        return await this.#workerPromise;
    }
}
Target$1.WorkerTarget = WorkerTarget;
/**
 * @internal
 */
class OtherTarget extends CDPTarget {
}
Target$1.OtherTarget = OtherTarget;

/**
 * Copyright 2022 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(ChromeTargetManager$1, "__esModule", { value: true });
ChromeTargetManager$1.ChromeTargetManager = void 0;
const Target_js_1$1 = Target$3;
const assert_js_1$6 = assert$1;
const Deferred_js_1$2 = Deferred$1;
const Connection_js_1$4 = Connection$1;
const EventEmitter_js_1$1 = EventEmitter$1;
const Target_js_2 = Target$1;
const util_js_1$5 = requireUtil();
function isTargetExposed(target) {
    return target.type() !== Target_js_1$1.TargetType.TAB && !target._subtype();
}
function isPageTargetBecomingPrimary(target, newTargetInfo) {
    return Boolean(target._subtype()) && !newTargetInfo.subtype;
}
/**
 * ChromeTargetManager uses the CDP's auto-attach mechanism to intercept
 * new targets and allow the rest of Puppeteer to configure listeners while
 * the target is paused.
 *
 * @internal
 */
class ChromeTargetManager extends EventEmitter_js_1$1.EventEmitter {
    #connection;
    /**
     * Keeps track of the following events: 'Target.targetCreated',
     * 'Target.targetDestroyed', 'Target.targetInfoChanged'.
     *
     * A target becomes discovered when 'Target.targetCreated' is received.
     * A target is removed from this map once 'Target.targetDestroyed' is
     * received.
     *
     * `targetFilterCallback` has no effect on this map.
     */
    #discoveredTargetsByTargetId = new Map();
    /**
     * A target is added to this map once ChromeTargetManager has created
     * a Target and attached at least once to it.
     */
    #attachedTargetsByTargetId = new Map();
    /**
     * Tracks which sessions attach to which target.
     */
    #attachedTargetsBySessionId = new Map();
    /**
     * If a target was filtered out by `targetFilterCallback`, we still receive
     * events about it from CDP, but we don't forward them to the rest of Puppeteer.
     */
    #ignoredTargets = new Set();
    #targetFilterCallback;
    #targetFactory;
    #attachedToTargetListenersBySession = new WeakMap();
    #detachedFromTargetListenersBySession = new WeakMap();
    #initializeDeferred = Deferred_js_1$2.Deferred.create();
    #targetsIdsForInit = new Set();
    #waitForInitiallyDiscoveredTargets = true;
    // TODO: remove the flag once the testing/rollout is done.
    #tabMode;
    #discoveryFilter;
    constructor(connection, targetFactory, targetFilterCallback, waitForInitiallyDiscoveredTargets = true, useTabTarget = false) {
        super();
        this.#tabMode = useTabTarget;
        this.#discoveryFilter = this.#tabMode
            ? [{}]
            : [{ type: 'tab', exclude: true }, {}];
        this.#connection = connection;
        this.#targetFilterCallback = targetFilterCallback;
        this.#targetFactory = targetFactory;
        this.#waitForInitiallyDiscoveredTargets = waitForInitiallyDiscoveredTargets;
        this.#connection.on('Target.targetCreated', this.#onTargetCreated);
        this.#connection.on('Target.targetDestroyed', this.#onTargetDestroyed);
        this.#connection.on('Target.targetInfoChanged', this.#onTargetInfoChanged);
        this.#connection.on('sessiondetached', this.#onSessionDetached);
        this.#setupAttachmentListeners(this.#connection);
        this.#connection
            .send('Target.setDiscoverTargets', {
            discover: true,
            filter: this.#discoveryFilter,
        })
            .then(this.#storeExistingTargetsForInit)
            .catch(util_js_1$5.debugError);
    }
    #storeExistingTargetsForInit = () => {
        if (!this.#waitForInitiallyDiscoveredTargets) {
            return;
        }
        for (const [targetId, targetInfo,] of this.#discoveredTargetsByTargetId.entries()) {
            const targetForFilter = new Target_js_2.CDPTarget(targetInfo, undefined, undefined, this, undefined);
            if ((!this.#targetFilterCallback ||
                this.#targetFilterCallback(targetForFilter)) &&
                targetInfo.type !== 'browser') {
                this.#targetsIdsForInit.add(targetId);
            }
        }
    };
    async initialize() {
        await this.#connection.send('Target.setAutoAttach', {
            waitForDebuggerOnStart: true,
            flatten: true,
            autoAttach: true,
            filter: this.#tabMode
                ? [
                    {
                        type: 'page',
                        exclude: true,
                    },
                    ...this.#discoveryFilter,
                ]
                : this.#discoveryFilter,
        });
        this.#finishInitializationIfReady();
        await this.#initializeDeferred.valueOrThrow();
    }
    dispose() {
        this.#connection.off('Target.targetCreated', this.#onTargetCreated);
        this.#connection.off('Target.targetDestroyed', this.#onTargetDestroyed);
        this.#connection.off('Target.targetInfoChanged', this.#onTargetInfoChanged);
        this.#connection.off('sessiondetached', this.#onSessionDetached);
        this.#removeAttachmentListeners(this.#connection);
    }
    getAvailableTargets() {
        const result = new Map();
        for (const [id, target] of this.#attachedTargetsByTargetId.entries()) {
            if (isTargetExposed(target)) {
                result.set(id, target);
            }
        }
        return result;
    }
    #setupAttachmentListeners(session) {
        const listener = (event) => {
            return this.#onAttachedToTarget(session, event);
        };
        (0, assert_js_1$6.assert)(!this.#attachedToTargetListenersBySession.has(session));
        this.#attachedToTargetListenersBySession.set(session, listener);
        session.on('Target.attachedToTarget', listener);
        const detachedListener = (event) => {
            return this.#onDetachedFromTarget(session, event);
        };
        (0, assert_js_1$6.assert)(!this.#detachedFromTargetListenersBySession.has(session));
        this.#detachedFromTargetListenersBySession.set(session, detachedListener);
        session.on('Target.detachedFromTarget', detachedListener);
    }
    #removeAttachmentListeners(session) {
        if (this.#attachedToTargetListenersBySession.has(session)) {
            session.off('Target.attachedToTarget', this.#attachedToTargetListenersBySession.get(session));
            this.#attachedToTargetListenersBySession.delete(session);
        }
        if (this.#detachedFromTargetListenersBySession.has(session)) {
            session.off('Target.detachedFromTarget', this.#detachedFromTargetListenersBySession.get(session));
            this.#detachedFromTargetListenersBySession.delete(session);
        }
    }
    #onSessionDetached = (session) => {
        this.#removeAttachmentListeners(session);
    };
    #onTargetCreated = async (event) => {
        this.#discoveredTargetsByTargetId.set(event.targetInfo.targetId, event.targetInfo);
        this.emit("targetDiscovered" /* TargetManagerEmittedEvents.TargetDiscovered */, event.targetInfo);
        // The connection is already attached to the browser target implicitly,
        // therefore, no new CDPSession is created and we have special handling
        // here.
        if (event.targetInfo.type === 'browser' && event.targetInfo.attached) {
            if (this.#attachedTargetsByTargetId.has(event.targetInfo.targetId)) {
                return;
            }
            const target = this.#targetFactory(event.targetInfo, undefined);
            target._initialize();
            this.#attachedTargetsByTargetId.set(event.targetInfo.targetId, target);
        }
    };
    #onTargetDestroyed = (event) => {
        const targetInfo = this.#discoveredTargetsByTargetId.get(event.targetId);
        this.#discoveredTargetsByTargetId.delete(event.targetId);
        this.#finishInitializationIfReady(event.targetId);
        if (targetInfo?.type === 'service_worker' &&
            this.#attachedTargetsByTargetId.has(event.targetId)) {
            // Special case for service workers: report TargetGone event when
            // the worker is destroyed.
            const target = this.#attachedTargetsByTargetId.get(event.targetId);
            this.emit("targetGone" /* TargetManagerEmittedEvents.TargetGone */, target);
            this.#attachedTargetsByTargetId.delete(event.targetId);
        }
    };
    #onTargetInfoChanged = (event) => {
        this.#discoveredTargetsByTargetId.set(event.targetInfo.targetId, event.targetInfo);
        if (this.#ignoredTargets.has(event.targetInfo.targetId) ||
            !this.#attachedTargetsByTargetId.has(event.targetInfo.targetId) ||
            !event.targetInfo.attached) {
            return;
        }
        const target = this.#attachedTargetsByTargetId.get(event.targetInfo.targetId);
        if (!target) {
            return;
        }
        const previousURL = target.url();
        const wasInitialized = target._initializedDeferred.value() === Target_js_2.InitializationStatus.SUCCESS;
        if (isPageTargetBecomingPrimary(target, event.targetInfo)) {
            const target = this.#attachedTargetsByTargetId.get(event.targetInfo.targetId);
            const session = target?._session();
            (0, assert_js_1$6.assert)(session, 'Target that is being activated is missing a CDPSession.');
            session.parentSession()?.emit(Connection_js_1$4.CDPSessionEmittedEvents.Swapped, session);
        }
        target._targetInfoChanged(event.targetInfo);
        if (wasInitialized && previousURL !== target.url()) {
            this.emit("targetChanged" /* TargetManagerEmittedEvents.TargetChanged */, {
                target: target,
                wasInitialized,
                previousURL,
            });
        }
    };
    #onAttachedToTarget = async (parentSession, event) => {
        const targetInfo = event.targetInfo;
        const session = this.#connection.session(event.sessionId);
        if (!session) {
            throw new Error(`Session ${event.sessionId} was not created.`);
        }
        const silentDetach = async () => {
            await session.send('Runtime.runIfWaitingForDebugger').catch(util_js_1$5.debugError);
            // We don't use `session.detach()` because that dispatches all commands on
            // the connection instead of the parent session.
            await parentSession
                .send('Target.detachFromTarget', {
                sessionId: session.id(),
            })
                .catch(util_js_1$5.debugError);
        };
        if (!this.#connection.isAutoAttached(targetInfo.targetId)) {
            return;
        }
        // Special case for service workers: being attached to service workers will
        // prevent them from ever being destroyed. Therefore, we silently detach
        // from service workers unless the connection was manually created via
        // `page.worker()`. To determine this, we use
        // `this.#connection.isAutoAttached(targetInfo.targetId)`. In the future, we
        // should determine if a target is auto-attached or not with the help of
        // CDP.
        if (targetInfo.type === 'service_worker' &&
            this.#connection.isAutoAttached(targetInfo.targetId)) {
            this.#finishInitializationIfReady(targetInfo.targetId);
            await silentDetach();
            if (this.#attachedTargetsByTargetId.has(targetInfo.targetId)) {
                return;
            }
            const target = this.#targetFactory(targetInfo);
            target._initialize();
            this.#attachedTargetsByTargetId.set(targetInfo.targetId, target);
            this.emit("targetAvailable" /* TargetManagerEmittedEvents.TargetAvailable */, target);
            return;
        }
        const isExistingTarget = this.#attachedTargetsByTargetId.has(targetInfo.targetId);
        const target = isExistingTarget
            ? this.#attachedTargetsByTargetId.get(targetInfo.targetId)
            : this.#targetFactory(targetInfo, session, parentSession instanceof Connection_js_1$4.CDPSession ? parentSession : undefined);
        if (this.#targetFilterCallback && !this.#targetFilterCallback(target)) {
            this.#ignoredTargets.add(targetInfo.targetId);
            this.#finishInitializationIfReady(targetInfo.targetId);
            await silentDetach();
            return;
        }
        if (!isExistingTarget) {
            target._initialize();
        }
        this.#setupAttachmentListeners(session);
        if (isExistingTarget) {
            this.#attachedTargetsBySessionId.set(session.id(), this.#attachedTargetsByTargetId.get(targetInfo.targetId));
        }
        else {
            this.#attachedTargetsByTargetId.set(targetInfo.targetId, target);
            this.#attachedTargetsBySessionId.set(session.id(), target);
        }
        parentSession.emit(Connection_js_1$4.CDPSessionEmittedEvents.Ready, session);
        this.#targetsIdsForInit.delete(target._targetId);
        if (!isExistingTarget && isTargetExposed(target)) {
            this.emit("targetAvailable" /* TargetManagerEmittedEvents.TargetAvailable */, target);
        }
        this.#finishInitializationIfReady();
        // TODO: the browser might be shutting down here. What do we do with the
        // error?
        await Promise.all([
            session.send('Target.setAutoAttach', {
                waitForDebuggerOnStart: true,
                flatten: true,
                autoAttach: true,
                filter: this.#discoveryFilter,
            }),
            session.send('Runtime.runIfWaitingForDebugger'),
        ]).catch(util_js_1$5.debugError);
    };
    #finishInitializationIfReady(targetId) {
        targetId !== undefined && this.#targetsIdsForInit.delete(targetId);
        if (this.#targetsIdsForInit.size === 0) {
            this.#initializeDeferred.resolve();
        }
    }
    #onDetachedFromTarget = (_parentSession, event) => {
        const target = this.#attachedTargetsBySessionId.get(event.sessionId);
        this.#attachedTargetsBySessionId.delete(event.sessionId);
        if (!target) {
            return;
        }
        this.#attachedTargetsByTargetId.delete(target._targetId);
        if (isTargetExposed(target)) {
            this.emit("targetGone" /* TargetManagerEmittedEvents.TargetGone */, target);
        }
    };
}
ChromeTargetManager$1.ChromeTargetManager = ChromeTargetManager;

var FirefoxTargetManager$1 = {};

/**
 * Copyright 2022 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(FirefoxTargetManager$1, "__esModule", { value: true });
FirefoxTargetManager$1.FirefoxTargetManager = void 0;
const assert_js_1$5 = assert$1;
const Deferred_js_1$1 = Deferred$1;
const Connection_js_1$3 = Connection$1;
const EventEmitter_js_1 = EventEmitter$1;
/**
 * FirefoxTargetManager implements target management using
 * `Target.setDiscoverTargets` without using auto-attach. It, therefore, creates
 * targets that lazily establish their CDP sessions.
 *
 * Although the approach is potentially flaky, there is no other way for Firefox
 * because Firefox's CDP implementation does not support auto-attach.
 *
 * Firefox does not support targetInfoChanged and detachedFromTarget events:
 *
 * - https://bugzilla.mozilla.org/show_bug.cgi?id=1610855
 * - https://bugzilla.mozilla.org/show_bug.cgi?id=1636979
 *   @internal
 */
class FirefoxTargetManager extends EventEmitter_js_1.EventEmitter {
    #connection;
    /**
     * Keeps track of the following events: 'Target.targetCreated',
     * 'Target.targetDestroyed'.
     *
     * A target becomes discovered when 'Target.targetCreated' is received.
     * A target is removed from this map once 'Target.targetDestroyed' is
     * received.
     *
     * `targetFilterCallback` has no effect on this map.
     */
    #discoveredTargetsByTargetId = new Map();
    /**
     * Keeps track of targets that were created via 'Target.targetCreated'
     * and which one are not filtered out by `targetFilterCallback`.
     *
     * The target is removed from here once it's been destroyed.
     */
    #availableTargetsByTargetId = new Map();
    /**
     * Tracks which sessions attach to which target.
     */
    #availableTargetsBySessionId = new Map();
    /**
     * If a target was filtered out by `targetFilterCallback`, we still receive
     * events about it from CDP, but we don't forward them to the rest of Puppeteer.
     */
    #ignoredTargets = new Set();
    #targetFilterCallback;
    #targetFactory;
    #attachedToTargetListenersBySession = new WeakMap();
    #initializeDeferred = Deferred_js_1$1.Deferred.create();
    #targetsIdsForInit = new Set();
    constructor(connection, targetFactory, targetFilterCallback) {
        super();
        this.#connection = connection;
        this.#targetFilterCallback = targetFilterCallback;
        this.#targetFactory = targetFactory;
        this.#connection.on('Target.targetCreated', this.#onTargetCreated);
        this.#connection.on('Target.targetDestroyed', this.#onTargetDestroyed);
        this.#connection.on('sessiondetached', this.#onSessionDetached);
        this.setupAttachmentListeners(this.#connection);
    }
    setupAttachmentListeners(session) {
        const listener = (event) => {
            return this.#onAttachedToTarget(session, event);
        };
        (0, assert_js_1$5.assert)(!this.#attachedToTargetListenersBySession.has(session));
        this.#attachedToTargetListenersBySession.set(session, listener);
        session.on('Target.attachedToTarget', listener);
    }
    #onSessionDetached = (session) => {
        this.removeSessionListeners(session);
        this.#availableTargetsBySessionId.delete(session.id());
    };
    removeSessionListeners(session) {
        if (this.#attachedToTargetListenersBySession.has(session)) {
            session.off('Target.attachedToTarget', this.#attachedToTargetListenersBySession.get(session));
            this.#attachedToTargetListenersBySession.delete(session);
        }
    }
    getAvailableTargets() {
        return this.#availableTargetsByTargetId;
    }
    dispose() {
        this.#connection.off('Target.targetCreated', this.#onTargetCreated);
        this.#connection.off('Target.targetDestroyed', this.#onTargetDestroyed);
    }
    async initialize() {
        await this.#connection.send('Target.setDiscoverTargets', {
            discover: true,
            filter: [{}],
        });
        this.#targetsIdsForInit = new Set(this.#discoveredTargetsByTargetId.keys());
        await this.#initializeDeferred.valueOrThrow();
    }
    #onTargetCreated = async (event) => {
        if (this.#discoveredTargetsByTargetId.has(event.targetInfo.targetId)) {
            return;
        }
        this.#discoveredTargetsByTargetId.set(event.targetInfo.targetId, event.targetInfo);
        if (event.targetInfo.type === 'browser' && event.targetInfo.attached) {
            const target = this.#targetFactory(event.targetInfo, undefined);
            target._initialize();
            this.#availableTargetsByTargetId.set(event.targetInfo.targetId, target);
            this.#finishInitializationIfReady(target._targetId);
            return;
        }
        const target = this.#targetFactory(event.targetInfo, undefined);
        if (this.#targetFilterCallback && !this.#targetFilterCallback(target)) {
            this.#ignoredTargets.add(event.targetInfo.targetId);
            this.#finishInitializationIfReady(event.targetInfo.targetId);
            return;
        }
        target._initialize();
        this.#availableTargetsByTargetId.set(event.targetInfo.targetId, target);
        this.emit("targetAvailable" /* TargetManagerEmittedEvents.TargetAvailable */, target);
        this.#finishInitializationIfReady(target._targetId);
    };
    #onTargetDestroyed = (event) => {
        this.#discoveredTargetsByTargetId.delete(event.targetId);
        this.#finishInitializationIfReady(event.targetId);
        const target = this.#availableTargetsByTargetId.get(event.targetId);
        if (target) {
            this.emit("targetGone" /* TargetManagerEmittedEvents.TargetGone */, target);
            this.#availableTargetsByTargetId.delete(event.targetId);
        }
    };
    #onAttachedToTarget = async (parentSession, event) => {
        const targetInfo = event.targetInfo;
        const session = this.#connection.session(event.sessionId);
        if (!session) {
            throw new Error(`Session ${event.sessionId} was not created.`);
        }
        const target = this.#availableTargetsByTargetId.get(targetInfo.targetId);
        (0, assert_js_1$5.assert)(target, `Target ${targetInfo.targetId} is missing`);
        this.setupAttachmentListeners(session);
        this.#availableTargetsBySessionId.set(session.id(), this.#availableTargetsByTargetId.get(targetInfo.targetId));
        parentSession.emit(Connection_js_1$3.CDPSessionEmittedEvents.Ready, session);
    };
    #finishInitializationIfReady(targetId) {
        this.#targetsIdsForInit.delete(targetId);
        if (this.#targetsIdsForInit.size === 0) {
            this.#initializeDeferred.resolve();
        }
    }
}
FirefoxTargetManager$1.FirefoxTargetManager = FirefoxTargetManager;

var TaskQueue$1 = {};

/**
 * Copyright 2020 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(TaskQueue$1, "__esModule", { value: true });
TaskQueue$1.TaskQueue = void 0;
/**
 * @internal
 */
class TaskQueue {
    #chain;
    constructor() {
        this.#chain = Promise.resolve();
    }
    postTask(task) {
        const result = this.#chain.then(task);
        this.#chain = result.then(() => {
            return undefined;
        }, () => {
            return undefined;
        });
        return result;
    }
}
TaskQueue$1.TaskQueue = TaskQueue;

/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(Browser$1, "__esModule", { value: true });
Browser$1.CDPBrowserContext = Browser$1.CDPBrowser = void 0;
const Browser_js_1$2 = Browser$3;
const BrowserContext_js_1 = BrowserContext$2;
const environment_js_1$3 = environment;
const assert_js_1$4 = assert$1;
const ChromeTargetManager_js_1 = ChromeTargetManager$1;
const Connection_js_1$2 = Connection$1;
const FirefoxTargetManager_js_1 = FirefoxTargetManager$1;
const Target_js_1 = Target$1;
const TaskQueue_js_1 = TaskQueue$1;
/**
 * @internal
 */
class CDPBrowser extends Browser_js_1$2.Browser {
    static async _create(product, connection, contextIds, ignoreHTTPSErrors, defaultViewport, process, closeCallback, targetFilterCallback, isPageTargetCallback, waitForInitiallyDiscoveredTargets = true, useTabTarget = environment_js_1$3.USE_TAB_TARGET) {
        const browser = new CDPBrowser(product, connection, contextIds, ignoreHTTPSErrors, defaultViewport, process, closeCallback, targetFilterCallback, isPageTargetCallback, waitForInitiallyDiscoveredTargets, useTabTarget);
        await browser._attach();
        return browser;
    }
    #ignoreHTTPSErrors;
    #defaultViewport;
    #process;
    #connection;
    #closeCallback;
    #targetFilterCallback;
    #isPageTargetCallback;
    #defaultContext;
    #contexts = new Map();
    #screenshotTaskQueue;
    #targetManager;
    get _targets() {
        return this.#targetManager.getAvailableTargets();
    }
    constructor(product, connection, contextIds, ignoreHTTPSErrors, defaultViewport, process, closeCallback, targetFilterCallback, isPageTargetCallback, waitForInitiallyDiscoveredTargets = true, useTabTarget = environment_js_1$3.USE_TAB_TARGET) {
        super();
        product = product || 'chrome';
        this.#ignoreHTTPSErrors = ignoreHTTPSErrors;
        this.#defaultViewport = defaultViewport;
        this.#process = process;
        this.#screenshotTaskQueue = new TaskQueue_js_1.TaskQueue();
        this.#connection = connection;
        this.#closeCallback = closeCallback || function () { };
        this.#targetFilterCallback =
            targetFilterCallback ||
                (() => {
                    return true;
                });
        this.#setIsPageTargetCallback(isPageTargetCallback);
        if (product === 'firefox') {
            this.#targetManager = new FirefoxTargetManager_js_1.FirefoxTargetManager(connection, this.#createTarget, this.#targetFilterCallback);
        }
        else {
            this.#targetManager = new ChromeTargetManager_js_1.ChromeTargetManager(connection, this.#createTarget, this.#targetFilterCallback, waitForInitiallyDiscoveredTargets, useTabTarget);
        }
        this.#defaultContext = new CDPBrowserContext(this.#connection, this);
        for (const contextId of contextIds) {
            this.#contexts.set(contextId, new CDPBrowserContext(this.#connection, this, contextId));
        }
    }
    #emitDisconnected = () => {
        this.emit("disconnected" /* BrowserEmittedEvents.Disconnected */);
    };
    async _attach() {
        this.#connection.on(Connection_js_1$2.ConnectionEmittedEvents.Disconnected, this.#emitDisconnected);
        this.#targetManager.on("targetAvailable" /* TargetManagerEmittedEvents.TargetAvailable */, this.#onAttachedToTarget);
        this.#targetManager.on("targetGone" /* TargetManagerEmittedEvents.TargetGone */, this.#onDetachedFromTarget);
        this.#targetManager.on("targetChanged" /* TargetManagerEmittedEvents.TargetChanged */, this.#onTargetChanged);
        this.#targetManager.on("targetDiscovered" /* TargetManagerEmittedEvents.TargetDiscovered */, this.#onTargetDiscovered);
        await this.#targetManager.initialize();
    }
    _detach() {
        this.#connection.off(Connection_js_1$2.ConnectionEmittedEvents.Disconnected, this.#emitDisconnected);
        this.#targetManager.off("targetAvailable" /* TargetManagerEmittedEvents.TargetAvailable */, this.#onAttachedToTarget);
        this.#targetManager.off("targetGone" /* TargetManagerEmittedEvents.TargetGone */, this.#onDetachedFromTarget);
        this.#targetManager.off("targetChanged" /* TargetManagerEmittedEvents.TargetChanged */, this.#onTargetChanged);
        this.#targetManager.off("targetDiscovered" /* TargetManagerEmittedEvents.TargetDiscovered */, this.#onTargetDiscovered);
    }
    /**
     * The spawned browser process. Returns `null` if the browser instance was created with
     * {@link Puppeteer.connect}.
     */
    process() {
        return this.#process ?? null;
    }
    _targetManager() {
        return this.#targetManager;
    }
    #setIsPageTargetCallback(isPageTargetCallback) {
        this.#isPageTargetCallback =
            isPageTargetCallback ||
                ((target) => {
                    return (target.type() === 'page' ||
                        target.type() === 'background_page' ||
                        target.type() === 'webview');
                });
    }
    _getIsPageTargetCallback() {
        return this.#isPageTargetCallback;
    }
    /**
     * Creates a new incognito browser context. This won't share cookies/cache with other
     * browser contexts.
     *
     * @example
     *
     * ```ts
     * (async () => {
     *   const browser = await puppeteer.launch();
     *   // Create a new incognito browser context.
     *   const context = await browser.createIncognitoBrowserContext();
     *   // Create a new page in a pristine context.
     *   const page = await context.newPage();
     *   // Do stuff
     *   await page.goto('https://example.com');
     * })();
     * ```
     */
    async createIncognitoBrowserContext(options = {}) {
        const { proxyServer, proxyBypassList } = options;
        const { browserContextId } = await this.#connection.send('Target.createBrowserContext', {
            proxyServer,
            proxyBypassList: proxyBypassList && proxyBypassList.join(','),
        });
        const context = new CDPBrowserContext(this.#connection, this, browserContextId);
        this.#contexts.set(browserContextId, context);
        return context;
    }
    /**
     * Returns an array of all open browser contexts. In a newly created browser, this will
     * return a single instance of {@link BrowserContext}.
     */
    browserContexts() {
        return [this.#defaultContext, ...Array.from(this.#contexts.values())];
    }
    /**
     * Returns the default browser context. The default browser context cannot be closed.
     */
    defaultBrowserContext() {
        return this.#defaultContext;
    }
    async _disposeContext(contextId) {
        if (!contextId) {
            return;
        }
        await this.#connection.send('Target.disposeBrowserContext', {
            browserContextId: contextId,
        });
        this.#contexts.delete(contextId);
    }
    #createTarget = (targetInfo, session) => {
        const { browserContextId } = targetInfo;
        const context = browserContextId && this.#contexts.has(browserContextId)
            ? this.#contexts.get(browserContextId)
            : this.#defaultContext;
        if (!context) {
            throw new Error('Missing browser context');
        }
        const createSession = (isAutoAttachEmulated) => {
            return this.#connection._createSession(targetInfo, isAutoAttachEmulated);
        };
        const targetForFilter = new Target_js_1.OtherTarget(targetInfo, session, context, this.#targetManager, createSession);
        if (targetInfo.url?.startsWith('devtools://')) {
            return new Target_js_1.DevToolsTarget(targetInfo, session, context, this.#targetManager, createSession, this.#ignoreHTTPSErrors, this.#defaultViewport ?? null, this.#screenshotTaskQueue);
        }
        if (this.#isPageTargetCallback(targetForFilter)) {
            return new Target_js_1.PageTarget(targetInfo, session, context, this.#targetManager, createSession, this.#ignoreHTTPSErrors, this.#defaultViewport ?? null, this.#screenshotTaskQueue);
        }
        if (targetInfo.type === 'service_worker' ||
            targetInfo.type === 'shared_worker') {
            return new Target_js_1.WorkerTarget(targetInfo, session, context, this.#targetManager, createSession);
        }
        return new Target_js_1.OtherTarget(targetInfo, session, context, this.#targetManager, createSession);
    };
    #onAttachedToTarget = async (target) => {
        if ((await target._initializedDeferred.valueOrThrow()) ===
            Target_js_1.InitializationStatus.SUCCESS) {
            this.emit("targetcreated" /* BrowserEmittedEvents.TargetCreated */, target);
            target
                .browserContext()
                .emit("targetcreated" /* BrowserContextEmittedEvents.TargetCreated */, target);
        }
    };
    #onDetachedFromTarget = async (target) => {
        target._initializedDeferred.resolve(Target_js_1.InitializationStatus.ABORTED);
        target._isClosedDeferred.resolve();
        if ((await target._initializedDeferred.valueOrThrow()) ===
            Target_js_1.InitializationStatus.SUCCESS) {
            this.emit("targetdestroyed" /* BrowserEmittedEvents.TargetDestroyed */, target);
            target
                .browserContext()
                .emit("targetdestroyed" /* BrowserContextEmittedEvents.TargetDestroyed */, target);
        }
    };
    #onTargetChanged = ({ target }) => {
        this.emit("targetchanged" /* BrowserEmittedEvents.TargetChanged */, target);
        target
            .browserContext()
            .emit("targetchanged" /* BrowserContextEmittedEvents.TargetChanged */, target);
    };
    #onTargetDiscovered = (targetInfo) => {
        this.emit('targetdiscovered', targetInfo);
    };
    /**
     * The browser websocket endpoint which can be used as an argument to
     * {@link Puppeteer.connect}.
     *
     * @returns The Browser websocket url.
     *
     * @remarks
     *
     * The format is `ws://${host}:${port}/devtools/browser/<id>`.
     *
     * You can find the `webSocketDebuggerUrl` from `http://${host}:${port}/json/version`.
     * Learn more about the
     * {@link https://chromedevtools.github.io/devtools-protocol | devtools protocol} and
     * the {@link
     * https://chromedevtools.github.io/devtools-protocol/#how-do-i-access-the-browser-target
     * | browser endpoint}.
     */
    wsEndpoint() {
        return this.#connection.url();
    }
    /**
     * Promise which resolves to a new {@link Page} object. The Page is created in
     * a default browser context.
     */
    async newPage() {
        return await this.#defaultContext.newPage();
    }
    async _createPageInContext(contextId) {
        const { targetId } = await this.#connection.send('Target.createTarget', {
            url: 'about:blank',
            browserContextId: contextId || undefined,
        });
        const target = (await this.waitForTarget(t => {
            return t._targetId === targetId;
        }));
        if (!target) {
            throw new Error(`Missing target for page (id = ${targetId})`);
        }
        const initialized = (await target._initializedDeferred.valueOrThrow()) ===
            Target_js_1.InitializationStatus.SUCCESS;
        if (!initialized) {
            throw new Error(`Failed to create target for page (id = ${targetId})`);
        }
        const page = await target.page();
        if (!page) {
            throw new Error(`Failed to create a page for context (id = ${contextId})`);
        }
        return page;
    }
    /**
     * All active targets inside the Browser. In case of multiple browser contexts, returns
     * an array with all the targets in all browser contexts.
     */
    targets() {
        return Array.from(this.#targetManager.getAvailableTargets().values()).filter(target => {
            return (target._initializedDeferred.value() === Target_js_1.InitializationStatus.SUCCESS);
        });
    }
    /**
     * The target associated with the browser.
     */
    target() {
        const browserTarget = this.targets().find(target => {
            return target.type() === 'browser';
        });
        if (!browserTarget) {
            throw new Error('Browser target is not found');
        }
        return browserTarget;
    }
    async version() {
        const version = await this.#getVersion();
        return version.product;
    }
    /**
     * The browser's original user agent. Pages can override the browser user agent with
     * {@link Page.setUserAgent}.
     */
    async userAgent() {
        const version = await this.#getVersion();
        return version.userAgent;
    }
    async close() {
        await this.#closeCallback.call(null);
        this.disconnect();
    }
    disconnect() {
        this.#targetManager.dispose();
        this.#connection.dispose();
        this._detach();
    }
    /**
     * Indicates that the browser is connected.
     */
    isConnected() {
        return !this.#connection._closed;
    }
    #getVersion() {
        return this.#connection.send('Browser.getVersion');
    }
}
Browser$1.CDPBrowser = CDPBrowser;
/**
 * @internal
 */
class CDPBrowserContext extends BrowserContext_js_1.BrowserContext {
    #connection;
    #browser;
    #id;
    constructor(connection, browser, contextId) {
        super();
        this.#connection = connection;
        this.#browser = browser;
        this.#id = contextId;
    }
    get id() {
        return this.#id;
    }
    /**
     * An array of all active targets inside the browser context.
     */
    targets() {
        return this.#browser.targets().filter(target => {
            return target.browserContext() === this;
        });
    }
    /**
     * This searches for a target in this specific browser context.
     *
     * @example
     * An example of finding a target for a page opened via `window.open`:
     *
     * ```ts
     * await page.evaluate(() => window.open('https://www.example.com/'));
     * const newWindowTarget = await browserContext.waitForTarget(
     *   target => target.url() === 'https://www.example.com/'
     * );
     * ```
     *
     * @param predicate - A function to be run for every target
     * @param options - An object of options. Accepts a timeout,
     * which is the maximum wait time in milliseconds.
     * Pass `0` to disable the timeout. Defaults to 30 seconds.
     * @returns Promise which resolves to the first target found
     * that matches the `predicate` function.
     */
    waitForTarget(predicate, options = {}) {
        return this.#browser.waitForTarget(target => {
            return target.browserContext() === this && predicate(target);
        }, options);
    }
    /**
     * An array of all pages inside the browser context.
     *
     * @returns Promise which resolves to an array of all open pages.
     * Non visible pages, such as `"background_page"`, will not be listed here.
     * You can find them using {@link Target.page | the target page}.
     */
    async pages() {
        const pages = await Promise.all(this.targets()
            .filter(target => {
            return (target.type() === 'page' ||
                (target.type() === 'other' &&
                    this.#browser._getIsPageTargetCallback()?.(target)));
        })
            .map(target => {
            return target.page();
        }));
        return pages.filter((page) => {
            return !!page;
        });
    }
    /**
     * Returns whether BrowserContext is incognito.
     * The default browser context is the only non-incognito browser context.
     *
     * @remarks
     * The default browser context cannot be closed.
     */
    isIncognito() {
        return !!this.#id;
    }
    /**
     * @example
     *
     * ```ts
     * const context = browser.defaultBrowserContext();
     * await context.overridePermissions('https://html5demos.com', [
     *   'geolocation',
     * ]);
     * ```
     *
     * @param origin - The origin to grant permissions to, e.g. "https://example.com".
     * @param permissions - An array of permissions to grant.
     * All permissions that are not listed here will be automatically denied.
     */
    async overridePermissions(origin, permissions) {
        const protocolPermissions = permissions.map(permission => {
            const protocolPermission = Browser_js_1$2.WEB_PERMISSION_TO_PROTOCOL_PERMISSION.get(permission);
            if (!protocolPermission) {
                throw new Error('Unknown permission: ' + permission);
            }
            return protocolPermission;
        });
        await this.#connection.send('Browser.grantPermissions', {
            origin,
            browserContextId: this.#id || undefined,
            permissions: protocolPermissions,
        });
    }
    /**
     * Clears all permission overrides for the browser context.
     *
     * @example
     *
     * ```ts
     * const context = browser.defaultBrowserContext();
     * context.overridePermissions('https://example.com', ['clipboard-read']);
     * // do stuff ..
     * context.clearPermissionOverrides();
     * ```
     */
    async clearPermissionOverrides() {
        await this.#connection.send('Browser.resetPermissions', {
            browserContextId: this.#id || undefined,
        });
    }
    /**
     * Creates a new page in the browser context.
     */
    newPage() {
        return this.#browser._createPageInContext(this.#id);
    }
    /**
     * The browser this browser context belongs to.
     */
    browser() {
        return this.#browser;
    }
    /**
     * Closes the browser context. All the targets that belong to the browser context
     * will be closed.
     *
     * @remarks
     * Only incognito browser contexts can be closed.
     */
    async close() {
        (0, assert_js_1$4.assert)(this.#id, 'Non-incognito profiles cannot be closed!');
        await this.#browser._disposeContext(this.#id);
    }
}
Browser$1.CDPBrowserContext = CDPBrowserContext;

var BrowserConnector = {};

var fetch = {};

/**
 * Copyright 2020 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding$2 = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault$2 = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar$2 = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$2(result, mod, k);
    __setModuleDefault$2(result, mod);
    return result;
};
Object.defineProperty(fetch, "__esModule", { value: true });
fetch.getFetch = void 0;
/**
 * Gets the global version if we're in the browser, else loads the node-fetch module.
 *
 * @internal
 */
const getFetch = async () => {
    return globalThis.fetch || (await Promise.resolve().then(() => __importStar$2(require$$0))).fetch;
};
fetch.getFetch = getFetch;

var NodeWebSocketTransport$1 = {};

var version = {};

Object.defineProperty(version, "__esModule", { value: true });
version.packageVersion = void 0;
/**
 * @internal
 */
version.packageVersion = '21.2.1';

var __importDefault$3 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(NodeWebSocketTransport$1, "__esModule", { value: true });
NodeWebSocketTransport$1.NodeWebSocketTransport = void 0;
/**
 * Copyright 2018 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ws_1 = __importDefault$3(require$$0$1);
const version_js_1 = version;
/**
 * @internal
 */
class NodeWebSocketTransport {
    static create(url, headers) {
        return new Promise((resolve, reject) => {
            const ws = new ws_1.default(url, [], {
                followRedirects: true,
                perMessageDeflate: false,
                maxPayload: 256 * 1024 * 1024,
                headers: {
                    'User-Agent': `Puppeteer ${version_js_1.packageVersion}`,
                    ...headers,
                },
            });
            ws.addEventListener('open', () => {
                return resolve(new NodeWebSocketTransport(ws));
            });
            ws.addEventListener('error', reject);
        });
    }
    #ws;
    onmessage;
    onclose;
    constructor(ws) {
        this.#ws = ws;
        this.#ws.addEventListener('message', event => {
            if (this.onmessage) {
                this.onmessage.call(null, event.data);
            }
        });
        this.#ws.addEventListener('close', () => {
            if (this.onclose) {
                this.onclose.call(null);
            }
        });
        // Silently ignore all errors - we don't know what to do with them.
        this.#ws.addEventListener('error', () => { });
    }
    send(message) {
        this.#ws.send(message);
    }
    close() {
        this.#ws.close();
    }
}
NodeWebSocketTransport$1.NodeWebSocketTransport = NodeWebSocketTransport;

var BrowserWebSocketTransport$1 = {};

Object.defineProperty(BrowserWebSocketTransport$1, "__esModule", { value: true });
BrowserWebSocketTransport$1.BrowserWebSocketTransport = void 0;
/**
 * @internal
 */
class BrowserWebSocketTransport {
    static create(url) {
        return new Promise((resolve, reject) => {
            const ws = new WebSocket(url);
            ws.addEventListener('open', () => {
                return resolve(new BrowserWebSocketTransport(ws));
            });
            ws.addEventListener('error', reject);
        });
    }
    #ws;
    onmessage;
    onclose;
    constructor(ws) {
        this.#ws = ws;
        this.#ws.addEventListener('message', event => {
            if (this.onmessage) {
                this.onmessage.call(null, event.data);
            }
        });
        this.#ws.addEventListener('close', () => {
            if (this.onclose) {
                this.onclose.call(null);
            }
        });
        // Silently ignore all errors - we don't know what to do with them.
        this.#ws.addEventListener('error', () => { });
    }
    send(message) {
        this.#ws.send(message);
    }
    close() {
        this.#ws.close();
    }
}
BrowserWebSocketTransport$1.BrowserWebSocketTransport = BrowserWebSocketTransport;

/**
 * Copyright 2020 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding$1 = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault$1 = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar$1 = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$1(result, mod, k);
    __setModuleDefault$1(result, mod);
    return result;
};
Object.defineProperty(BrowserConnector, "__esModule", { value: true });
BrowserConnector._connectToCDPBrowser = void 0;
const environment_js_1$2 = environment;
const assert_js_1$3 = assert$1;
const ErrorLike_js_1 = ErrorLike;
const Browser_js_1$1 = Browser$1;
const Connection_js_1$1 = Connection$1;
const fetch_js_1 = fetch;
const util_js_1$4 = requireUtil();
const getWebSocketTransportClass = async () => {
    return environment_js_1$2.isNode
        ? (await Promise.resolve().then(() => __importStar$1(NodeWebSocketTransport$1))).NodeWebSocketTransport
        : (await Promise.resolve().then(() => __importStar$1(BrowserWebSocketTransport$1)))
            .BrowserWebSocketTransport;
};
/**
 * Users should never call this directly; it's called when calling
 * `puppeteer.connect`.
 *
 * @internal
 */
async function _connectToCDPBrowser(options) {
    const { browserWSEndpoint, browserURL, ignoreHTTPSErrors = false, defaultViewport = { width: 800, height: 600 }, transport, headers = {}, slowMo = 0, targetFilter, _isPageTarget: isPageTarget, protocolTimeout, } = options;
    (0, assert_js_1$3.assert)(Number(!!browserWSEndpoint) + Number(!!browserURL) + Number(!!transport) ===
        1, 'Exactly one of browserWSEndpoint, browserURL or transport must be passed to puppeteer.connect');
    let connection;
    if (transport) {
        connection = new Connection_js_1$1.Connection('', transport, slowMo, protocolTimeout);
    }
    else if (browserWSEndpoint) {
        const WebSocketClass = await getWebSocketTransportClass();
        const connectionTransport = await WebSocketClass.create(browserWSEndpoint, headers);
        connection = new Connection_js_1$1.Connection(browserWSEndpoint, connectionTransport, slowMo, protocolTimeout);
    }
    else if (browserURL) {
        const connectionURL = await getWSEndpoint(browserURL);
        const WebSocketClass = await getWebSocketTransportClass();
        const connectionTransport = await WebSocketClass.create(connectionURL);
        connection = new Connection_js_1$1.Connection(connectionURL, connectionTransport, slowMo, protocolTimeout);
    }
    const version = await connection.send('Browser.getVersion');
    const product = version.product.toLowerCase().includes('firefox')
        ? 'firefox'
        : 'chrome';
    const { browserContextIds } = await connection.send('Target.getBrowserContexts');
    const browser = await Browser_js_1$1.CDPBrowser._create(product || 'chrome', connection, browserContextIds, ignoreHTTPSErrors, defaultViewport, undefined, () => {
        return connection.send('Browser.close').catch(util_js_1$4.debugError);
    }, targetFilter, isPageTarget);
    return browser;
}
BrowserConnector._connectToCDPBrowser = _connectToCDPBrowser;
async function getWSEndpoint(browserURL) {
    const endpointURL = new URL('/json/version', browserURL);
    const fetch = await (0, fetch_js_1.getFetch)();
    try {
        const result = await fetch(endpointURL.toString(), {
            method: 'GET',
        });
        if (!result.ok) {
            throw new Error(`HTTP ${result.statusText}`);
        }
        const data = await result.json();
        return data.webSocketDebuggerUrl;
    }
    catch (error) {
        if ((0, ErrorLike_js_1.isErrorLike)(error)) {
            error.message =
                `Failed to fetch browser webSocket URL from ${endpointURL}: ` +
                    error.message;
        }
        throw error;
    }
}

var Configuration = {};

/**
 * Copyright 2022 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(Configuration, "__esModule", { value: true });

var ConnectionTransport = {};

/**
 * Copyright 2020 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(ConnectionTransport, "__esModule", { value: true });

var Device = {};

(function (exports) {
	/**
	 * Copyright 2017 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.devices = exports.KnownDevices = void 0;
	const knownDevices = [
	    {
	        name: 'Blackberry PlayBook',
	        userAgent: 'Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/7.2.1.0 Safari/536.2+',
	        viewport: {
	            width: 600,
	            height: 1024,
	            deviceScaleFactor: 1,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'Blackberry PlayBook landscape',
	        userAgent: 'Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/7.2.1.0 Safari/536.2+',
	        viewport: {
	            width: 1024,
	            height: 600,
	            deviceScaleFactor: 1,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'BlackBerry Z30',
	        userAgent: 'Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/10.0.9.2372 Mobile Safari/537.10+',
	        viewport: {
	            width: 360,
	            height: 640,
	            deviceScaleFactor: 2,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'BlackBerry Z30 landscape',
	        userAgent: 'Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/10.0.9.2372 Mobile Safari/537.10+',
	        viewport: {
	            width: 640,
	            height: 360,
	            deviceScaleFactor: 2,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'Galaxy Note 3',
	        userAgent: 'Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30',
	        viewport: {
	            width: 360,
	            height: 640,
	            deviceScaleFactor: 3,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'Galaxy Note 3 landscape',
	        userAgent: 'Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30',
	        viewport: {
	            width: 640,
	            height: 360,
	            deviceScaleFactor: 3,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'Galaxy Note II',
	        userAgent: 'Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30',
	        viewport: {
	            width: 360,
	            height: 640,
	            deviceScaleFactor: 2,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'Galaxy Note II landscape',
	        userAgent: 'Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30',
	        viewport: {
	            width: 640,
	            height: 360,
	            deviceScaleFactor: 2,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'Galaxy S III',
	        userAgent: 'Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30',
	        viewport: {
	            width: 360,
	            height: 640,
	            deviceScaleFactor: 2,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'Galaxy S III landscape',
	        userAgent: 'Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30',
	        viewport: {
	            width: 640,
	            height: 360,
	            deviceScaleFactor: 2,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'Galaxy S5',
	        userAgent: 'Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
	        viewport: {
	            width: 360,
	            height: 640,
	            deviceScaleFactor: 3,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'Galaxy S5 landscape',
	        userAgent: 'Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
	        viewport: {
	            width: 640,
	            height: 360,
	            deviceScaleFactor: 3,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'Galaxy S8',
	        userAgent: 'Mozilla/5.0 (Linux; Android 7.0; SM-G950U Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36',
	        viewport: {
	            width: 360,
	            height: 740,
	            deviceScaleFactor: 3,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'Galaxy S8 landscape',
	        userAgent: 'Mozilla/5.0 (Linux; Android 7.0; SM-G950U Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36',
	        viewport: {
	            width: 740,
	            height: 360,
	            deviceScaleFactor: 3,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'Galaxy S9+',
	        userAgent: 'Mozilla/5.0 (Linux; Android 8.0.0; SM-G965U Build/R16NW) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.111 Mobile Safari/537.36',
	        viewport: {
	            width: 320,
	            height: 658,
	            deviceScaleFactor: 4.5,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'Galaxy S9+ landscape',
	        userAgent: 'Mozilla/5.0 (Linux; Android 8.0.0; SM-G965U Build/R16NW) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.111 Mobile Safari/537.36',
	        viewport: {
	            width: 658,
	            height: 320,
	            deviceScaleFactor: 4.5,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'Galaxy Tab S4',
	        userAgent: 'Mozilla/5.0 (Linux; Android 8.1.0; SM-T837A) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.80 Safari/537.36',
	        viewport: {
	            width: 712,
	            height: 1138,
	            deviceScaleFactor: 2.25,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'Galaxy Tab S4 landscape',
	        userAgent: 'Mozilla/5.0 (Linux; Android 8.1.0; SM-T837A) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.80 Safari/537.36',
	        viewport: {
	            width: 1138,
	            height: 712,
	            deviceScaleFactor: 2.25,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'iPad',
	        userAgent: 'Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1',
	        viewport: {
	            width: 768,
	            height: 1024,
	            deviceScaleFactor: 2,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'iPad landscape',
	        userAgent: 'Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1',
	        viewport: {
	            width: 1024,
	            height: 768,
	            deviceScaleFactor: 2,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'iPad (gen 6)',
	        userAgent: 'Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
	        viewport: {
	            width: 768,
	            height: 1024,
	            deviceScaleFactor: 2,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'iPad (gen 6) landscape',
	        userAgent: 'Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
	        viewport: {
	            width: 1024,
	            height: 768,
	            deviceScaleFactor: 2,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'iPad (gen 7)',
	        userAgent: 'Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
	        viewport: {
	            width: 810,
	            height: 1080,
	            deviceScaleFactor: 2,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'iPad (gen 7) landscape',
	        userAgent: 'Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
	        viewport: {
	            width: 1080,
	            height: 810,
	            deviceScaleFactor: 2,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'iPad Mini',
	        userAgent: 'Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1',
	        viewport: {
	            width: 768,
	            height: 1024,
	            deviceScaleFactor: 2,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'iPad Mini landscape',
	        userAgent: 'Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1',
	        viewport: {
	            width: 1024,
	            height: 768,
	            deviceScaleFactor: 2,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'iPad Pro',
	        userAgent: 'Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1',
	        viewport: {
	            width: 1024,
	            height: 1366,
	            deviceScaleFactor: 2,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'iPad Pro landscape',
	        userAgent: 'Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1',
	        viewport: {
	            width: 1366,
	            height: 1024,
	            deviceScaleFactor: 2,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'iPad Pro 11',
	        userAgent: 'Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
	        viewport: {
	            width: 834,
	            height: 1194,
	            deviceScaleFactor: 2,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'iPad Pro 11 landscape',
	        userAgent: 'Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
	        viewport: {
	            width: 1194,
	            height: 834,
	            deviceScaleFactor: 2,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'iPhone 4',
	        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 7_1_2 like Mac OS X) AppleWebKit/537.51.2 (KHTML, like Gecko) Version/7.0 Mobile/11D257 Safari/9537.53',
	        viewport: {
	            width: 320,
	            height: 480,
	            deviceScaleFactor: 2,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'iPhone 4 landscape',
	        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 7_1_2 like Mac OS X) AppleWebKit/537.51.2 (KHTML, like Gecko) Version/7.0 Mobile/11D257 Safari/9537.53',
	        viewport: {
	            width: 480,
	            height: 320,
	            deviceScaleFactor: 2,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'iPhone 5',
	        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1',
	        viewport: {
	            width: 320,
	            height: 568,
	            deviceScaleFactor: 2,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'iPhone 5 landscape',
	        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1',
	        viewport: {
	            width: 568,
	            height: 320,
	            deviceScaleFactor: 2,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'iPhone 6',
	        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
	        viewport: {
	            width: 375,
	            height: 667,
	            deviceScaleFactor: 2,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'iPhone 6 landscape',
	        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
	        viewport: {
	            width: 667,
	            height: 375,
	            deviceScaleFactor: 2,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'iPhone 6 Plus',
	        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
	        viewport: {
	            width: 414,
	            height: 736,
	            deviceScaleFactor: 3,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'iPhone 6 Plus landscape',
	        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
	        viewport: {
	            width: 736,
	            height: 414,
	            deviceScaleFactor: 3,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'iPhone 7',
	        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
	        viewport: {
	            width: 375,
	            height: 667,
	            deviceScaleFactor: 2,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'iPhone 7 landscape',
	        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
	        viewport: {
	            width: 667,
	            height: 375,
	            deviceScaleFactor: 2,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'iPhone 7 Plus',
	        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
	        viewport: {
	            width: 414,
	            height: 736,
	            deviceScaleFactor: 3,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'iPhone 7 Plus landscape',
	        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
	        viewport: {
	            width: 736,
	            height: 414,
	            deviceScaleFactor: 3,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'iPhone 8',
	        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
	        viewport: {
	            width: 375,
	            height: 667,
	            deviceScaleFactor: 2,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'iPhone 8 landscape',
	        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
	        viewport: {
	            width: 667,
	            height: 375,
	            deviceScaleFactor: 2,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'iPhone 8 Plus',
	        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
	        viewport: {
	            width: 414,
	            height: 736,
	            deviceScaleFactor: 3,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'iPhone 8 Plus landscape',
	        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
	        viewport: {
	            width: 736,
	            height: 414,
	            deviceScaleFactor: 3,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'iPhone SE',
	        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1',
	        viewport: {
	            width: 320,
	            height: 568,
	            deviceScaleFactor: 2,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'iPhone SE landscape',
	        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1',
	        viewport: {
	            width: 568,
	            height: 320,
	            deviceScaleFactor: 2,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'iPhone X',
	        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
	        viewport: {
	            width: 375,
	            height: 812,
	            deviceScaleFactor: 3,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'iPhone X landscape',
	        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1',
	        viewport: {
	            width: 812,
	            height: 375,
	            deviceScaleFactor: 3,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'iPhone XR',
	        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0 Mobile/15E148 Safari/604.1',
	        viewport: {
	            width: 414,
	            height: 896,
	            deviceScaleFactor: 3,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'iPhone XR landscape',
	        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0 Mobile/15E148 Safari/604.1',
	        viewport: {
	            width: 896,
	            height: 414,
	            deviceScaleFactor: 3,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'iPhone 11',
	        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1',
	        viewport: {
	            width: 414,
	            height: 828,
	            deviceScaleFactor: 2,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'iPhone 11 landscape',
	        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1',
	        viewport: {
	            width: 828,
	            height: 414,
	            deviceScaleFactor: 2,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'iPhone 11 Pro',
	        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1',
	        viewport: {
	            width: 375,
	            height: 812,
	            deviceScaleFactor: 3,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'iPhone 11 Pro landscape',
	        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1',
	        viewport: {
	            width: 812,
	            height: 375,
	            deviceScaleFactor: 3,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'iPhone 11 Pro Max',
	        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1',
	        viewport: {
	            width: 414,
	            height: 896,
	            deviceScaleFactor: 3,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'iPhone 11 Pro Max landscape',
	        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1',
	        viewport: {
	            width: 896,
	            height: 414,
	            deviceScaleFactor: 3,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'iPhone 12',
	        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
	        viewport: {
	            width: 390,
	            height: 844,
	            deviceScaleFactor: 3,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'iPhone 12 landscape',
	        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
	        viewport: {
	            width: 844,
	            height: 390,
	            deviceScaleFactor: 3,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'iPhone 12 Pro',
	        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
	        viewport: {
	            width: 390,
	            height: 844,
	            deviceScaleFactor: 3,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'iPhone 12 Pro landscape',
	        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
	        viewport: {
	            width: 844,
	            height: 390,
	            deviceScaleFactor: 3,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'iPhone 12 Pro Max',
	        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
	        viewport: {
	            width: 428,
	            height: 926,
	            deviceScaleFactor: 3,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'iPhone 12 Pro Max landscape',
	        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
	        viewport: {
	            width: 926,
	            height: 428,
	            deviceScaleFactor: 3,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'iPhone 12 Mini',
	        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
	        viewport: {
	            width: 375,
	            height: 812,
	            deviceScaleFactor: 3,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'iPhone 12 Mini landscape',
	        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
	        viewport: {
	            width: 812,
	            height: 375,
	            deviceScaleFactor: 3,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'iPhone 13',
	        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
	        viewport: {
	            width: 390,
	            height: 844,
	            deviceScaleFactor: 3,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'iPhone 13 landscape',
	        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
	        viewport: {
	            width: 844,
	            height: 390,
	            deviceScaleFactor: 3,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'iPhone 13 Pro',
	        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
	        viewport: {
	            width: 390,
	            height: 844,
	            deviceScaleFactor: 3,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'iPhone 13 Pro landscape',
	        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
	        viewport: {
	            width: 844,
	            height: 390,
	            deviceScaleFactor: 3,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'iPhone 13 Pro Max',
	        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
	        viewport: {
	            width: 428,
	            height: 926,
	            deviceScaleFactor: 3,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'iPhone 13 Pro Max landscape',
	        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
	        viewport: {
	            width: 926,
	            height: 428,
	            deviceScaleFactor: 3,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'iPhone 13 Mini',
	        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
	        viewport: {
	            width: 375,
	            height: 812,
	            deviceScaleFactor: 3,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'iPhone 13 Mini landscape',
	        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1',
	        viewport: {
	            width: 812,
	            height: 375,
	            deviceScaleFactor: 3,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'JioPhone 2',
	        userAgent: 'Mozilla/5.0 (Mobile; LYF/F300B/LYF-F300B-001-01-15-130718-i;Android; rv:48.0) Gecko/48.0 Firefox/48.0 KAIOS/2.5',
	        viewport: {
	            width: 240,
	            height: 320,
	            deviceScaleFactor: 1,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'JioPhone 2 landscape',
	        userAgent: 'Mozilla/5.0 (Mobile; LYF/F300B/LYF-F300B-001-01-15-130718-i;Android; rv:48.0) Gecko/48.0 Firefox/48.0 KAIOS/2.5',
	        viewport: {
	            width: 320,
	            height: 240,
	            deviceScaleFactor: 1,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'Kindle Fire HDX',
	        userAgent: 'Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true',
	        viewport: {
	            width: 800,
	            height: 1280,
	            deviceScaleFactor: 2,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'Kindle Fire HDX landscape',
	        userAgent: 'Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true',
	        viewport: {
	            width: 1280,
	            height: 800,
	            deviceScaleFactor: 2,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'LG Optimus L70',
	        userAgent: 'Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/75.0.3765.0 Mobile Safari/537.36',
	        viewport: {
	            width: 384,
	            height: 640,
	            deviceScaleFactor: 1.25,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'LG Optimus L70 landscape',
	        userAgent: 'Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/75.0.3765.0 Mobile Safari/537.36',
	        viewport: {
	            width: 640,
	            height: 384,
	            deviceScaleFactor: 1.25,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'Microsoft Lumia 550',
	        userAgent: 'Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 550) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263',
	        viewport: {
	            width: 640,
	            height: 360,
	            deviceScaleFactor: 2,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'Microsoft Lumia 950',
	        userAgent: 'Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263',
	        viewport: {
	            width: 360,
	            height: 640,
	            deviceScaleFactor: 4,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'Microsoft Lumia 950 landscape',
	        userAgent: 'Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263',
	        viewport: {
	            width: 640,
	            height: 360,
	            deviceScaleFactor: 4,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'Nexus 10',
	        userAgent: 'Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36',
	        viewport: {
	            width: 800,
	            height: 1280,
	            deviceScaleFactor: 2,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'Nexus 10 landscape',
	        userAgent: 'Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36',
	        viewport: {
	            width: 1280,
	            height: 800,
	            deviceScaleFactor: 2,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'Nexus 4',
	        userAgent: 'Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
	        viewport: {
	            width: 384,
	            height: 640,
	            deviceScaleFactor: 2,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'Nexus 4 landscape',
	        userAgent: 'Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
	        viewport: {
	            width: 640,
	            height: 384,
	            deviceScaleFactor: 2,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'Nexus 5',
	        userAgent: 'Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
	        viewport: {
	            width: 360,
	            height: 640,
	            deviceScaleFactor: 3,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'Nexus 5 landscape',
	        userAgent: 'Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
	        viewport: {
	            width: 640,
	            height: 360,
	            deviceScaleFactor: 3,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'Nexus 5X',
	        userAgent: 'Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
	        viewport: {
	            width: 412,
	            height: 732,
	            deviceScaleFactor: 2.625,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'Nexus 5X landscape',
	        userAgent: 'Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
	        viewport: {
	            width: 732,
	            height: 412,
	            deviceScaleFactor: 2.625,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'Nexus 6',
	        userAgent: 'Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
	        viewport: {
	            width: 412,
	            height: 732,
	            deviceScaleFactor: 3.5,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'Nexus 6 landscape',
	        userAgent: 'Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
	        viewport: {
	            width: 732,
	            height: 412,
	            deviceScaleFactor: 3.5,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'Nexus 6P',
	        userAgent: 'Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
	        viewport: {
	            width: 412,
	            height: 732,
	            deviceScaleFactor: 3.5,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'Nexus 6P landscape',
	        userAgent: 'Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
	        viewport: {
	            width: 732,
	            height: 412,
	            deviceScaleFactor: 3.5,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'Nexus 7',
	        userAgent: 'Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36',
	        viewport: {
	            width: 600,
	            height: 960,
	            deviceScaleFactor: 2,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'Nexus 7 landscape',
	        userAgent: 'Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36',
	        viewport: {
	            width: 960,
	            height: 600,
	            deviceScaleFactor: 2,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'Nokia Lumia 520',
	        userAgent: 'Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)',
	        viewport: {
	            width: 320,
	            height: 533,
	            deviceScaleFactor: 1.5,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'Nokia Lumia 520 landscape',
	        userAgent: 'Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)',
	        viewport: {
	            width: 533,
	            height: 320,
	            deviceScaleFactor: 1.5,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'Nokia N9',
	        userAgent: 'Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13',
	        viewport: {
	            width: 480,
	            height: 854,
	            deviceScaleFactor: 1,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'Nokia N9 landscape',
	        userAgent: 'Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13',
	        viewport: {
	            width: 854,
	            height: 480,
	            deviceScaleFactor: 1,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'Pixel 2',
	        userAgent: 'Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
	        viewport: {
	            width: 411,
	            height: 731,
	            deviceScaleFactor: 2.625,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'Pixel 2 landscape',
	        userAgent: 'Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
	        viewport: {
	            width: 731,
	            height: 411,
	            deviceScaleFactor: 2.625,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'Pixel 2 XL',
	        userAgent: 'Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
	        viewport: {
	            width: 411,
	            height: 823,
	            deviceScaleFactor: 3.5,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'Pixel 2 XL landscape',
	        userAgent: 'Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36',
	        viewport: {
	            width: 823,
	            height: 411,
	            deviceScaleFactor: 3.5,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'Pixel 3',
	        userAgent: 'Mozilla/5.0 (Linux; Android 9; Pixel 3 Build/PQ1A.181105.017.A1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.158 Mobile Safari/537.36',
	        viewport: {
	            width: 393,
	            height: 786,
	            deviceScaleFactor: 2.75,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'Pixel 3 landscape',
	        userAgent: 'Mozilla/5.0 (Linux; Android 9; Pixel 3 Build/PQ1A.181105.017.A1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.158 Mobile Safari/537.36',
	        viewport: {
	            width: 786,
	            height: 393,
	            deviceScaleFactor: 2.75,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'Pixel 4',
	        userAgent: 'Mozilla/5.0 (Linux; Android 10; Pixel 4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Mobile Safari/537.36',
	        viewport: {
	            width: 353,
	            height: 745,
	            deviceScaleFactor: 3,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'Pixel 4 landscape',
	        userAgent: 'Mozilla/5.0 (Linux; Android 10; Pixel 4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Mobile Safari/537.36',
	        viewport: {
	            width: 745,
	            height: 353,
	            deviceScaleFactor: 3,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'Pixel 4a (5G)',
	        userAgent: 'Mozilla/5.0 (Linux; Android 11; Pixel 4a (5G)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36',
	        viewport: {
	            width: 353,
	            height: 745,
	            deviceScaleFactor: 3,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'Pixel 4a (5G) landscape',
	        userAgent: 'Mozilla/5.0 (Linux; Android 11; Pixel 4a (5G)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36',
	        viewport: {
	            width: 745,
	            height: 353,
	            deviceScaleFactor: 3,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'Pixel 5',
	        userAgent: 'Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36',
	        viewport: {
	            width: 393,
	            height: 851,
	            deviceScaleFactor: 3,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'Pixel 5 landscape',
	        userAgent: 'Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36',
	        viewport: {
	            width: 851,
	            height: 393,
	            deviceScaleFactor: 3,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	    {
	        name: 'Moto G4',
	        userAgent: 'Mozilla/5.0 (Linux; Android 7.0; Moto G (4)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36',
	        viewport: {
	            width: 360,
	            height: 640,
	            deviceScaleFactor: 3,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: false,
	        },
	    },
	    {
	        name: 'Moto G4 landscape',
	        userAgent: 'Mozilla/5.0 (Linux; Android 7.0; Moto G (4)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36',
	        viewport: {
	            width: 640,
	            height: 360,
	            deviceScaleFactor: 3,
	            isMobile: true,
	            hasTouch: true,
	            isLandscape: true,
	        },
	    },
	];
	const knownDevicesByName = {};
	for (const device of knownDevices) {
	    knownDevicesByName[device.name] = device;
	}
	/**
	 * A list of devices to be used with {@link Page.emulate}.
	 *
	 * @example
	 *
	 * ```ts
	 * import {KnownDevices} from 'puppeteer';
	 * const iPhone = KnownDevices['iPhone 6'];
	 *
	 * (async () => {
	 *   const browser = await puppeteer.launch();
	 *   const page = await browser.newPage();
	 *   await page.emulate(iPhone);
	 *   await page.goto('https://www.google.com');
	 *   // other actions...
	 *   await browser.close();
	 * })();
	 * ```
	 *
	 * @public
	 */
	exports.KnownDevices = Object.freeze(knownDevicesByName);
	/**
	 * @deprecated Import {@link KnownDevices}
	 *
	 * @public
	 */
	exports.devices = exports.KnownDevices;
	
} (Device));

var PredefinedNetworkConditions = {};

(function (exports) {
	/**
	 * Copyright 2021 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.networkConditions = exports.PredefinedNetworkConditions = void 0;
	/**
	 * A list of network conditions to be used with
	 * {@link Page.emulateNetworkConditions}.
	 *
	 * @example
	 *
	 * ```ts
	 * import {PredefinedNetworkConditions} from 'puppeteer';
	 * const slow3G = PredefinedNetworkConditions['Slow 3G'];
	 *
	 * (async () => {
	 *   const browser = await puppeteer.launch();
	 *   const page = await browser.newPage();
	 *   await page.emulateNetworkConditions(slow3G);
	 *   await page.goto('https://www.google.com');
	 *   // other actions...
	 *   await browser.close();
	 * })();
	 * ```
	 *
	 * @public
	 */
	exports.PredefinedNetworkConditions = Object.freeze({
	    'Slow 3G': {
	        download: ((500 * 1000) / 8) * 0.8,
	        upload: ((500 * 1000) / 8) * 0.8,
	        latency: 400 * 5,
	    },
	    'Fast 3G': {
	        download: ((1.6 * 1000 * 1000) / 8) * 0.9,
	        upload: ((750 * 1000) / 8) * 0.9,
	        latency: 150 * 3.75,
	    },
	});
	/**
	 * @deprecated Import {@link PredefinedNetworkConditions}.
	 *
	 * @public
	 */
	exports.networkConditions = exports.PredefinedNetworkConditions;
	
} (PredefinedNetworkConditions));

var Product = {};

/**
 * Copyright 2020 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(Product, "__esModule", { value: true });

var Puppeteer$1 = {};

/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(Puppeteer$1, "__esModule", { value: true });
Puppeteer$1.Puppeteer = void 0;
const BrowserConnector_js_1 = BrowserConnector;
const CustomQueryHandler_js_1 = requireCustomQueryHandler();
/**
 * The main Puppeteer class.
 *
 * IMPORTANT: if you are using Puppeteer in a Node environment, you will get an
 * instance of {@link PuppeteerNode} when you import or require `puppeteer`.
 * That class extends `Puppeteer`, so has all the methods documented below as
 * well as all that are defined on {@link PuppeteerNode}.
 *
 * @public
 */
class Puppeteer {
    /**
     * Operations for {@link CustomQueryHandler | custom query handlers}. See
     * {@link CustomQueryHandlerRegistry}.
     *
     * @internal
     */
    static customQueryHandlers = CustomQueryHandler_js_1.customQueryHandlers;
    /**
     * Registers a {@link CustomQueryHandler | custom query handler}.
     *
     * @remarks
     * After registration, the handler can be used everywhere where a selector is
     * expected by prepending the selection string with `<name>/`. The name is only
     * allowed to consist of lower- and upper case latin letters.
     *
     * @example
     *
     * ```
     * puppeteer.registerCustomQueryHandler('text', { … });
     * const aHandle = await page.$('text/…');
     * ```
     *
     * @param name - The name that the custom query handler will be registered
     * under.
     * @param queryHandler - The {@link CustomQueryHandler | custom query handler}
     * to register.
     *
     * @public
     */
    static registerCustomQueryHandler(name, queryHandler) {
        return this.customQueryHandlers.register(name, queryHandler);
    }
    /**
     * Unregisters a custom query handler for a given name.
     */
    static unregisterCustomQueryHandler(name) {
        return this.customQueryHandlers.unregister(name);
    }
    /**
     * Gets the names of all custom query handlers.
     */
    static customQueryHandlerNames() {
        return this.customQueryHandlers.names();
    }
    /**
     * Unregisters all custom query handlers.
     */
    static clearCustomQueryHandlers() {
        return this.customQueryHandlers.clear();
    }
    /**
     * @internal
     */
    _isPuppeteerCore;
    /**
     * @internal
     */
    _changedProduct = false;
    /**
     * @internal
     */
    constructor(settings) {
        this._isPuppeteerCore = settings.isPuppeteerCore;
        this.connect = this.connect.bind(this);
    }
    /**
     * This method attaches Puppeteer to an existing browser instance.
     *
     * @remarks
     *
     * @param options - Set of configurable options to set on the browser.
     * @returns Promise which resolves to browser instance.
     */
    connect(options) {
        return (0, BrowserConnector_js_1._connectToCDPBrowser)(options);
    }
}
Puppeteer$1.Puppeteer = Puppeteer;

var PuppeteerViewport = {};

Object.defineProperty(PuppeteerViewport, "__esModule", { value: true });

var TargetManager = {};

/**
 * Copyright 2022 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(TargetManager, "__esModule", { value: true });

var types = {};

/**
 * Copyright 2020 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(types, "__esModule", { value: true });

(function (exports) {
	/**
	 * Copyright 2022 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	__exportStar(Accessibility$1, exports);
	__exportStar(requireAriaQueryHandler(), exports);
	__exportStar(Binding$1, exports);
	__exportStar(Browser$1, exports);
	__exportStar(BrowserConnector, exports);
	__exportStar(BrowserWebSocketTransport$1, exports);
	__exportStar(ChromeTargetManager$1, exports);
	__exportStar(Configuration, exports);
	__exportStar(Connection$1, exports);
	__exportStar(ConnectionTransport, exports);
	__exportStar(ConsoleMessage$1, exports);
	__exportStar(Coverage$1, exports);
	__exportStar(requireCustomQueryHandler(), exports);
	__exportStar(Debug, exports);
	__exportStar(Device, exports);
	__exportStar(DeviceRequestPrompt$1, exports);
	__exportStar(Dialog$1, exports);
	__exportStar(requireElementHandle$1(), exports);
	__exportStar(EmulationManager$2, exports);
	__exportStar(Errors, exports);
	__exportStar(EventEmitter$1, exports);
	__exportStar(ExecutionContext$1, exports);
	__exportStar(fetch, exports);
	__exportStar(FileChooser$1, exports);
	__exportStar(FirefoxTargetManager$1, exports);
	__exportStar(requireFrameManager(), exports);
	__exportStar(FrameTree$1, exports);
	__exportStar(Input$1, exports);
	__exportStar(requireIsolatedWorld(), exports);
	__exportStar(IsolatedWorlds, exports);
	__exportStar(requireJSHandle$1(), exports);
	__exportStar(LazyArg$1, exports);
	__exportStar(requireLifecycleWatcher(), exports);
	__exportStar(NetworkEventManager$1, exports);
	__exportStar(NetworkManager$1, exports);
	__exportStar(NodeWebSocketTransport$1, exports);
	__exportStar(Page$1, exports);
	__exportStar(PDFOptions, exports);
	__exportStar(PredefinedNetworkConditions, exports);
	__exportStar(Product, exports);
	__exportStar(Puppeteer$1, exports);
	__exportStar(PuppeteerViewport, exports);
	__exportStar(requireQueryHandler(), exports);
	__exportStar(SecurityDetails$1, exports);
	__exportStar(Target$1, exports);
	__exportStar(TargetManager, exports);
	__exportStar(TaskQueue$1, exports);
	__exportStar(TimeoutSettings$1, exports);
	__exportStar(Tracing$1, exports);
	__exportStar(types, exports);
	__exportStar(USKeyboardLayout, exports);
	__exportStar(requireUtil(), exports);
	__exportStar(WaitTask$1, exports);
	__exportStar(WebWorker$1, exports);
	
} (common));

var node = {};

var ChromeLauncher$1 = {};

var ProductLauncher$1 = {};

var PipeTransport$1 = {};

Object.defineProperty(PipeTransport$1, "__esModule", { value: true });
PipeTransport$1.PipeTransport = void 0;
const util_js_1$3 = requireUtil();
const assert_js_1$2 = assert$1;
/**
 * @internal
 */
class PipeTransport {
    #pipeWrite;
    #eventListeners;
    #isClosed = false;
    #pendingMessage = '';
    onclose;
    onmessage;
    constructor(pipeWrite, pipeRead) {
        this.#pipeWrite = pipeWrite;
        this.#eventListeners = [
            (0, util_js_1$3.addEventListener)(pipeRead, 'data', buffer => {
                return this.#dispatch(buffer);
            }),
            (0, util_js_1$3.addEventListener)(pipeRead, 'close', () => {
                if (this.onclose) {
                    this.onclose.call(null);
                }
            }),
            (0, util_js_1$3.addEventListener)(pipeRead, 'error', util_js_1$3.debugError),
            (0, util_js_1$3.addEventListener)(pipeWrite, 'error', util_js_1$3.debugError),
        ];
    }
    send(message) {
        (0, assert_js_1$2.assert)(!this.#isClosed, '`PipeTransport` is closed.');
        this.#pipeWrite.write(message);
        this.#pipeWrite.write('\0');
    }
    #dispatch(buffer) {
        (0, assert_js_1$2.assert)(!this.#isClosed, '`PipeTransport` is closed.');
        let end = buffer.indexOf('\0');
        if (end === -1) {
            this.#pendingMessage += buffer.toString();
            return;
        }
        const message = this.#pendingMessage + buffer.toString(undefined, 0, end);
        if (this.onmessage) {
            this.onmessage.call(null, message);
        }
        let start = end + 1;
        end = buffer.indexOf('\0', start);
        while (end !== -1) {
            if (this.onmessage) {
                this.onmessage.call(null, buffer.toString(undefined, start, end));
            }
            start = end + 1;
            end = buffer.indexOf('\0', start);
        }
        this.#pendingMessage = buffer.toString(undefined, start);
    }
    close() {
        this.#isClosed = true;
        (0, util_js_1$3.removeEventListeners)(this.#eventListeners);
    }
}
PipeTransport$1.PipeTransport = PipeTransport;

var bidi = {};

var BidiOverCDP = {};

var Connection = {};

var BrowsingContext = {};

var Realm = {};

var ElementHandle = {};

var JSHandle = {};

var Serializer = {};

var hasRequiredSerializer;

function requireSerializer () {
	if (hasRequiredSerializer) return Serializer;
	hasRequiredSerializer = 1;
	/**
	 * Copyright 2023 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(Serializer, "__esModule", { value: true });
	Serializer.BidiSerializer = void 0;
	const LazyArg_js_1 = LazyArg$1;
	const util_js_1 = requireUtil();
	const ElementHandle_js_1 = requireElementHandle();
	const JSHandle_js_1 = requireJSHandle();
	/**
	 * @internal
	 */
	class UnserializableError extends Error {
	}
	/**
	 * @internal
	 */
	class BidiSerializer {
	    static serializeNumber(arg) {
	        let value;
	        if (Object.is(arg, -0)) {
	            value = '-0';
	        }
	        else if (Object.is(arg, Infinity)) {
	            value = 'Infinity';
	        }
	        else if (Object.is(arg, -Infinity)) {
	            value = '-Infinity';
	        }
	        else if (Object.is(arg, NaN)) {
	            value = 'NaN';
	        }
	        else {
	            value = arg;
	        }
	        return {
	            type: 'number',
	            value,
	        };
	    }
	    static serializeObject(arg) {
	        if (arg === null) {
	            return {
	                type: 'null',
	            };
	        }
	        else if (Array.isArray(arg)) {
	            const parsedArray = arg.map(subArg => {
	                return BidiSerializer.serializeRemoteValue(subArg);
	            });
	            return {
	                type: 'array',
	                value: parsedArray,
	            };
	        }
	        else if ((0, util_js_1.isPlainObject)(arg)) {
	            try {
	                JSON.stringify(arg);
	            }
	            catch (error) {
	                if (error instanceof TypeError &&
	                    error.message.startsWith('Converting circular structure to JSON')) {
	                    error.message += ' Recursive objects are not allowed.';
	                }
	                throw error;
	            }
	            const parsedObject = [];
	            for (const key in arg) {
	                parsedObject.push([
	                    BidiSerializer.serializeRemoteValue(key),
	                    BidiSerializer.serializeRemoteValue(arg[key]),
	                ]);
	            }
	            return {
	                type: 'object',
	                value: parsedObject,
	            };
	        }
	        else if ((0, util_js_1.isRegExp)(arg)) {
	            return {
	                type: 'regexp',
	                value: {
	                    pattern: arg.source,
	                    flags: arg.flags,
	                },
	            };
	        }
	        else if ((0, util_js_1.isDate)(arg)) {
	            return {
	                type: 'date',
	                value: arg.toISOString(),
	            };
	        }
	        throw new UnserializableError('Custom object sterilization not possible. Use plain objects instead.');
	    }
	    static serializeRemoteValue(arg) {
	        switch (typeof arg) {
	            case 'symbol':
	            case 'function':
	                throw new UnserializableError(`Unable to serializable ${typeof arg}`);
	            case 'object':
	                return BidiSerializer.serializeObject(arg);
	            case 'undefined':
	                return {
	                    type: 'undefined',
	                };
	            case 'number':
	                return BidiSerializer.serializeNumber(arg);
	            case 'bigint':
	                return {
	                    type: 'bigint',
	                    value: arg.toString(),
	                };
	            case 'string':
	                return {
	                    type: 'string',
	                    value: arg,
	                };
	            case 'boolean':
	                return {
	                    type: 'boolean',
	                    value: arg,
	                };
	        }
	    }
	    static async serialize(sandbox, arg) {
	        if (arg instanceof LazyArg_js_1.LazyArg) {
	            arg = await arg.get(sandbox.realm);
	        }
	        // eslint-disable-next-line rulesdir/use-using -- We want this to continue living.
	        const objectHandle = arg && (arg instanceof JSHandle_js_1.BidiJSHandle || arg instanceof ElementHandle_js_1.BidiElementHandle)
	            ? arg
	            : null;
	        if (objectHandle) {
	            if (objectHandle.realm.environment.context() !==
	                sandbox.environment.context() &&
	                !('sharedId' in objectHandle.remoteValue())) {
	                throw new Error('JSHandles can be evaluated only in the context they were created!');
	            }
	            if (objectHandle.disposed) {
	                throw new Error('JSHandle is disposed!');
	            }
	            return objectHandle.remoteValue();
	        }
	        return BidiSerializer.serializeRemoteValue(arg);
	    }
	    static deserializeNumber(value) {
	        switch (value) {
	            case '-0':
	                return -0;
	            case 'NaN':
	                return NaN;
	            case 'Infinity':
	                return Infinity;
	            case '-Infinity':
	                return -Infinity;
	            default:
	                return value;
	        }
	    }
	    static deserializeLocalValue(result) {
	        switch (result.type) {
	            case 'array':
	                if (result.value) {
	                    return result.value.map(value => {
	                        return BidiSerializer.deserializeLocalValue(value);
	                    });
	                }
	                break;
	            case 'set':
	                if (result.value) {
	                    return result.value.reduce((acc, value) => {
	                        return acc.add(BidiSerializer.deserializeLocalValue(value));
	                    }, new Set());
	                }
	                break;
	            case 'object':
	                if (result.value) {
	                    return result.value.reduce((acc, tuple) => {
	                        const { key, value } = BidiSerializer.deserializeTuple(tuple);
	                        acc[key] = value;
	                        return acc;
	                    }, {});
	                }
	                break;
	            case 'map':
	                if (result.value) {
	                    return result.value?.reduce((acc, tuple) => {
	                        const { key, value } = BidiSerializer.deserializeTuple(tuple);
	                        return acc.set(key, value);
	                    }, new Map());
	                }
	                break;
	            case 'promise':
	                return {};
	            case 'regexp':
	                return new RegExp(result.value.pattern, result.value.flags);
	            case 'date':
	                return new Date(result.value);
	            case 'undefined':
	                return undefined;
	            case 'null':
	                return null;
	            case 'number':
	                return BidiSerializer.deserializeNumber(result.value);
	            case 'bigint':
	                return BigInt(result.value);
	            case 'boolean':
	                return Boolean(result.value);
	            case 'string':
	                return result.value;
	        }
	        throw new UnserializableError(`Deserialization of type ${result.type} not supported.`);
	    }
	    static deserializeTuple([serializedKey, serializedValue]) {
	        const key = typeof serializedKey === 'string'
	            ? serializedKey
	            : BidiSerializer.deserializeLocalValue(serializedKey);
	        const value = BidiSerializer.deserializeLocalValue(serializedValue);
	        return { key, value };
	    }
	    static deserialize(result) {
	        if (!result) {
	            (0, util_js_1.debugError)('Service did not produce a result.');
	            return undefined;
	        }
	        try {
	            return BidiSerializer.deserializeLocalValue(result);
	        }
	        catch (error) {
	            if (error instanceof UnserializableError) {
	                (0, util_js_1.debugError)(error.message);
	                return undefined;
	            }
	            throw error;
	        }
	    }
	}
	Serializer.BidiSerializer = BidiSerializer;
	
	return Serializer;
}

var utils = {};

var hasRequiredUtils;

function requireUtils () {
	if (hasRequiredUtils) return utils;
	hasRequiredUtils = 1;
	(function (exports) {
		/**
		 * Copyright 2023 Google Inc. All rights reserved.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *     http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.createEvaluationError = exports.releaseReference = exports.debugError = void 0;
		const Debug_js_1 = Debug;
		const util_js_1 = requireUtil();
		const Serializer_js_1 = requireSerializer();
		/**
		 * @internal
		 */
		exports.debugError = (0, Debug_js_1.debug)('puppeteer:error');
		/**
		 * @internal
		 */
		async function releaseReference(client, remoteReference) {
		    if (!remoteReference.handle) {
		        return;
		    }
		    await client.connection
		        .send('script.disown', {
		        target: client.target,
		        handles: [remoteReference.handle],
		    })
		        .catch((error) => {
		        // Exceptions might happen in case of a page been navigated or closed.
		        // Swallow these since they are harmless and we don't leak anything in this case.
		        (0, exports.debugError)(error);
		    });
		}
		exports.releaseReference = releaseReference;
		/**
		 * @internal
		 */
		function createEvaluationError(details) {
		    if (details.exception.type !== 'error') {
		        return Serializer_js_1.BidiSerializer.deserialize(details.exception);
		    }
		    const [name = '', ...parts] = details.text.split(': ');
		    const message = parts.join(': ');
		    const error = new Error(message);
		    error.name = name;
		    // The first line is this function which we ignore.
		    const stackLines = [];
		    if (details.stackTrace && stackLines.length < Error.stackTraceLimit) {
		        for (const frame of details.stackTrace.callFrames.reverse()) {
		            if (util_js_1.PuppeteerURL.isPuppeteerURL(frame.url) &&
		                frame.url !== util_js_1.PuppeteerURL.INTERNAL_URL) {
		                const url = util_js_1.PuppeteerURL.parse(frame.url);
		                stackLines.unshift(`    at ${frame.functionName || url.functionName} (${url.functionName} at ${url.siteString}, <anonymous>:${frame.lineNumber}:${frame.columnNumber})`);
		            }
		            else {
		                stackLines.push(`    at ${frame.functionName || '<anonymous>'} (${frame.url}:${frame.lineNumber}:${frame.columnNumber})`);
		            }
		            if (stackLines.length >= Error.stackTraceLimit) {
		                break;
		            }
		        }
		    }
		    error.stack = [details.text, ...stackLines].join('\n');
		    return error;
		}
		exports.createEvaluationError = createEvaluationError;
		
	} (utils));
	return utils;
}

var hasRequiredJSHandle;

function requireJSHandle () {
	if (hasRequiredJSHandle) return JSHandle;
	hasRequiredJSHandle = 1;
	/**
	 * Copyright 2023 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(JSHandle, "__esModule", { value: true });
	JSHandle.BidiJSHandle = void 0;
	const JSHandle_js_1 = requireJSHandle$2();
	const Serializer_js_1 = requireSerializer();
	const utils_js_1 = requireUtils();
	class BidiJSHandle extends JSHandle_js_1.JSHandle {
	    #disposed = false;
	    #sandbox;
	    #remoteValue;
	    constructor(sandbox, remoteValue) {
	        super();
	        this.#sandbox = sandbox;
	        this.#remoteValue = remoteValue;
	    }
	    context() {
	        return this.realm.environment.context();
	    }
	    get realm() {
	        return this.#sandbox;
	    }
	    get disposed() {
	        return this.#disposed;
	    }
	    async jsonValue() {
	        return await this.evaluate(value => {
	            return value;
	        });
	    }
	    asElement() {
	        return null;
	    }
	    async dispose() {
	        if (this.#disposed) {
	            return;
	        }
	        this.#disposed = true;
	        if ('handle' in this.#remoteValue) {
	            await (0, utils_js_1.releaseReference)(this.context(), this.#remoteValue);
	        }
	    }
	    get isPrimitiveValue() {
	        switch (this.#remoteValue.type) {
	            case 'string':
	            case 'number':
	            case 'bigint':
	            case 'boolean':
	            case 'undefined':
	            case 'null':
	                return true;
	            default:
	                return false;
	        }
	    }
	    toString() {
	        if (this.isPrimitiveValue) {
	            return 'JSHandle:' + Serializer_js_1.BidiSerializer.deserialize(this.#remoteValue);
	        }
	        return 'JSHandle@' + this.#remoteValue.type;
	    }
	    get id() {
	        return 'handle' in this.#remoteValue ? this.#remoteValue.handle : undefined;
	    }
	    remoteValue() {
	        return this.#remoteValue;
	    }
	    remoteObject() {
	        throw new Error('Not available in WebDriver BiDi');
	    }
	}
	JSHandle.BidiJSHandle = BidiJSHandle;
	
	return JSHandle;
}

var hasRequiredElementHandle;

function requireElementHandle () {
	if (hasRequiredElementHandle) return ElementHandle;
	hasRequiredElementHandle = 1;
	/**
	 * Copyright 2023 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var __runInitializers = (commonjsGlobal && commonjsGlobal.__runInitializers) || function (thisArg, initializers, value) {
	    var useValue = arguments.length > 2;
	    for (var i = 0; i < initializers.length; i++) {
	        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
	    }
	    return useValue ? value : void 0;
	};
	var __esDecorate = (commonjsGlobal && commonjsGlobal.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
	    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
	    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
	    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
	    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
	    var _, done = false;
	    for (var i = decorators.length - 1; i >= 0; i--) {
	        var context = {};
	        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
	        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
	        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
	        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
	        if (kind === "accessor") {
	            if (result === void 0) continue;
	            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
	            if (_ = accept(result.get)) descriptor.get = _;
	            if (_ = accept(result.set)) descriptor.set = _;
	            if (_ = accept(result.init)) initializers.unshift(_);
	        }
	        else if (_ = accept(result)) {
	            if (kind === "field") initializers.unshift(_);
	            else descriptor[key] = _;
	        }
	    }
	    if (target) Object.defineProperty(target, contextIn.name, descriptor);
	    done = true;
	};
	var __addDisposableResource = (commonjsGlobal && commonjsGlobal.__addDisposableResource) || function (env, value, async) {
	    if (value !== null && value !== void 0) {
	        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
	        var dispose;
	        if (async) {
	            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
	            dispose = value[Symbol.asyncDispose];
	        }
	        if (dispose === void 0) {
	            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
	            dispose = value[Symbol.dispose];
	        }
	        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
	        env.stack.push({ value: value, dispose: dispose, async: async });
	    }
	    else if (async) {
	        env.stack.push({ async: true });
	    }
	    return value;
	};
	var __disposeResources = (commonjsGlobal && commonjsGlobal.__disposeResources) || (function (SuppressedError) {
	    return function (env) {
	        function fail(e) {
	            env.error = env.hasError ? new SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
	            env.hasError = true;
	        }
	        function next() {
	            while (env.stack.length) {
	                var rec = env.stack.pop();
	                try {
	                    var result = rec.dispose && rec.dispose.call(rec.value);
	                    if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
	                }
	                catch (e) {
	                    fail(e);
	                }
	            }
	            if (env.hasError) throw env.error;
	        }
	        return next();
	    };
	})(typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
	    var e = new Error(message);
	    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
	});
	Object.defineProperty(ElementHandle, "__esModule", { value: true });
	ElementHandle.BidiElementHandle = void 0;
	const ElementHandle_js_1 = requireElementHandle$2();
	const JSHandle_js_1 = requireJSHandle();
	/**
	 * @internal
	 */
	let BidiElementHandle = (() => {
	    var _a;
	    let _classSuper = ElementHandle_js_1.ElementHandle;
	    let _instanceExtraInitializers = [];
	    let _contentFrame_decorators;
	    return class BidiElementHandle extends _classSuper {
	        static {
	            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
	            _contentFrame_decorators = [(_a = ElementHandle_js_1.ElementHandle).bindIsolatedHandle.bind(_a)];
	            __esDecorate(this, null, _contentFrame_decorators, { kind: "method", name: "contentFrame", static: false, private: false, access: { has: obj => "contentFrame" in obj, get: obj => obj.contentFrame }, metadata: _metadata }, null, _instanceExtraInitializers);
	            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
	        }
	        constructor(sandbox, remoteValue) {
	            super(new JSHandle_js_1.BidiJSHandle(sandbox, remoteValue));
	            __runInitializers(this, _instanceExtraInitializers);
	        }
	        get realm() {
	            return this.handle.realm;
	        }
	        get frame() {
	            return this.realm.environment;
	        }
	        context() {
	            return this.handle.context();
	        }
	        get isPrimitiveValue() {
	            return this.handle.isPrimitiveValue;
	        }
	        remoteValue() {
	            return this.handle.remoteValue();
	        }
	        async autofill(data) {
	            const client = this.frame.client;
	            const nodeInfo = await client.send('DOM.describeNode', {
	                objectId: this.handle.id,
	            });
	            const fieldId = nodeInfo.node.backendNodeId;
	            const frameId = this.frame._id;
	            await client.send('Autofill.trigger', {
	                fieldId,
	                frameId,
	                card: data.creditCard,
	            });
	        }
	        async contentFrame() {
	            const env_1 = { stack: [], error: void 0, hasError: false };
	            try {
	                const handle = __addDisposableResource(env_1, (await this.evaluateHandle(element => {
	                    if (element instanceof HTMLIFrameElement) {
	                        return element.contentWindow;
	                    }
	                    return;
	                })), false);
	                const value = handle.remoteValue();
	                if (value.type === 'window') {
	                    return this.frame.page().frame(value.value.context);
	                }
	                return null;
	            }
	            catch (e_1) {
	                env_1.error = e_1;
	                env_1.hasError = true;
	            }
	            finally {
	                __disposeResources(env_1);
	            }
	        }
	    };
	})();
	ElementHandle.BidiElementHandle = BidiElementHandle;
	
	return ElementHandle;
}

var hasRequiredRealm;

function requireRealm () {
	if (hasRequiredRealm) return Realm;
	hasRequiredRealm = 1;
	(function (exports) {
		var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
		    Object.defineProperty(o, "default", { enumerable: true, value: v });
		}) : function(o, v) {
		    o["default"] = v;
		});
		var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
		    if (mod && mod.__esModule) return mod;
		    var result = {};
		    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		    __setModuleDefault(result, mod);
		    return result;
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.createBidiHandle = exports.Realm = exports.getSourceUrlComment = exports.SOURCE_URL_REGEX = void 0;
		const Bidi = __importStar(require$$0$2);
		const Function_js_1 = _Function;
		const EventEmitter_js_1 = EventEmitter$1;
		const ScriptInjector_js_1 = ScriptInjector$1;
		const util_js_1 = requireUtil();
		const ElementHandle_js_1 = requireElementHandle();
		const JSHandle_js_1 = requireJSHandle();
		const Serializer_js_1 = requireSerializer();
		const utils_js_1 = requireUtils();
		exports.SOURCE_URL_REGEX = /^[\040\t]*\/\/[@#] sourceURL=\s*(\S*?)\s*$/m;
		const getSourceUrlComment = (url) => {
		    return `//# sourceURL=${url}`;
		};
		exports.getSourceUrlComment = getSourceUrlComment;
		class Realm extends EventEmitter_js_1.EventEmitter {
		    connection;
		    #id;
		    #sandbox;
		    constructor(connection) {
		        super();
		        this.connection = connection;
		    }
		    get target() {
		        return {
		            context: this.#sandbox.environment._id,
		            sandbox: this.#sandbox.name,
		        };
		    }
		    handleRealmDestroyed = async (params) => {
		        if (params.realm === this.#id) {
		            // Note: The Realm is destroyed, so in theory the handle should be as
		            // well.
		            this.internalPuppeteerUtil = undefined;
		            this.#sandbox.environment.clearDocumentHandle();
		        }
		    };
		    handleRealmCreated = (params) => {
		        if (params.type === 'window' &&
		            params.context === this.#sandbox.environment._id &&
		            params.sandbox === this.#sandbox.name) {
		            this.#id = params.realm;
		            void this.#sandbox.taskManager.rerunAll();
		        }
		    };
		    setSandbox(sandbox) {
		        this.#sandbox = sandbox;
		        this.connection.on(Bidi.ChromiumBidi.Script.EventNames.RealmCreated, this.handleRealmCreated);
		        this.connection.on(Bidi.ChromiumBidi.Script.EventNames.RealmDestroyed, this.handleRealmDestroyed);
		    }
		    internalPuppeteerUtil;
		    get puppeteerUtil() {
		        const promise = Promise.resolve();
		        ScriptInjector_js_1.scriptInjector.inject(script => {
		            if (this.internalPuppeteerUtil) {
		                void this.internalPuppeteerUtil.then(handle => {
		                    void handle.dispose();
		                });
		            }
		            this.internalPuppeteerUtil = promise.then(() => {
		                return this.evaluateHandle(script);
		            });
		        }, !this.internalPuppeteerUtil);
		        return this.internalPuppeteerUtil;
		    }
		    async evaluateHandle(pageFunction, ...args) {
		        return await this.#evaluate(false, pageFunction, ...args);
		    }
		    async evaluate(pageFunction, ...args) {
		        return await this.#evaluate(true, pageFunction, ...args);
		    }
		    async #evaluate(returnByValue, pageFunction, ...args) {
		        const sourceUrlComment = (0, exports.getSourceUrlComment)((0, util_js_1.getSourcePuppeteerURLIfAvailable)(pageFunction)?.toString() ??
		            util_js_1.PuppeteerURL.INTERNAL_URL);
		        const sandbox = this.#sandbox;
		        let responsePromise;
		        const resultOwnership = returnByValue
		            ? "none" /* Bidi.Script.ResultOwnership.None */
		            : "root" /* Bidi.Script.ResultOwnership.Root */;
		        const serializationOptions = returnByValue
		            ? {}
		            : {
		                maxObjectDepth: 0,
		                maxDomDepth: 0,
		            };
		        if ((0, util_js_1.isString)(pageFunction)) {
		            const expression = exports.SOURCE_URL_REGEX.test(pageFunction)
		                ? pageFunction
		                : `${pageFunction}\n${sourceUrlComment}\n`;
		            responsePromise = this.connection.send('script.evaluate', {
		                expression,
		                target: this.target,
		                resultOwnership,
		                awaitPromise: true,
		                userActivation: true,
		                serializationOptions,
		            });
		        }
		        else {
		            let functionDeclaration = (0, Function_js_1.stringifyFunction)(pageFunction);
		            functionDeclaration = exports.SOURCE_URL_REGEX.test(functionDeclaration)
		                ? functionDeclaration
		                : `${functionDeclaration}\n${sourceUrlComment}\n`;
		            responsePromise = this.connection.send('script.callFunction', {
		                functionDeclaration,
		                arguments: await Promise.all(args.map(arg => {
		                    return Serializer_js_1.BidiSerializer.serialize(sandbox, arg);
		                })),
		                target: this.target,
		                resultOwnership,
		                awaitPromise: true,
		                userActivation: true,
		                serializationOptions,
		            });
		        }
		        const { result } = await responsePromise;
		        if ('type' in result && result.type === 'exception') {
		            throw (0, utils_js_1.createEvaluationError)(result.exceptionDetails);
		        }
		        return returnByValue
		            ? Serializer_js_1.BidiSerializer.deserialize(result.result)
		            : createBidiHandle(sandbox, result.result);
		    }
		    [Symbol.dispose]() {
		        this.connection.off(Bidi.ChromiumBidi.Script.EventNames.RealmCreated, this.handleRealmCreated);
		        this.connection.off(Bidi.ChromiumBidi.Script.EventNames.RealmDestroyed, this.handleRealmDestroyed);
		    }
		}
		exports.Realm = Realm;
		/**
		 * @internal
		 */
		function createBidiHandle(sandbox, result) {
		    if (result.type === 'node' || result.type === 'window') {
		        return new ElementHandle_js_1.BidiElementHandle(sandbox, result);
		    }
		    return new JSHandle_js_1.BidiJSHandle(sandbox, result);
		}
		exports.createBidiHandle = createBidiHandle;
		
	} (Realm));
	return Realm;
}

var hasRequiredBrowsingContext;

function requireBrowsingContext () {
	if (hasRequiredBrowsingContext) return BrowsingContext;
	hasRequiredBrowsingContext = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.getWaitUntilSingle = exports.BrowsingContext = exports.BrowsingContextEmittedEvents = exports.CDPSessionWrapper = exports.cdpSessions = exports.lifeCycleToSubscribedEvent = void 0;
		const assert_js_1 = assert$1;
		const Deferred_js_1 = Deferred$1;
		const Connection_js_1 = Connection$1;
		const Errors_js_1 = Errors;
		const util_js_1 = requireUtil();
		const Realm_js_1 = requireRealm();
		const utils_js_1 = requireUtils();
		/**
		 * @internal
		 */
		exports.lifeCycleToSubscribedEvent = new Map([
		    ['load', 'browsingContext.load'],
		    ['domcontentloaded', 'browsingContext.domContentLoaded'],
		]);
		/**
		 * @internal
		 */
		const lifeCycleToReadinessState = new Map([
		    ['load', "complete" /* Bidi.BrowsingContext.ReadinessState.Complete */],
		    ['domcontentloaded', "interactive" /* Bidi.BrowsingContext.ReadinessState.Interactive */],
		]);
		/**
		 * @internal
		 */
		exports.cdpSessions = new Map();
		/**
		 * @internal
		 */
		class CDPSessionWrapper extends Connection_js_1.CDPSession {
		    #context;
		    #sessionId = Deferred_js_1.Deferred.create();
		    #detached = false;
		    constructor(context, sessionId) {
		        super();
		        this.#context = context;
		        if (!this.#context.supportsCDP()) {
		            return;
		        }
		        if (sessionId) {
		            this.#sessionId.resolve(sessionId);
		            exports.cdpSessions.set(sessionId, this);
		        }
		        else {
		            context.connection
		                .send('cdp.getSession', {
		                context: context.id,
		            })
		                .then(session => {
		                this.#sessionId.resolve(session.result.session);
		                exports.cdpSessions.set(session.result.session, this);
		            })
		                .catch(err => {
		                this.#sessionId.reject(err);
		            });
		        }
		    }
		    connection() {
		        return undefined;
		    }
		    async send(method, ...paramArgs) {
		        if (!this.#context.supportsCDP()) {
		            throw new Error('CDP support is required for this feature. The current browser does not support CDP.');
		        }
		        if (this.#detached) {
		            throw new Errors_js_1.TargetCloseError(`Protocol error (${method}): Session closed. Most likely the page has been closed.`);
		        }
		        const session = await this.#sessionId.valueOrThrow();
		        const { result } = await this.#context.connection.send('cdp.sendCommand', {
		            method: method,
		            params: paramArgs[0],
		            session,
		        });
		        return result.result;
		    }
		    async detach() {
		        exports.cdpSessions.delete(this.id());
		        if (!this.#detached && this.#context.supportsCDP()) {
		            await this.#context.cdpSession.send('Target.detachFromTarget', {
		                sessionId: this.id(),
		            });
		        }
		        this.#detached = true;
		    }
		    id() {
		        const val = this.#sessionId.value();
		        return val instanceof Error || val === undefined ? '' : val;
		    }
		}
		exports.CDPSessionWrapper = CDPSessionWrapper;
		/**
		 * Internal events that the BrowsingContext class emits.
		 *
		 * @internal
		 */
		exports.BrowsingContextEmittedEvents = {
		    /**
		     * Emitted on the top-level context, when a descendant context is created.
		     */
		    Created: Symbol('BrowsingContext.created'),
		    /**
		     * Emitted on the top-level context, when a descendant context or the
		     * top-level context itself is destroyed.
		     */
		    Destroyed: Symbol('BrowsingContext.destroyed'),
		};
		/**
		 * @internal
		 */
		class BrowsingContext extends Realm_js_1.Realm {
		    #id;
		    #url;
		    #cdpSession;
		    #parent;
		    #browserName = '';
		    constructor(connection, info, browserName) {
		        super(connection);
		        this.#id = info.context;
		        this.#url = info.url;
		        this.#parent = info.parent;
		        this.#browserName = browserName;
		        this.#cdpSession = new CDPSessionWrapper(this, undefined);
		        this.on('browsingContext.domContentLoaded', this.#updateUrl.bind(this));
		        this.on('browsingContext.fragmentNavigated', this.#updateUrl.bind(this));
		        this.on('browsingContext.load', this.#updateUrl.bind(this));
		    }
		    supportsCDP() {
		        return !this.#browserName.toLowerCase().includes('firefox');
		    }
		    #updateUrl(info) {
		        this.#url = info.url;
		    }
		    createRealmForSandbox() {
		        return new Realm_js_1.Realm(this.connection);
		    }
		    get url() {
		        return this.#url;
		    }
		    get id() {
		        return this.#id;
		    }
		    get parent() {
		        return this.#parent;
		    }
		    get cdpSession() {
		        return this.#cdpSession;
		    }
		    async goto(url, options) {
		        const { waitUntil = 'load', timeout } = options;
		        const readinessState = lifeCycleToReadinessState.get(getWaitUntilSingle(waitUntil));
		        try {
		            const { result } = await (0, util_js_1.waitWithTimeout)(this.connection.send('browsingContext.navigate', {
		                url: url,
		                context: this.#id,
		                wait: readinessState,
		            }), 'Navigation', timeout);
		            this.#url = result.url;
		            return result.navigation;
		        }
		        catch (error) {
		            if (error instanceof Errors_js_1.ProtocolError) {
		                error.message += ` at ${url}`;
		            }
		            else if (error instanceof Errors_js_1.TimeoutError) {
		                error.message = 'Navigation timeout of ' + timeout + ' ms exceeded';
		            }
		            throw error;
		        }
		    }
		    async reload(options) {
		        const { waitUntil = 'load', timeout } = options;
		        const readinessState = lifeCycleToReadinessState.get(getWaitUntilSingle(waitUntil));
		        await (0, util_js_1.waitWithTimeout)(this.connection.send('browsingContext.reload', {
		            context: this.#id,
		            wait: readinessState,
		        }), 'Navigation', timeout);
		    }
		    async setContent(html, options) {
		        const { waitUntil = 'load', timeout } = options;
		        const waitUntilEvent = exports.lifeCycleToSubscribedEvent.get(getWaitUntilSingle(waitUntil));
		        await Promise.all([
		            (0, util_js_1.setPageContent)(this, html),
		            (0, util_js_1.waitWithTimeout)(new Promise(resolve => {
		                this.once(waitUntilEvent, () => {
		                    resolve();
		                });
		            }), waitUntilEvent, timeout),
		        ]);
		    }
		    async sendCDPCommand(method, ...paramArgs) {
		        return await this.#cdpSession.send(method, ...paramArgs);
		    }
		    title() {
		        return this.evaluate(() => {
		            return document.title;
		        });
		    }
		    dispose() {
		        this.removeAllListeners();
		        this.connection.unregisterBrowsingContexts(this.#id);
		        void this.#cdpSession.detach().catch(utils_js_1.debugError);
		    }
		}
		exports.BrowsingContext = BrowsingContext;
		/**
		 * @internal
		 */
		function getWaitUntilSingle(event) {
		    if (Array.isArray(event) && event.length > 1) {
		        throw new Error('BiDi support only single `waitUntil` argument');
		    }
		    const waitUntilSingle = Array.isArray(event)
		        ? event.find(lifecycle => {
		            return lifecycle === 'domcontentloaded' || lifecycle === 'load';
		        })
		        : event;
		    if (waitUntilSingle === 'networkidle0' ||
		        waitUntilSingle === 'networkidle2') {
		        throw new Error(`BiDi does not support 'waitUntil' ${waitUntilSingle}`);
		    }
		    (0, assert_js_1.assert)(waitUntilSingle, `Invalid waitUntil option ${waitUntilSingle}`);
		    return waitUntilSingle;
		}
		exports.getWaitUntilSingle = getWaitUntilSingle;
		
	} (BrowsingContext));
	return BrowsingContext;
}

var hasRequiredConnection;

function requireConnection () {
	if (hasRequiredConnection) return Connection;
	hasRequiredConnection = 1;
	/**
	 * Copyright 2017 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(Connection, "__esModule", { value: true });
	Connection.Connection = void 0;
	const Connection_js_1 = Connection$1;
	const Debug_js_1 = Debug;
	const EventEmitter_js_1 = EventEmitter$1;
	const BrowsingContext_js_1 = requireBrowsingContext();
	const utils_js_1 = requireUtils();
	const debugProtocolSend = (0, Debug_js_1.debug)('puppeteer:webDriverBiDi:SEND ►');
	const debugProtocolReceive = (0, Debug_js_1.debug)('puppeteer:webDriverBiDi:RECV ◀');
	/**
	 * @internal
	 */
	let Connection$2 = class Connection extends EventEmitter_js_1.EventEmitter {
	    #url;
	    #transport;
	    #delay;
	    #timeout = 0;
	    #closed = false;
	    #callbacks = new Connection_js_1.CallbackRegistry();
	    #browsingContexts = new Map();
	    constructor(url, transport, delay = 0, timeout) {
	        super();
	        this.#url = url;
	        this.#delay = delay;
	        this.#timeout = timeout ?? 180000;
	        this.#transport = transport;
	        this.#transport.onmessage = this.onMessage.bind(this);
	        this.#transport.onclose = this.#onClose.bind(this);
	    }
	    get closed() {
	        return this.#closed;
	    }
	    get url() {
	        return this.#url;
	    }
	    send(method, params) {
	        return this.#callbacks.create(method, this.#timeout, id => {
	            const stringifiedMessage = JSON.stringify({
	                id,
	                method,
	                params,
	            });
	            debugProtocolSend(stringifiedMessage);
	            this.#transport.send(stringifiedMessage);
	        });
	    }
	    /**
	     * @internal
	     */
	    async onMessage(message) {
	        if (this.#delay) {
	            await new Promise(f => {
	                return setTimeout(f, this.#delay);
	            });
	        }
	        debugProtocolReceive(message);
	        const object = JSON.parse(message);
	        if ('id' in object && object.id) {
	            if ('error' in object) {
	                this.#callbacks.reject(object.id, createProtocolError(object), object.message);
	            }
	            else {
	                this.#callbacks.resolve(object.id, object);
	            }
	        }
	        else {
	            if ('error' in object || 'id' in object || 'launched' in object) {
	                (0, utils_js_1.debugError)(object);
	            }
	            else {
	                this.#maybeEmitOnContext(object);
	                this.emit(object.method, object.params);
	            }
	        }
	    }
	    #maybeEmitOnContext(event) {
	        let context;
	        // Context specific events
	        if ('context' in event.params && event.params.context) {
	            context = this.#browsingContexts.get(event.params.context);
	            // `log.entryAdded` specific context
	        }
	        else if ('source' in event.params && event.params.source.context) {
	            context = this.#browsingContexts.get(event.params.source.context);
	        }
	        else if (isCDPEvent(event)) {
	            BrowsingContext_js_1.cdpSessions
	                .get(event.params.session)
	                ?.emit(event.params.event, event.params.params);
	        }
	        context?.emit(event.method, event.params);
	    }
	    registerBrowsingContexts(context) {
	        this.#browsingContexts.set(context.id, context);
	    }
	    getBrowsingContext(contextId) {
	        const currentContext = this.#browsingContexts.get(contextId);
	        if (!currentContext) {
	            throw new Error(`BrowsingContext ${contextId} does not exist.`);
	        }
	        return currentContext;
	    }
	    getTopLevelContext(contextId) {
	        let currentContext = this.#browsingContexts.get(contextId);
	        if (!currentContext) {
	            throw new Error(`BrowsingContext ${contextId} does not exist.`);
	        }
	        while (currentContext.parent) {
	            contextId = currentContext.parent;
	            currentContext = this.#browsingContexts.get(contextId);
	            if (!currentContext) {
	                throw new Error(`BrowsingContext ${contextId} does not exist.`);
	            }
	        }
	        return currentContext;
	    }
	    unregisterBrowsingContexts(id) {
	        this.#browsingContexts.delete(id);
	    }
	    #onClose() {
	        if (this.#closed) {
	            return;
	        }
	        this.#closed = true;
	        this.#transport.onmessage = undefined;
	        this.#transport.onclose = undefined;
	        this.#callbacks.clear();
	    }
	    dispose() {
	        this.#onClose();
	        this.#transport.close();
	    }
	};
	Connection.Connection = Connection$2;
	/**
	 * @internal
	 */
	function createProtocolError(object) {
	    let message = `${object.error} ${object.message}`;
	    if (object.stacktrace) {
	        message += ` ${object.stacktrace}`;
	    }
	    return message;
	}
	function isCDPEvent(event) {
	    return event.method.startsWith('cdp.');
	}
	
	return Connection;
}

var hasRequiredBidiOverCDP;

function requireBidiOverCDP () {
	if (hasRequiredBidiOverCDP) return BidiOverCDP;
	hasRequiredBidiOverCDP = 1;
	/**
	 * Copyright 2023 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(BidiOverCDP, "__esModule", { value: true });
	BidiOverCDP.connectBidiOverCDP = void 0;
	const BidiMapper = __importStar(require$$0$3);
	const Errors_js_1 = Errors;
	const Connection_js_1 = requireConnection();
	/**
	 * @internal
	 */
	async function connectBidiOverCDP(cdp) {
	    const transportBiDi = new NoOpTransport();
	    const cdpConnectionAdapter = new CDPConnectionAdapter(cdp);
	    const pptrTransport = {
	        send(message) {
	            // Forwards a BiDi command sent by Puppeteer to the input of the BidiServer.
	            transportBiDi.emitMessage(JSON.parse(message));
	        },
	        close() {
	            bidiServer.close();
	            cdpConnectionAdapter.close();
	        },
	        onmessage(_message) {
	            // The method is overridden by the Connection.
	        },
	    };
	    transportBiDi.on('bidiResponse', (message) => {
	        // Forwards a BiDi event sent by BidiServer to Puppeteer.
	        pptrTransport.onmessage(JSON.stringify(message));
	    });
	    const pptrBiDiConnection = new Connection_js_1.Connection(cdp.url(), pptrTransport);
	    const bidiServer = await BidiMapper.BidiServer.createAndStart(transportBiDi, cdpConnectionAdapter, '');
	    return pptrBiDiConnection;
	}
	BidiOverCDP.connectBidiOverCDP = connectBidiOverCDP;
	/**
	 * Manages CDPSessions for BidiServer.
	 * @internal
	 */
	class CDPConnectionAdapter {
	    #cdp;
	    #adapters = new Map();
	    #browser;
	    constructor(cdp) {
	        this.#cdp = cdp;
	        this.#browser = new CDPClientAdapter(cdp);
	    }
	    browserClient() {
	        return this.#browser;
	    }
	    getCdpClient(id) {
	        const session = this.#cdp.session(id);
	        if (!session) {
	            throw new Error('Unknown CDP session with id' + id);
	        }
	        if (!this.#adapters.has(session)) {
	            const adapter = new CDPClientAdapter(session, id, this.#browser);
	            this.#adapters.set(session, adapter);
	            return adapter;
	        }
	        return this.#adapters.get(session);
	    }
	    close() {
	        this.#browser.close();
	        for (const adapter of this.#adapters.values()) {
	            adapter.close();
	        }
	    }
	}
	/**
	 * Wrapper on top of CDPSession/CDPConnection to satisfy CDP interface that
	 * BidiServer needs.
	 *
	 * @internal
	 */
	class CDPClientAdapter extends BidiMapper.EventEmitter {
	    #closed = false;
	    #client;
	    sessionId = undefined;
	    #browserClient;
	    constructor(client, sessionId, browserClient) {
	        super();
	        this.#client = client;
	        this.sessionId = sessionId;
	        this.#browserClient = browserClient;
	        this.#client.on('*', this.#forwardMessage);
	    }
	    browserClient() {
	        return this.#browserClient;
	    }
	    #forwardMessage = (method, event) => {
	        this.emit(method, event);
	    };
	    async sendCommand(method, ...params) {
	        if (this.#closed) {
	            return;
	        }
	        try {
	            return await this.#client.send(method, ...params);
	        }
	        catch (err) {
	            if (this.#closed) {
	                return;
	            }
	            throw err;
	        }
	    }
	    close() {
	        this.#client.off('*', this.#forwardMessage);
	        this.#closed = true;
	    }
	    isCloseError(error) {
	        return error instanceof Errors_js_1.TargetCloseError;
	    }
	}
	/**
	 * This transport is given to the BiDi server instance and allows Puppeteer
	 * to send and receive commands to the BiDiServer.
	 * @internal
	 */
	class NoOpTransport extends BidiMapper.EventEmitter {
	    #onMessage = async (_m) => {
	        return;
	    };
	    emitMessage(message) {
	        void this.#onMessage(message);
	    }
	    setOnMessage(onMessage) {
	        this.#onMessage = onMessage;
	    }
	    async sendMessage(message) {
	        this.emit('bidiResponse', message);
	    }
	    close() {
	        this.#onMessage = async (_m) => {
	            return;
	        };
	    }
	}
	
	return BidiOverCDP;
}

var Browser = {};

var BrowserContext = {};

var hasRequiredBrowserContext;

function requireBrowserContext () {
	if (hasRequiredBrowserContext) return BrowserContext;
	hasRequiredBrowserContext = 1;
	/**
	 * Copyright 2022 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(BrowserContext, "__esModule", { value: true });
	BrowserContext.BidiBrowserContext = void 0;
	const BrowserContext_js_1 = BrowserContext$2;
	/**
	 * @internal
	 */
	class BidiBrowserContext extends BrowserContext_js_1.BrowserContext {
	    #browser;
	    #connection;
	    #defaultViewport;
	    #isDefault = false;
	    constructor(browser, options) {
	        super();
	        this.#browser = browser;
	        this.#connection = this.#browser.connection;
	        this.#defaultViewport = options.defaultViewport;
	        this.#isDefault = options.isDefault;
	    }
	    targets() {
	        return this.#browser.targets().filter(target => {
	            return target.browserContext() === this;
	        });
	    }
	    waitForTarget(predicate, options = {}) {
	        return this.#browser.waitForTarget(target => {
	            return target.browserContext() === this && predicate(target);
	        }, options);
	    }
	    get connection() {
	        return this.#connection;
	    }
	    async newPage() {
	        const { result } = await this.#connection.send('browsingContext.create', {
	            type: "tab" /* Bidi.BrowsingContext.CreateType.Tab */,
	        });
	        const target = this.#browser._getTargetById(result.context);
	        // TODO: once BiDi has some concept matching BrowserContext, the newly
	        // created contexts should get automatically assigned to the right
	        // BrowserContext. For now, we assume that only explicitly created pages go
	        // to the current BrowserContext. Otherwise, the contexts get assigned to
	        // the default BrowserContext by the Browser.
	        target._setBrowserContext(this);
	        const page = await target.page();
	        if (!page) {
	            throw new Error('Page is not found');
	        }
	        if (this.#defaultViewport) {
	            try {
	                await page.setViewport(this.#defaultViewport);
	            }
	            catch {
	                // No support for setViewport in Firefox.
	            }
	        }
	        return page;
	    }
	    async close() {
	        if (this.#isDefault) {
	            throw new Error('Default context cannot be closed!');
	        }
	        await this.#browser._closeContext(this);
	    }
	    browser() {
	        return this.#browser;
	    }
	    async pages() {
	        const results = await Promise.all([...this.targets()].map(t => {
	            return t.page();
	        }));
	        return results.filter((p) => {
	            return p !== null;
	        });
	    }
	    isIncognito() {
	        return !this.#isDefault;
	    }
	}
	BrowserContext.BidiBrowserContext = BidiBrowserContext;
	
	return BrowserContext;
}

var Target = {};

var Page = {};

var Dialog = {};

var hasRequiredDialog;

function requireDialog () {
	if (hasRequiredDialog) return Dialog;
	hasRequiredDialog = 1;
	/**
	 * Copyright 2017 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(Dialog, "__esModule", { value: true });
	Dialog.BidiDialog = void 0;
	const Dialog_js_1 = Dialog$3;
	/**
	 * @internal
	 */
	class BidiDialog extends Dialog_js_1.Dialog {
	    #context;
	    /**
	     * @internal
	     */
	    constructor(context, type, message, defaultValue) {
	        super(type, message, defaultValue);
	        this.#context = context;
	    }
	    /**
	     * @internal
	     */
	    async sendCommand(options) {
	        await this.#context.connection.send('browsingContext.handleUserPrompt', {
	            context: this.#context.id,
	            accept: options.accept,
	            userText: options.text,
	        });
	    }
	}
	Dialog.BidiDialog = BidiDialog;
	
	return Dialog;
}

var EmulationManager = {};

var hasRequiredEmulationManager;

function requireEmulationManager () {
	if (hasRequiredEmulationManager) return EmulationManager;
	hasRequiredEmulationManager = 1;
	/**
	 * Copyright 2023 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(EmulationManager, "__esModule", { value: true });
	EmulationManager.EmulationManager = void 0;
	/**
	 * @internal
	 */
	let EmulationManager$1 = class EmulationManager {
	    #browsingContext;
	    constructor(browsingContext) {
	        this.#browsingContext = browsingContext;
	    }
	    async emulateViewport(viewport) {
	        await this.#browsingContext.connection.send('browsingContext.setViewport', {
	            context: this.#browsingContext.id,
	            viewport,
	        });
	    }
	};
	EmulationManager.EmulationManager = EmulationManager$1;
	
	return EmulationManager;
}

var Frame = {};

var ExposedFunction = {};

var hasRequiredExposedFunction;

function requireExposedFunction () {
	if (hasRequiredExposedFunction) return ExposedFunction;
	hasRequiredExposedFunction = 1;
	/**
	 * Copyright 2023 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(ExposedFunction, "__esModule", { value: true });
	ExposedFunction.ExposeableFunction = void 0;
	const Bidi = __importStar(require$$0$2);
	const assert_js_1 = assert$1;
	const Deferred_js_1 = Deferred$1;
	const Function_js_1 = _Function;
	const Serializer_js_1 = requireSerializer();
	const utils_js_1 = requireUtils();
	class ExposeableFunction {
	    #frame;
	    name;
	    #apply;
	    #channels;
	    #callerInfos = new Map();
	    constructor(frame, name, apply) {
	        this.#frame = frame;
	        this.name = name;
	        this.#apply = apply;
	        this.#channels = {
	            args: `__puppeteer__${this.#frame._id}_page_exposeFunction_${this.name}_args`,
	            resolve: `__puppeteer__${this.#frame._id}_page_exposeFunction_${this.name}_resolve`,
	            reject: `__puppeteer__${this.#frame._id}_page_exposeFunction_${this.name}_reject`,
	        };
	    }
	    async expose() {
	        const connection = this.#connection;
	        const channelArguments = this.#channelArguments;
	        const { name } = this;
	        // TODO(jrandolf): Implement cleanup with removePreloadScript.
	        connection.on(Bidi.ChromiumBidi.Script.EventNames.Message, this.#handleArgumentsMessage);
	        connection.on(Bidi.ChromiumBidi.Script.EventNames.Message, this.#handleResolveMessage);
	        connection.on(Bidi.ChromiumBidi.Script.EventNames.Message, this.#handleRejectMessage);
	        const functionDeclaration = (0, Function_js_1.stringifyFunction)((0, Function_js_1.interpolateFunction)((sendArgs, sendResolve, sendReject) => {
	            let id = 0;
	            Object.assign(globalThis, {
	                [PLACEHOLDER('name')]: function (...args) {
	                    return new Promise((resolve, reject) => {
	                        sendArgs([id, args]);
	                        sendResolve([id, resolve]);
	                        sendReject([id, reject]);
	                        ++id;
	                    });
	                },
	            });
	        }, { name: JSON.stringify(name) }));
	        await connection.send('script.addPreloadScript', {
	            functionDeclaration,
	            arguments: channelArguments,
	        });
	        await connection.send('script.callFunction', {
	            functionDeclaration,
	            arguments: channelArguments,
	            awaitPromise: false,
	            target: this.#frame.mainRealm().realm.target,
	        });
	    }
	    #handleArgumentsMessage = async (params) => {
	        if (params.channel !== this.#channels.args) {
	            return;
	        }
	        const connection = this.#connection;
	        const { callbacks, remoteValue } = this.#getCallbacksAndRemoteValue(params);
	        const args = remoteValue.value?.[1];
	        (0, assert_js_1.assert)(args);
	        try {
	            const result = await this.#apply(...Serializer_js_1.BidiSerializer.deserialize(args));
	            await connection.send('script.callFunction', {
	                functionDeclaration: (0, Function_js_1.stringifyFunction)(([_, resolve], result) => {
	                    resolve(result);
	                }),
	                arguments: [
	                    (await callbacks.resolve.valueOrThrow()),
	                    Serializer_js_1.BidiSerializer.serializeRemoteValue(result),
	                ],
	                awaitPromise: false,
	                target: params.source,
	            });
	        }
	        catch (error) {
	            try {
	                if (error instanceof Error) {
	                    await connection.send('script.callFunction', {
	                        functionDeclaration: (0, Function_js_1.stringifyFunction)(([_, reject], name, message, stack) => {
	                            const error = new Error(message);
	                            error.name = name;
	                            if (stack) {
	                                error.stack = stack;
	                            }
	                            reject(error);
	                        }),
	                        arguments: [
	                            (await callbacks.reject.valueOrThrow()),
	                            Serializer_js_1.BidiSerializer.serializeRemoteValue(error.name),
	                            Serializer_js_1.BidiSerializer.serializeRemoteValue(error.message),
	                            Serializer_js_1.BidiSerializer.serializeRemoteValue(error.stack),
	                        ],
	                        awaitPromise: false,
	                        target: params.source,
	                    });
	                }
	                else {
	                    await connection.send('script.callFunction', {
	                        functionDeclaration: (0, Function_js_1.stringifyFunction)(([_, reject], error) => {
	                            reject(error);
	                        }),
	                        arguments: [
	                            (await callbacks.reject.valueOrThrow()),
	                            Serializer_js_1.BidiSerializer.serializeRemoteValue(error),
	                        ],
	                        awaitPromise: false,
	                        target: params.source,
	                    });
	                }
	            }
	            catch (error) {
	                (0, utils_js_1.debugError)(error);
	            }
	        }
	    };
	    get #connection() {
	        return this.#frame.context().connection;
	    }
	    get #channelArguments() {
	        return [
	            {
	                type: 'channel',
	                value: {
	                    channel: this.#channels.args,
	                    ownership: "root" /* Bidi.Script.ResultOwnership.Root */,
	                },
	            },
	            {
	                type: 'channel',
	                value: {
	                    channel: this.#channels.resolve,
	                    ownership: "root" /* Bidi.Script.ResultOwnership.Root */,
	                },
	            },
	            {
	                type: 'channel',
	                value: {
	                    channel: this.#channels.reject,
	                    ownership: "root" /* Bidi.Script.ResultOwnership.Root */,
	                },
	            },
	        ];
	    }
	    #handleResolveMessage = (params) => {
	        if (params.channel !== this.#channels.resolve) {
	            return;
	        }
	        const { callbacks, remoteValue } = this.#getCallbacksAndRemoteValue(params);
	        callbacks.resolve.resolve(remoteValue);
	    };
	    #handleRejectMessage = (params) => {
	        if (params.channel !== this.#channels.reject) {
	            return;
	        }
	        const { callbacks, remoteValue } = this.#getCallbacksAndRemoteValue(params);
	        callbacks.reject.resolve(remoteValue);
	    };
	    #getCallbacksAndRemoteValue(params) {
	        const { data, source } = params;
	        (0, assert_js_1.assert)(data.type === 'array');
	        (0, assert_js_1.assert)(data.value);
	        const callerIdRemote = data.value[0];
	        (0, assert_js_1.assert)(callerIdRemote);
	        (0, assert_js_1.assert)(callerIdRemote.type === 'number');
	        (0, assert_js_1.assert)(typeof callerIdRemote.value === 'number');
	        let bindingMap = this.#callerInfos.get(source.realm);
	        if (!bindingMap) {
	            bindingMap = new Map();
	            this.#callerInfos.set(source.realm, bindingMap);
	        }
	        const callerId = callerIdRemote.value;
	        let callbacks = bindingMap.get(callerId);
	        if (!callbacks) {
	            callbacks = {
	                resolve: new Deferred_js_1.Deferred(),
	                reject: new Deferred_js_1.Deferred(),
	            };
	            bindingMap.set(callerId, callbacks);
	        }
	        return { callbacks, remoteValue: data };
	    }
	}
	ExposedFunction.ExposeableFunction = ExposeableFunction;
	
	return ExposedFunction;
}

var Sandbox = {};

var hasRequiredSandbox;

function requireSandbox () {
	if (hasRequiredSandbox) return Sandbox;
	hasRequiredSandbox = 1;
	/**
	 * Copyright 2023 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(Sandbox, "__esModule", { value: true });
	Sandbox.Sandbox = Sandbox.PUPPETEER_SANDBOX = Sandbox.MAIN_SANDBOX = void 0;
	const Realm_js_1 = Realm$2;
	const util_js_1 = requireUtil();
	/**
	 * A unique key for {@link SandboxChart} to denote the default world.
	 * Realms are automatically created in the default sandbox.
	 *
	 * @internal
	 */
	Sandbox.MAIN_SANDBOX = Symbol('mainSandbox');
	/**
	 * A unique key for {@link SandboxChart} to denote the puppeteer sandbox.
	 * This world contains all puppeteer-internal bindings/code.
	 *
	 * @internal
	 */
	Sandbox.PUPPETEER_SANDBOX = Symbol('puppeteerSandbox');
	/**
	 * @internal
	 */
	let Sandbox$1 = class Sandbox extends Realm_js_1.Realm {
	    name;
	    realm;
	    #frame;
	    constructor(name, frame, 
	    // TODO: We should split the Realm and BrowsingContext
	    realm, timeoutSettings) {
	        super(timeoutSettings);
	        this.name = name;
	        this.realm = realm;
	        this.#frame = frame;
	        this.realm.setSandbox(this);
	    }
	    get environment() {
	        return this.#frame;
	    }
	    async evaluateHandle(pageFunction, ...args) {
	        pageFunction = (0, util_js_1.withSourcePuppeteerURLIfNone)(this.evaluateHandle.name, pageFunction);
	        return await this.realm.evaluateHandle(pageFunction, ...args);
	    }
	    async evaluate(pageFunction, ...args) {
	        pageFunction = (0, util_js_1.withSourcePuppeteerURLIfNone)(this.evaluate.name, pageFunction);
	        return await this.realm.evaluate(pageFunction, ...args);
	    }
	    async adoptHandle(handle) {
	        return (await this.evaluateHandle(node => {
	            return node;
	        }, handle));
	    }
	    async transferHandle(handle) {
	        if (handle.realm === this) {
	            return handle;
	        }
	        const transferredHandle = await this.evaluateHandle(node => {
	            return node;
	        }, handle);
	        await handle.dispose();
	        return transferredHandle;
	    }
	};
	Sandbox.Sandbox = Sandbox$1;
	
	return Sandbox;
}

var hasRequiredFrame;

function requireFrame () {
	if (hasRequiredFrame) return Frame;
	hasRequiredFrame = 1;
	/**
	 * Copyright 2023 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __runInitializers = (commonjsGlobal && commonjsGlobal.__runInitializers) || function (thisArg, initializers, value) {
	    var useValue = arguments.length > 2;
	    for (var i = 0; i < initializers.length; i++) {
	        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
	    }
	    return useValue ? value : void 0;
	};
	var __esDecorate = (commonjsGlobal && commonjsGlobal.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
	    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
	    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
	    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
	    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
	    var _, done = false;
	    for (var i = decorators.length - 1; i >= 0; i--) {
	        var context = {};
	        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
	        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
	        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
	        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
	        if (kind === "accessor") {
	            if (result === void 0) continue;
	            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
	            if (_ = accept(result.get)) descriptor.get = _;
	            if (_ = accept(result.set)) descriptor.set = _;
	            if (_ = accept(result.init)) initializers.unshift(_);
	        }
	        else if (_ = accept(result)) {
	            if (kind === "field") initializers.unshift(_);
	            else descriptor[key] = _;
	        }
	    }
	    if (target) Object.defineProperty(target, contextIn.name, descriptor);
	    done = true;
	};
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(Frame, "__esModule", { value: true });
	Frame.BidiFrame = void 0;
	const Bidi = __importStar(require$$0$2);
	const Frame_js_1 = Frame$2;
	const Deferred_js_1 = Deferred$1;
	const FrameManager_js_1 = requireFrameManager();
	const util_js_1 = requireUtil();
	const BrowsingContext_js_1 = requireBrowsingContext();
	const ExposedFunction_js_1 = requireExposedFunction();
	const Sandbox_js_1 = requireSandbox();
	/**
	 * Puppeteer's Frame class could be viewed as a BiDi BrowsingContext implementation
	 * @internal
	 */
	let BidiFrame = (() => {
	    let _classSuper = Frame_js_1.Frame;
	    let _instanceExtraInitializers = [];
	    let _goto_decorators;
	    let _setContent_decorators;
	    let _waitForNavigation_decorators;
	    return class BidiFrame extends _classSuper {
	        static {
	            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
	            __esDecorate(this, null, _goto_decorators, { kind: "method", name: "goto", static: false, private: false, access: { has: obj => "goto" in obj, get: obj => obj.goto }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _setContent_decorators, { kind: "method", name: "setContent", static: false, private: false, access: { has: obj => "setContent" in obj, get: obj => obj.setContent }, metadata: _metadata }, null, _instanceExtraInitializers);
	            __esDecorate(this, null, _waitForNavigation_decorators, { kind: "method", name: "waitForNavigation", static: false, private: false, access: { has: obj => "waitForNavigation" in obj, get: obj => obj.waitForNavigation }, metadata: _metadata }, null, _instanceExtraInitializers);
	            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
	        }
	        #page = (__runInitializers(this, _instanceExtraInitializers), void 0);
	        #context;
	        #timeoutSettings;
	        #abortDeferred = Deferred_js_1.Deferred.create();
	        #disposed = false;
	        sandboxes;
	        _id;
	        constructor(page, context, timeoutSettings, parentId) {
	            super();
	            this.#page = page;
	            this.#context = context;
	            this.#timeoutSettings = timeoutSettings;
	            this._id = this.#context.id;
	            this._parentId = parentId ?? undefined;
	            this.sandboxes = {
	                [Sandbox_js_1.MAIN_SANDBOX]: new Sandbox_js_1.Sandbox(undefined, this, context, timeoutSettings),
	                [Sandbox_js_1.PUPPETEER_SANDBOX]: new Sandbox_js_1.Sandbox(FrameManager_js_1.UTILITY_WORLD_NAME, this, context.createRealmForSandbox(), timeoutSettings),
	            };
	        }
	        get client() {
	            return this.context().cdpSession;
	        }
	        mainRealm() {
	            return this.sandboxes[Sandbox_js_1.MAIN_SANDBOX];
	        }
	        isolatedRealm() {
	            return this.sandboxes[Sandbox_js_1.PUPPETEER_SANDBOX];
	        }
	        page() {
	            return this.#page;
	        }
	        url() {
	            return this.#context.url;
	        }
	        parentFrame() {
	            return this.#page.frame(this._parentId ?? '');
	        }
	        childFrames() {
	            return this.#page.childFrames(this.#context.id);
	        }
	        async goto(url, options) {
	            const navigationId = await this.#context.goto(url, {
	                ...options,
	                timeout: options?.timeout ?? this.#timeoutSettings.navigationTimeout(),
	            });
	            return this.#page.getNavigationResponse(navigationId);
	        }
	        setContent(html, options) {
	            return this.#context.setContent(html, {
	                ...options,
	                timeout: options?.timeout ?? this.#timeoutSettings.navigationTimeout(),
	            });
	        }
	        context() {
	            return this.#context;
	        }
	        async waitForNavigation(options = {}) {
	            const { waitUntil = 'load', timeout = this.#timeoutSettings.navigationTimeout(), } = options;
	            const waitUntilEvent = BrowsingContext_js_1.lifeCycleToSubscribedEvent.get((0, BrowsingContext_js_1.getWaitUntilSingle)(waitUntil));
	            const [info] = await Deferred_js_1.Deferred.race([
	                // TODO(lightning00blade): Should also keep tack of
	                // navigationAborted and navigationFailed
	                Promise.all([
	                    (0, util_js_1.waitForEvent)(this.#context, waitUntilEvent, () => {
	                        return true;
	                    }, timeout, this.#abortDeferred.valueOrThrow()),
	                    (0, util_js_1.waitForEvent)(this.#context, Bidi.ChromiumBidi.BrowsingContext.EventNames.NavigationStarted, () => {
	                        return true;
	                    }, timeout, this.#abortDeferred.valueOrThrow()),
	                ]),
	                (0, util_js_1.waitForEvent)(this.#context, Bidi.ChromiumBidi.BrowsingContext.EventNames.FragmentNavigated, () => {
	                    return true;
	                }, timeout, this.#abortDeferred.valueOrThrow()).then(info => {
	                    return [info, undefined];
	                }),
	            ]);
	            return this.#page.getNavigationResponse(info.navigation);
	        }
	        get detached() {
	            return this.#disposed;
	        }
	        [(_goto_decorators = [Frame_js_1.throwIfDetached], _setContent_decorators = [Frame_js_1.throwIfDetached], _waitForNavigation_decorators = [Frame_js_1.throwIfDetached], Symbol.dispose)]() {
	            if (this.#disposed) {
	                return;
	            }
	            this.#disposed = true;
	            this.#abortDeferred.reject(new Error('Frame detached'));
	            this.#context.dispose();
	            this.sandboxes[Sandbox_js_1.MAIN_SANDBOX][Symbol.dispose]();
	            this.sandboxes[Sandbox_js_1.PUPPETEER_SANDBOX][Symbol.dispose]();
	        }
	        #exposedFunctions = new Map();
	        async exposeFunction(name, apply) {
	            if (this.#exposedFunctions.has(name)) {
	                throw new Error(`Failed to add page binding with name ${name}: globalThis['${name}'] already exists!`);
	            }
	            const exposeable = new ExposedFunction_js_1.ExposeableFunction(this, name, apply);
	            this.#exposedFunctions.set(name, exposeable);
	            try {
	                await exposeable.expose();
	            }
	            catch (error) {
	                this.#exposedFunctions.delete(name);
	                throw error;
	            }
	        }
	    };
	})();
	Frame.BidiFrame = BidiFrame;
	
	return Frame;
}

var Input = {};

var hasRequiredInput;

function requireInput () {
	if (hasRequiredInput) return Input;
	hasRequiredInput = 1;
	/**
	 * Copyright 2017 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the 'License');
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an 'AS IS' BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(Input, "__esModule", { value: true });
	Input.Touchscreen = Input.Mouse = Input.Keyboard = void 0;
	const Input_js_1 = Input$2;
	var SourceActionsType;
	(function (SourceActionsType) {
	    SourceActionsType["None"] = "none";
	    SourceActionsType["Key"] = "key";
	    SourceActionsType["Pointer"] = "pointer";
	    SourceActionsType["Wheel"] = "wheel";
	})(SourceActionsType || (SourceActionsType = {}));
	var ActionType;
	(function (ActionType) {
	    ActionType["Pause"] = "pause";
	    ActionType["KeyDown"] = "keyDown";
	    ActionType["KeyUp"] = "keyUp";
	    ActionType["PointerUp"] = "pointerUp";
	    ActionType["PointerDown"] = "pointerDown";
	    ActionType["PointerMove"] = "pointerMove";
	    ActionType["Scroll"] = "scroll";
	})(ActionType || (ActionType = {}));
	const getBidiKeyValue = (key) => {
	    switch (key) {
	        case '\r':
	        case '\n':
	            key = 'Enter';
	            break;
	    }
	    // Measures the number of code points rather than UTF-16 code units.
	    if ([...key].length === 1) {
	        return key;
	    }
	    switch (key) {
	        case 'Cancel':
	            return '\uE001';
	        case 'Help':
	            return '\uE002';
	        case 'Backspace':
	            return '\uE003';
	        case 'Tab':
	            return '\uE004';
	        case 'Clear':
	            return '\uE005';
	        case 'Enter':
	            return '\uE007';
	        case 'Shift':
	        case 'ShiftLeft':
	            return '\uE008';
	        case 'Control':
	        case 'ControlLeft':
	            return '\uE009';
	        case 'Alt':
	        case 'AltLeft':
	            return '\uE00A';
	        case 'Pause':
	            return '\uE00B';
	        case 'Escape':
	            return '\uE00C';
	        case 'PageUp':
	            return '\uE00E';
	        case 'PageDown':
	            return '\uE00F';
	        case 'End':
	            return '\uE010';
	        case 'Home':
	            return '\uE011';
	        case 'ArrowLeft':
	            return '\uE012';
	        case 'ArrowUp':
	            return '\uE013';
	        case 'ArrowRight':
	            return '\uE014';
	        case 'ArrowDown':
	            return '\uE015';
	        case 'Insert':
	            return '\uE016';
	        case 'Delete':
	            return '\uE017';
	        case 'NumpadEqual':
	            return '\uE019';
	        case 'Numpad0':
	            return '\uE01A';
	        case 'Numpad1':
	            return '\uE01B';
	        case 'Numpad2':
	            return '\uE01C';
	        case 'Numpad3':
	            return '\uE01D';
	        case 'Numpad4':
	            return '\uE01E';
	        case 'Numpad5':
	            return '\uE01F';
	        case 'Numpad6':
	            return '\uE020';
	        case 'Numpad7':
	            return '\uE021';
	        case 'Numpad8':
	            return '\uE022';
	        case 'Numpad9':
	            return '\uE023';
	        case 'NumpadMultiply':
	            return '\uE024';
	        case 'NumpadAdd':
	            return '\uE025';
	        case 'NumpadSubtract':
	            return '\uE027';
	        case 'NumpadDecimal':
	            return '\uE028';
	        case 'NumpadDivide':
	            return '\uE029';
	        case 'F1':
	            return '\uE031';
	        case 'F2':
	            return '\uE032';
	        case 'F3':
	            return '\uE033';
	        case 'F4':
	            return '\uE034';
	        case 'F5':
	            return '\uE035';
	        case 'F6':
	            return '\uE036';
	        case 'F7':
	            return '\uE037';
	        case 'F8':
	            return '\uE038';
	        case 'F9':
	            return '\uE039';
	        case 'F10':
	            return '\uE03A';
	        case 'F11':
	            return '\uE03B';
	        case 'F12':
	            return '\uE03C';
	        case 'Meta':
	        case 'MetaLeft':
	            return '\uE03D';
	        case 'ShiftRight':
	            return '\uE050';
	        case 'ControlRight':
	            return '\uE051';
	        case 'AltRight':
	            return '\uE052';
	        case 'MetaRight':
	            return '\uE053';
	        case 'Digit0':
	            return '0';
	        case 'Digit1':
	            return '1';
	        case 'Digit2':
	            return '2';
	        case 'Digit3':
	            return '3';
	        case 'Digit4':
	            return '4';
	        case 'Digit5':
	            return '5';
	        case 'Digit6':
	            return '6';
	        case 'Digit7':
	            return '7';
	        case 'Digit8':
	            return '8';
	        case 'Digit9':
	            return '9';
	        case 'KeyA':
	            return 'a';
	        case 'KeyB':
	            return 'b';
	        case 'KeyC':
	            return 'c';
	        case 'KeyD':
	            return 'd';
	        case 'KeyE':
	            return 'e';
	        case 'KeyF':
	            return 'f';
	        case 'KeyG':
	            return 'g';
	        case 'KeyH':
	            return 'h';
	        case 'KeyI':
	            return 'i';
	        case 'KeyJ':
	            return 'j';
	        case 'KeyK':
	            return 'k';
	        case 'KeyL':
	            return 'l';
	        case 'KeyM':
	            return 'm';
	        case 'KeyN':
	            return 'n';
	        case 'KeyO':
	            return 'o';
	        case 'KeyP':
	            return 'p';
	        case 'KeyQ':
	            return 'q';
	        case 'KeyR':
	            return 'r';
	        case 'KeyS':
	            return 's';
	        case 'KeyT':
	            return 't';
	        case 'KeyU':
	            return 'u';
	        case 'KeyV':
	            return 'v';
	        case 'KeyW':
	            return 'w';
	        case 'KeyX':
	            return 'x';
	        case 'KeyY':
	            return 'y';
	        case 'KeyZ':
	            return 'z';
	        case 'Semicolon':
	            return ';';
	        case 'Equal':
	            return '=';
	        case 'Comma':
	            return ',';
	        case 'Minus':
	            return '-';
	        case 'Period':
	            return '.';
	        case 'Slash':
	            return '/';
	        case 'Backquote':
	            return '`';
	        case 'BracketLeft':
	            return '[';
	        case 'Backslash':
	            return '\\';
	        case 'BracketRight':
	            return ']';
	        case 'Quote':
	            return '"';
	        default:
	            throw new Error(`Unknown key: "${key}"`);
	    }
	};
	/**
	 * @internal
	 */
	class Keyboard extends Input_js_1.Keyboard {
	    #context;
	    constructor(context) {
	        super();
	        this.#context = context;
	    }
	    async down(key, _options) {
	        await this.#context.connection.send('input.performActions', {
	            context: this.#context.id,
	            actions: [
	                {
	                    type: SourceActionsType.Key,
	                    id: "__puppeteer_keyboard" /* InputId.Keyboard */,
	                    actions: [
	                        {
	                            type: ActionType.KeyDown,
	                            value: getBidiKeyValue(key),
	                        },
	                    ],
	                },
	            ],
	        });
	    }
	    async up(key) {
	        await this.#context.connection.send('input.performActions', {
	            context: this.#context.id,
	            actions: [
	                {
	                    type: SourceActionsType.Key,
	                    id: "__puppeteer_keyboard" /* InputId.Keyboard */,
	                    actions: [
	                        {
	                            type: ActionType.KeyUp,
	                            value: getBidiKeyValue(key),
	                        },
	                    ],
	                },
	            ],
	        });
	    }
	    async press(key, options = {}) {
	        const { delay = 0 } = options;
	        const actions = [
	            {
	                type: ActionType.KeyDown,
	                value: getBidiKeyValue(key),
	            },
	        ];
	        if (delay > 0) {
	            actions.push({
	                type: ActionType.Pause,
	                duration: delay,
	            });
	        }
	        actions.push({
	            type: ActionType.KeyUp,
	            value: getBidiKeyValue(key),
	        });
	        await this.#context.connection.send('input.performActions', {
	            context: this.#context.id,
	            actions: [
	                {
	                    type: SourceActionsType.Key,
	                    id: "__puppeteer_keyboard" /* InputId.Keyboard */,
	                    actions,
	                },
	            ],
	        });
	    }
	    async type(text, options = {}) {
	        const { delay = 0 } = options;
	        // This spread separates the characters into code points rather than UTF-16
	        // code units.
	        const values = [...text].map(getBidiKeyValue);
	        const actions = [];
	        if (delay <= 0) {
	            for (const value of values) {
	                actions.push({
	                    type: ActionType.KeyDown,
	                    value,
	                }, {
	                    type: ActionType.KeyUp,
	                    value,
	                });
	            }
	        }
	        else {
	            for (const value of values) {
	                actions.push({
	                    type: ActionType.KeyDown,
	                    value,
	                }, {
	                    type: ActionType.Pause,
	                    duration: delay,
	                }, {
	                    type: ActionType.KeyUp,
	                    value,
	                });
	            }
	        }
	        await this.#context.connection.send('input.performActions', {
	            context: this.#context.id,
	            actions: [
	                {
	                    type: SourceActionsType.Key,
	                    id: "__puppeteer_keyboard" /* InputId.Keyboard */,
	                    actions,
	                },
	            ],
	        });
	    }
	}
	Input.Keyboard = Keyboard;
	const getBidiButton = (button) => {
	    switch (button) {
	        case Input_js_1.MouseButton.Left:
	            return 0;
	        case Input_js_1.MouseButton.Middle:
	            return 1;
	        case Input_js_1.MouseButton.Right:
	            return 2;
	        case Input_js_1.MouseButton.Back:
	            return 3;
	        case Input_js_1.MouseButton.Forward:
	            return 4;
	    }
	};
	/**
	 * @internal
	 */
	class Mouse extends Input_js_1.Mouse {
	    #context;
	    #lastMovePoint;
	    constructor(context) {
	        super();
	        this.#context = context;
	    }
	    async reset() {
	        this.#lastMovePoint = undefined;
	        await this.#context.connection.send('input.releaseActions', {
	            context: this.#context.id,
	        });
	    }
	    async move(x, y, options = {}) {
	        // https://w3c.github.io/webdriver-bidi/#command-input-performActions:~:text=input.PointerMoveAction%20%3D%20%7B%0A%20%20type%3A%20%22pointerMove%22%2C%0A%20%20x%3A%20js%2Dint%2C
	        this.#lastMovePoint = {
	            x: Math.round(x),
	            y: Math.round(y),
	        };
	        await this.#context.connection.send('input.performActions', {
	            context: this.#context.id,
	            actions: [
	                {
	                    type: SourceActionsType.Pointer,
	                    id: "__puppeteer_mouse" /* InputId.Mouse */,
	                    actions: [
	                        {
	                            type: ActionType.PointerMove,
	                            ...this.#lastMovePoint,
	                            duration: (options.steps ?? 0) * 50,
	                            origin: options.origin,
	                        },
	                    ],
	                },
	            ],
	        });
	    }
	    async down(options = {}) {
	        await this.#context.connection.send('input.performActions', {
	            context: this.#context.id,
	            actions: [
	                {
	                    type: SourceActionsType.Pointer,
	                    id: "__puppeteer_mouse" /* InputId.Mouse */,
	                    actions: [
	                        {
	                            type: ActionType.PointerDown,
	                            button: getBidiButton(options.button ?? Input_js_1.MouseButton.Left),
	                        },
	                    ],
	                },
	            ],
	        });
	    }
	    async up(options = {}) {
	        await this.#context.connection.send('input.performActions', {
	            context: this.#context.id,
	            actions: [
	                {
	                    type: SourceActionsType.Pointer,
	                    id: "__puppeteer_mouse" /* InputId.Mouse */,
	                    actions: [
	                        {
	                            type: ActionType.PointerUp,
	                            button: getBidiButton(options.button ?? Input_js_1.MouseButton.Left),
	                        },
	                    ],
	                },
	            ],
	        });
	    }
	    async click(x, y, options = {}) {
	        const actions = [
	            {
	                type: ActionType.PointerMove,
	                x: Math.round(x),
	                y: Math.round(y),
	                origin: options.origin,
	            },
	        ];
	        const pointerDownAction = {
	            type: ActionType.PointerDown,
	            button: getBidiButton(options.button ?? Input_js_1.MouseButton.Left),
	        };
	        const pointerUpAction = {
	            type: ActionType.PointerUp,
	            button: pointerDownAction.button,
	        };
	        for (let i = 1; i < (options.count ?? 1); ++i) {
	            actions.push(pointerDownAction, pointerUpAction);
	        }
	        actions.push(pointerDownAction);
	        if (options.delay) {
	            actions.push({
	                type: ActionType.Pause,
	                duration: options.delay,
	            });
	        }
	        actions.push(pointerUpAction);
	        await this.#context.connection.send('input.performActions', {
	            context: this.#context.id,
	            actions: [
	                {
	                    type: SourceActionsType.Pointer,
	                    id: "__puppeteer_mouse" /* InputId.Mouse */,
	                    actions,
	                },
	            ],
	        });
	    }
	    async wheel(options = {}) {
	        await this.#context.connection.send('input.performActions', {
	            context: this.#context.id,
	            actions: [
	                {
	                    type: SourceActionsType.Wheel,
	                    id: "__puppeteer_wheel" /* InputId.Wheel */,
	                    actions: [
	                        {
	                            type: ActionType.Scroll,
	                            ...(this.#lastMovePoint ?? {
	                                x: 0,
	                                y: 0,
	                            }),
	                            deltaX: options.deltaX ?? 0,
	                            deltaY: options.deltaY ?? 0,
	                        },
	                    ],
	                },
	            ],
	        });
	    }
	}
	Input.Mouse = Mouse;
	/**
	 * @internal
	 */
	class Touchscreen extends Input_js_1.Touchscreen {
	    #context;
	    constructor(context) {
	        super();
	        this.#context = context;
	    }
	    async tap(x, y, options = {}) {
	        await this.touchStart(x, y, options);
	        await this.touchEnd();
	    }
	    async touchStart(x, y, options = {}) {
	        await this.#context.connection.send('input.performActions', {
	            context: this.#context.id,
	            actions: [
	                {
	                    type: SourceActionsType.Pointer,
	                    id: "__puppeteer_finger" /* InputId.Finger */,
	                    parameters: {
	                        pointerType: "touch" /* Bidi.Input.PointerType.Touch */,
	                    },
	                    actions: [
	                        {
	                            type: ActionType.PointerMove,
	                            x: Math.round(x),
	                            y: Math.round(y),
	                            origin: options.origin,
	                        },
	                        {
	                            type: ActionType.PointerDown,
	                            button: 0,
	                        },
	                    ],
	                },
	            ],
	        });
	    }
	    async touchMove(x, y, options = {}) {
	        await this.#context.connection.send('input.performActions', {
	            context: this.#context.id,
	            actions: [
	                {
	                    type: SourceActionsType.Pointer,
	                    id: "__puppeteer_finger" /* InputId.Finger */,
	                    parameters: {
	                        pointerType: "touch" /* Bidi.Input.PointerType.Touch */,
	                    },
	                    actions: [
	                        {
	                            type: ActionType.PointerMove,
	                            x: Math.round(x),
	                            y: Math.round(y),
	                            origin: options.origin,
	                        },
	                    ],
	                },
	            ],
	        });
	    }
	    async touchEnd() {
	        await this.#context.connection.send('input.performActions', {
	            context: this.#context.id,
	            actions: [
	                {
	                    type: SourceActionsType.Pointer,
	                    id: "__puppeteer_finger" /* InputId.Finger */,
	                    parameters: {
	                        pointerType: "touch" /* Bidi.Input.PointerType.Touch */,
	                    },
	                    actions: [
	                        {
	                            type: ActionType.PointerUp,
	                            button: 0,
	                        },
	                    ],
	                },
	            ],
	        });
	    }
	}
	Input.Touchscreen = Touchscreen;
	
	return Input;
}

var NetworkManager = {};

var HTTPRequest = {};

var hasRequiredHTTPRequest;

function requireHTTPRequest () {
	if (hasRequiredHTTPRequest) return HTTPRequest;
	hasRequiredHTTPRequest = 1;
	Object.defineProperty(HTTPRequest, "__esModule", { value: true });
	HTTPRequest.HTTPRequest = void 0;
	const HTTPRequest_js_1 = HTTPRequest$4;
	/**
	 * @internal
	 */
	let HTTPRequest$1 = class HTTPRequest extends HTTPRequest_js_1.HTTPRequest {
	    _response = null;
	    _redirectChain;
	    _navigationId;
	    #url;
	    #resourceType;
	    #method;
	    #postData;
	    #headers = {};
	    #initiator;
	    #frame;
	    constructor(event, frame, redirectChain = []) {
	        super();
	        this.#url = event.request.url;
	        this.#resourceType = event.initiator.type.toLowerCase();
	        this.#method = event.request.method;
	        this.#postData = undefined;
	        this.#initiator = event.initiator;
	        this.#frame = frame;
	        this._requestId = event.request.request;
	        this._redirectChain = redirectChain;
	        this._navigationId = event.navigation;
	        for (const header of event.request.headers) {
	            // TODO: How to handle Binary Headers
	            // https://w3c.github.io/webdriver-bidi/#type-network-Header
	            if (header.value.type === 'string') {
	                this.#headers[header.name.toLowerCase()] = header.value.value;
	            }
	        }
	    }
	    url() {
	        return this.#url;
	    }
	    resourceType() {
	        return this.#resourceType;
	    }
	    method() {
	        return this.#method;
	    }
	    postData() {
	        return this.#postData;
	    }
	    headers() {
	        return this.#headers;
	    }
	    response() {
	        return this._response;
	    }
	    isNavigationRequest() {
	        return Boolean(this._navigationId);
	    }
	    initiator() {
	        return this.#initiator;
	    }
	    redirectChain() {
	        return this._redirectChain.slice();
	    }
	    enqueueInterceptAction(pendingHandler) {
	        // Execute the handler when interception is not supported
	        void pendingHandler();
	    }
	    frame() {
	        return this.#frame;
	    }
	};
	HTTPRequest.HTTPRequest = HTTPRequest$1;
	
	return HTTPRequest;
}

var HTTPResponse = {};

var hasRequiredHTTPResponse;

function requireHTTPResponse () {
	if (hasRequiredHTTPResponse) return HTTPResponse;
	hasRequiredHTTPResponse = 1;
	Object.defineProperty(HTTPResponse, "__esModule", { value: true });
	HTTPResponse.HTTPResponse = void 0;
	const HTTPResponse_js_1 = HTTPResponse$4;
	/**
	 * @internal
	 */
	let HTTPResponse$1 = class HTTPResponse extends HTTPResponse_js_1.HTTPResponse {
	    #request;
	    #remoteAddress;
	    #status;
	    #statusText;
	    #url;
	    #fromCache;
	    #headers = {};
	    #timings;
	    constructor(request, { response }) {
	        super();
	        this.#request = request;
	        this.#remoteAddress = {
	            ip: '',
	            port: -1,
	        };
	        this.#url = response.url;
	        this.#fromCache = response.fromCache;
	        this.#status = response.status;
	        this.#statusText = response.statusText;
	        // TODO: File and issue with BiDi spec
	        this.#timings = null;
	        // TODO: Removed once the Firefox implementation is compliant with https://w3c.github.io/webdriver-bidi/#get-the-response-data.
	        for (const header of response.headers || []) {
	            // TODO: How to handle Binary Headers
	            // https://w3c.github.io/webdriver-bidi/#type-network-Header
	            if (header.value.type === 'string') {
	                this.#headers[header.name.toLowerCase()] = header.value.value;
	            }
	        }
	    }
	    remoteAddress() {
	        return this.#remoteAddress;
	    }
	    url() {
	        return this.#url;
	    }
	    status() {
	        return this.#status;
	    }
	    statusText() {
	        return this.#statusText;
	    }
	    headers() {
	        return this.#headers;
	    }
	    request() {
	        return this.#request;
	    }
	    fromCache() {
	        return this.#fromCache;
	    }
	    timing() {
	        return this.#timings;
	    }
	    frame() {
	        return this.#request.frame();
	    }
	    fromServiceWorker() {
	        return false;
	    }
	};
	HTTPResponse.HTTPResponse = HTTPResponse$1;
	
	return HTTPResponse;
}

var hasRequiredNetworkManager;

function requireNetworkManager () {
	if (hasRequiredNetworkManager) return NetworkManager;
	hasRequiredNetworkManager = 1;
	/**
	 * Copyright 2023 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(NetworkManager, "__esModule", { value: true });
	NetworkManager.NetworkManager = void 0;
	const EventEmitter_js_1 = EventEmitter$1;
	const NetworkManager_js_1 = NetworkManager$1;
	const HTTPRequest_js_1 = requireHTTPRequest();
	const HTTPResponse_js_1 = requireHTTPResponse();
	/**
	 * @internal
	 */
	let NetworkManager$2 = class NetworkManager extends EventEmitter_js_1.EventEmitter {
	    #connection;
	    #page;
	    #subscribedEvents = new Map([
	        ['network.beforeRequestSent', this.#onBeforeRequestSent.bind(this)],
	        ['network.responseStarted', this.#onResponseStarted.bind(this)],
	        ['network.responseCompleted', this.#onResponseCompleted.bind(this)],
	        ['network.fetchError', this.#onFetchError.bind(this)],
	    ]);
	    #requestMap = new Map();
	    #navigationMap = new Map();
	    constructor(connection, page) {
	        super();
	        this.#connection = connection;
	        this.#page = page;
	        // TODO: Subscribe to the Frame individually
	        for (const [event, subscriber] of this.#subscribedEvents) {
	            this.#connection.on(event, subscriber);
	        }
	    }
	    #onBeforeRequestSent(event) {
	        const frame = this.#page.frame(event.context ?? '');
	        if (!frame) {
	            return;
	        }
	        const request = this.#requestMap.get(event.request.request);
	        let upsertRequest;
	        if (request) {
	            const requestChain = request._redirectChain;
	            upsertRequest = new HTTPRequest_js_1.HTTPRequest(event, frame, requestChain);
	        }
	        else {
	            upsertRequest = new HTTPRequest_js_1.HTTPRequest(event, frame, []);
	        }
	        this.#requestMap.set(event.request.request, upsertRequest);
	        this.emit(NetworkManager_js_1.NetworkManagerEmittedEvents.Request, upsertRequest);
	    }
	    #onResponseStarted(_event) { }
	    #onResponseCompleted(event) {
	        const request = this.#requestMap.get(event.request.request);
	        if (!request) {
	            return;
	        }
	        const response = new HTTPResponse_js_1.HTTPResponse(request, event);
	        request._response = response;
	        if (event.navigation) {
	            this.#navigationMap.set(event.navigation, response);
	        }
	        if (response.fromCache()) {
	            this.emit(NetworkManager_js_1.NetworkManagerEmittedEvents.RequestServedFromCache, request);
	        }
	        this.emit(NetworkManager_js_1.NetworkManagerEmittedEvents.Response, response);
	        this.emit(NetworkManager_js_1.NetworkManagerEmittedEvents.RequestFinished, request);
	        this.#requestMap.delete(event.request.request);
	    }
	    #onFetchError(event) {
	        const request = this.#requestMap.get(event.request.request);
	        if (!request) {
	            return;
	        }
	        request._failureText = event.errorText;
	        this.emit(NetworkManager_js_1.NetworkManagerEmittedEvents.RequestFailed, request);
	        this.#requestMap.delete(event.request.request);
	    }
	    getNavigationResponse(navigationId) {
	        if (!navigationId) {
	            return null;
	        }
	        const response = this.#navigationMap.get(navigationId);
	        return response ?? null;
	    }
	    inFlightRequestsCount() {
	        let inFlightRequestCounter = 0;
	        for (const request of this.#requestMap.values()) {
	            if (!request.response() || request._failureText) {
	                inFlightRequestCounter++;
	            }
	        }
	        return inFlightRequestCounter;
	    }
	    clearMapAfterFrameDispose(frame) {
	        for (const [id, request] of this.#requestMap.entries()) {
	            if (request.frame() === frame) {
	                this.#requestMap.delete(id);
	            }
	        }
	        for (const [id, response] of this.#navigationMap.entries()) {
	            if (response.frame() === frame) {
	                this.#navigationMap.delete(id);
	            }
	        }
	    }
	    dispose() {
	        this.removeAllListeners();
	        this.#requestMap.clear();
	        this.#navigationMap.clear();
	        for (const [event, subscriber] of this.#subscribedEvents) {
	            this.#connection.off(event, subscriber);
	        }
	    }
	};
	NetworkManager.NetworkManager = NetworkManager$2;
	
	return NetworkManager;
}

var hasRequiredPage;

function requirePage () {
	if (hasRequiredPage) return Page;
	hasRequiredPage = 1;
	/**
	 * Copyright 2022 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(Page, "__esModule", { value: true });
	Page.BidiPage = void 0;
	const Page_js_1 = Page$2;
	const assert_js_1 = assert$1;
	const Deferred_js_1 = Deferred$1;
	const Accessibility_js_1 = Accessibility$1;
	const ConsoleMessage_js_1 = ConsoleMessage$1;
	const Coverage_js_1 = Coverage$1;
	const EmulationManager_js_1 = EmulationManager$2;
	const Errors_js_1 = Errors;
	const FrameTree_js_1 = FrameTree$1;
	const NetworkManager_js_1 = NetworkManager$1;
	const TimeoutSettings_js_1 = TimeoutSettings$1;
	const Tracing_js_1 = Tracing$1;
	const util_js_1 = requireUtil();
	const BrowsingContext_js_1 = requireBrowsingContext();
	const Dialog_js_1 = requireDialog();
	const EmulationManager_js_2 = requireEmulationManager();
	const Frame_js_1 = requireFrame();
	const Input_js_1 = requireInput();
	const NetworkManager_js_2 = requireNetworkManager();
	const Realm_js_1 = requireRealm();
	const Serializer_js_1 = requireSerializer();
	/**
	 * @internal
	 */
	class BidiPage extends Page_js_1.Page {
	    #accessibility;
	    #timeoutSettings = new TimeoutSettings_js_1.TimeoutSettings();
	    #connection;
	    #frameTree = new FrameTree_js_1.FrameTree();
	    #networkManager;
	    #viewport = null;
	    #closedDeferred = Deferred_js_1.Deferred.create();
	    #subscribedEvents = new Map([
	        ['log.entryAdded', this.#onLogEntryAdded.bind(this)],
	        ['browsingContext.load', this.#onFrameLoaded.bind(this)],
	        [
	            'browsingContext.fragmentNavigated',
	            this.#onFrameFragmentNavigated.bind(this),
	        ],
	        [
	            'browsingContext.domContentLoaded',
	            this.#onFrameDOMContentLoaded.bind(this),
	        ],
	        ['browsingContext.userPromptOpened', this.#onDialog.bind(this)],
	    ]);
	    #networkManagerEvents = new Map([
	        [
	            NetworkManager_js_1.NetworkManagerEmittedEvents.Request,
	            this.emit.bind(this, "request" /* PageEmittedEvents.Request */),
	        ],
	        [
	            NetworkManager_js_1.NetworkManagerEmittedEvents.RequestServedFromCache,
	            this.emit.bind(this, "requestservedfromcache" /* PageEmittedEvents.RequestServedFromCache */),
	        ],
	        [
	            NetworkManager_js_1.NetworkManagerEmittedEvents.RequestFailed,
	            this.emit.bind(this, "requestfailed" /* PageEmittedEvents.RequestFailed */),
	        ],
	        [
	            NetworkManager_js_1.NetworkManagerEmittedEvents.RequestFinished,
	            this.emit.bind(this, "requestfinished" /* PageEmittedEvents.RequestFinished */),
	        ],
	        [
	            NetworkManager_js_1.NetworkManagerEmittedEvents.Response,
	            this.emit.bind(this, "response" /* PageEmittedEvents.Response */),
	        ],
	    ]);
	    #browsingContextEvents = new Map([
	        [BrowsingContext_js_1.BrowsingContextEmittedEvents.Created, this.#onContextCreated.bind(this)],
	        [
	            BrowsingContext_js_1.BrowsingContextEmittedEvents.Destroyed,
	            this.#onContextDestroyed.bind(this),
	        ],
	    ]);
	    #tracing;
	    #coverage;
	    #cdpEmulationManager;
	    #emulationManager;
	    #mouse;
	    #touchscreen;
	    #keyboard;
	    #browsingContext;
	    #browserContext;
	    _client() {
	        return this.mainFrame().context().cdpSession;
	    }
	    constructor(browsingContext, browserContext) {
	        super();
	        this.#browsingContext = browsingContext;
	        this.#browserContext = browserContext;
	        this.#connection = browsingContext.connection;
	        for (const [event, subscriber] of this.#browsingContextEvents) {
	            this.#browsingContext.on(event, subscriber);
	        }
	        this.#networkManager = new NetworkManager_js_2.NetworkManager(this.#connection, this);
	        for (const [event, subscriber] of this.#subscribedEvents) {
	            this.#connection.on(event, subscriber);
	        }
	        for (const [event, subscriber] of this.#networkManagerEvents) {
	            this.#networkManager.on(event, subscriber);
	        }
	        const frame = new Frame_js_1.BidiFrame(this, this.#browsingContext, this.#timeoutSettings, this.#browsingContext.parent);
	        this.#frameTree.addFrame(frame);
	        this.emit("frameattached" /* PageEmittedEvents.FrameAttached */, frame);
	        // TODO: https://github.com/w3c/webdriver-bidi/issues/443
	        this.#accessibility = new Accessibility_js_1.Accessibility(this.mainFrame().context().cdpSession);
	        this.#tracing = new Tracing_js_1.Tracing(this.mainFrame().context().cdpSession);
	        this.#coverage = new Coverage_js_1.Coverage(this.mainFrame().context().cdpSession);
	        this.#cdpEmulationManager = new EmulationManager_js_1.EmulationManager(this.mainFrame().context().cdpSession);
	        this.#emulationManager = new EmulationManager_js_2.EmulationManager(browsingContext);
	        this.#mouse = new Input_js_1.Mouse(this.mainFrame().context());
	        this.#touchscreen = new Input_js_1.Touchscreen(this.mainFrame().context());
	        this.#keyboard = new Input_js_1.Keyboard(this.mainFrame().context());
	    }
	    _setBrowserContext(browserContext) {
	        this.#browserContext = browserContext;
	    }
	    get accessibility() {
	        return this.#accessibility;
	    }
	    get tracing() {
	        return this.#tracing;
	    }
	    get coverage() {
	        return this.#coverage;
	    }
	    get mouse() {
	        return this.#mouse;
	    }
	    get touchscreen() {
	        return this.#touchscreen;
	    }
	    get keyboard() {
	        return this.#keyboard;
	    }
	    browser() {
	        return this.browserContext().browser();
	    }
	    browserContext() {
	        return this.#browserContext;
	    }
	    mainFrame() {
	        const mainFrame = this.#frameTree.getMainFrame();
	        (0, assert_js_1.assert)(mainFrame, 'Requesting main frame too early!');
	        return mainFrame;
	    }
	    frames() {
	        return Array.from(this.#frameTree.frames());
	    }
	    frame(frameId) {
	        return this.#frameTree.getById(frameId ?? '') || null;
	    }
	    childFrames(frameId) {
	        return this.#frameTree.childFrames(frameId);
	    }
	    #onFrameLoaded(info) {
	        const frame = this.frame(info.context);
	        if (frame && this.mainFrame() === frame) {
	            this.emit("load" /* PageEmittedEvents.Load */);
	        }
	    }
	    #onFrameFragmentNavigated(info) {
	        const frame = this.frame(info.context);
	        if (frame) {
	            this.emit("framenavigated" /* PageEmittedEvents.FrameNavigated */, frame);
	        }
	    }
	    #onFrameDOMContentLoaded(info) {
	        const frame = this.frame(info.context);
	        if (frame) {
	            frame._hasStartedLoading = true;
	            if (this.mainFrame() === frame) {
	                this.emit("domcontentloaded" /* PageEmittedEvents.DOMContentLoaded */);
	            }
	            this.emit("framenavigated" /* PageEmittedEvents.FrameNavigated */, frame);
	        }
	    }
	    #onContextCreated(context) {
	        if (!this.frame(context.id) &&
	            (this.frame(context.parent ?? '') || !this.#frameTree.getMainFrame())) {
	            const frame = new Frame_js_1.BidiFrame(this, context, this.#timeoutSettings, context.parent);
	            this.#frameTree.addFrame(frame);
	            if (frame !== this.mainFrame()) {
	                this.emit("frameattached" /* PageEmittedEvents.FrameAttached */, frame);
	            }
	        }
	    }
	    #onContextDestroyed(context) {
	        const frame = this.frame(context.id);
	        if (frame) {
	            if (frame === this.mainFrame()) {
	                this.emit("close" /* PageEmittedEvents.Close */);
	            }
	            this.#removeFramesRecursively(frame);
	        }
	    }
	    #removeFramesRecursively(frame) {
	        for (const child of frame.childFrames()) {
	            this.#removeFramesRecursively(child);
	        }
	        frame[Symbol.dispose]();
	        this.#networkManager.clearMapAfterFrameDispose(frame);
	        this.#frameTree.removeFrame(frame);
	        this.emit("framedetached" /* PageEmittedEvents.FrameDetached */, frame);
	    }
	    #onLogEntryAdded(event) {
	        const frame = this.frame(event.source.context);
	        if (!frame) {
	            return;
	        }
	        if (isConsoleLogEntry(event)) {
	            const args = event.args.map(arg => {
	                return (0, Realm_js_1.createBidiHandle)(frame.mainRealm(), arg);
	            });
	            const text = args
	                .reduce((value, arg) => {
	                const parsedValue = arg.isPrimitiveValue
	                    ? Serializer_js_1.BidiSerializer.deserialize(arg.remoteValue())
	                    : arg.toString();
	                return `${value} ${parsedValue}`;
	            }, '')
	                .slice(1);
	            this.emit("console" /* PageEmittedEvents.Console */, new ConsoleMessage_js_1.ConsoleMessage(event.method, text, args, getStackTraceLocations(event.stackTrace)));
	        }
	        else if (isJavaScriptLogEntry(event)) {
	            let message = event.text ?? '';
	            if (event.stackTrace) {
	                for (const callFrame of event.stackTrace.callFrames) {
	                    const location = callFrame.url +
	                        ':' +
	                        callFrame.lineNumber +
	                        ':' +
	                        callFrame.columnNumber;
	                    const functionName = callFrame.functionName || '<anonymous>';
	                    message += `\n    at ${functionName} (${location})`;
	                }
	            }
	            const error = new Error(message);
	            error.stack = ''; // Don't capture Puppeteer stacktrace.
	            this.emit("pageerror" /* PageEmittedEvents.PageError */, error);
	        }
	        else {
	            (0, util_js_1.debugError)(`Unhandled LogEntry with type "${event.type}", text "${event.text}" and level "${event.level}"`);
	        }
	    }
	    #onDialog(event) {
	        const frame = this.frame(event.context);
	        if (!frame) {
	            return;
	        }
	        const type = (0, util_js_1.validateDialogType)(event.type);
	        const dialog = new Dialog_js_1.BidiDialog(frame.context(), type, event.message, event.defaultValue);
	        this.emit("dialog" /* PageEmittedEvents.Dialog */, dialog);
	    }
	    getNavigationResponse(id) {
	        return this.#networkManager.getNavigationResponse(id);
	    }
	    isClosed() {
	        return this.#closedDeferred.finished();
	    }
	    async close() {
	        if (this.#closedDeferred.finished()) {
	            return;
	        }
	        this.#closedDeferred.resolve(new Errors_js_1.TargetCloseError('Page closed!'));
	        this.#networkManager.dispose();
	        await this.#connection.send('browsingContext.close', {
	            context: this.mainFrame()._id,
	        });
	        this.emit("close" /* PageEmittedEvents.Close */);
	        this.removeAllListeners();
	    }
	    async reload(options) {
	        const [response] = await Promise.all([
	            this.waitForResponse(response => {
	                return (response.request().isNavigationRequest() &&
	                    response.url() === this.url());
	            }),
	            this.mainFrame()
	                .context()
	                .reload({
	                ...options,
	                timeout: options?.timeout ?? this.#timeoutSettings.navigationTimeout(),
	            }),
	        ]);
	        return response;
	    }
	    setDefaultNavigationTimeout(timeout) {
	        this.#timeoutSettings.setDefaultNavigationTimeout(timeout);
	    }
	    setDefaultTimeout(timeout) {
	        this.#timeoutSettings.setDefaultTimeout(timeout);
	    }
	    getDefaultTimeout() {
	        return this.#timeoutSettings.timeout();
	    }
	    isJavaScriptEnabled() {
	        return this.#cdpEmulationManager.javascriptEnabled;
	    }
	    async setGeolocation(options) {
	        return await this.#cdpEmulationManager.setGeolocation(options);
	    }
	    async setJavaScriptEnabled(enabled) {
	        return await this.#cdpEmulationManager.setJavaScriptEnabled(enabled);
	    }
	    async emulateMediaType(type) {
	        return await this.#cdpEmulationManager.emulateMediaType(type);
	    }
	    async emulateCPUThrottling(factor) {
	        return await this.#cdpEmulationManager.emulateCPUThrottling(factor);
	    }
	    async emulateMediaFeatures(features) {
	        return await this.#cdpEmulationManager.emulateMediaFeatures(features);
	    }
	    async emulateTimezone(timezoneId) {
	        return await this.#cdpEmulationManager.emulateTimezone(timezoneId);
	    }
	    async emulateIdleState(overrides) {
	        return await this.#cdpEmulationManager.emulateIdleState(overrides);
	    }
	    async emulateVisionDeficiency(type) {
	        return await this.#cdpEmulationManager.emulateVisionDeficiency(type);
	    }
	    async setViewport(viewport) {
	        if (!this.#browsingContext.supportsCDP()) {
	            await this.#emulationManager.emulateViewport(viewport);
	            this.#viewport = viewport;
	            return;
	        }
	        await this.#cdpEmulationManager.emulateViewport(viewport);
	        this.#viewport = viewport;
	    }
	    viewport() {
	        return this.#viewport;
	    }
	    async pdf(options = {}) {
	        const { path = undefined } = options;
	        const { printBackground: background, margin, landscape, width, height, pageRanges: ranges, scale, preferCSSPageSize, timeout, } = this._getPDFOptions(options, 'cm');
	        const pageRanges = ranges ? ranges.split(', ') : [];
	        const { result } = await (0, util_js_1.waitWithTimeout)(this.#connection.send('browsingContext.print', {
	            context: this.mainFrame()._id,
	            background,
	            margin,
	            orientation: landscape ? 'landscape' : 'portrait',
	            page: {
	                width,
	                height,
	            },
	            pageRanges,
	            scale,
	            shrinkToFit: !preferCSSPageSize,
	        }), 'browsingContext.print', timeout);
	        const buffer = Buffer.from(result.data, 'base64');
	        await this._maybeWriteBufferToFile(path, buffer);
	        return buffer;
	    }
	    async createPDFStream(options) {
	        const buffer = await this.pdf(options);
	        try {
	            const { Readable } = await Promise.resolve().then(() => __importStar(require('stream')));
	            return Readable.from(buffer);
	        }
	        catch (error) {
	            if (error instanceof TypeError) {
	                throw new Error('Can only pass a file path in a Node-like environment.');
	            }
	            throw error;
	        }
	    }
	    async screenshot(options = {}) {
	        const { path = undefined, encoding, ...args } = options;
	        if (Object.keys(args).length >= 1) {
	            throw new Error('BiDi only supports "encoding" and "path" options');
	        }
	        const { result } = await this.#connection.send('browsingContext.captureScreenshot', {
	            context: this.mainFrame()._id,
	        });
	        if (encoding === 'base64') {
	            return result.data;
	        }
	        const buffer = Buffer.from(result.data, 'base64');
	        await this._maybeWriteBufferToFile(path, buffer);
	        return buffer;
	    }
	    async waitForRequest(urlOrPredicate, options = {}) {
	        const { timeout = this.#timeoutSettings.timeout() } = options;
	        return await (0, util_js_1.waitForEvent)(this.#networkManager, NetworkManager_js_1.NetworkManagerEmittedEvents.Request, async (request) => {
	            if ((0, util_js_1.isString)(urlOrPredicate)) {
	                return urlOrPredicate === request.url();
	            }
	            if (typeof urlOrPredicate === 'function') {
	                return !!(await urlOrPredicate(request));
	            }
	            return false;
	        }, timeout, this.#closedDeferred.valueOrThrow());
	    }
	    async waitForResponse(urlOrPredicate, options = {}) {
	        const { timeout = this.#timeoutSettings.timeout() } = options;
	        return await (0, util_js_1.waitForEvent)(this.#networkManager, NetworkManager_js_1.NetworkManagerEmittedEvents.Response, async (response) => {
	            if ((0, util_js_1.isString)(urlOrPredicate)) {
	                return urlOrPredicate === response.url();
	            }
	            if (typeof urlOrPredicate === 'function') {
	                return !!(await urlOrPredicate(response));
	            }
	            return false;
	        }, timeout, this.#closedDeferred.valueOrThrow());
	    }
	    async waitForNetworkIdle(options = {}) {
	        const { idleTime = 500, timeout = this.#timeoutSettings.timeout() } = options;
	        await this._waitForNetworkIdle(this.#networkManager, idleTime, timeout, this.#closedDeferred);
	    }
	    async createCDPSession() {
	        const { sessionId } = await this.mainFrame()
	            .context()
	            .cdpSession.send('Target.attachToTarget', {
	            targetId: this.mainFrame()._id,
	            flatten: true,
	        });
	        return new BrowsingContext_js_1.CDPSessionWrapper(this.mainFrame().context(), sessionId);
	    }
	    async bringToFront() {
	        await this.#connection.send('browsingContext.activate', {
	            context: this.mainFrame()._id,
	        });
	    }
	    async evaluateOnNewDocument(pageFunction, ...args) {
	        const expression = evaluationExpression(pageFunction, ...args);
	        const { result } = await this.#connection.send('script.addPreloadScript', {
	            functionDeclaration: expression,
	            // TODO: should change spec to accept browsingContext
	        });
	        return { identifier: result.script };
	    }
	    async removeScriptToEvaluateOnNewDocument(id) {
	        await this.#connection.send('script.removePreloadScript', {
	            script: id,
	        });
	    }
	    async exposeFunction(name, pptrFunction) {
	        return await this.mainFrame().exposeFunction(name, 'default' in pptrFunction ? pptrFunction.default : pptrFunction);
	    }
	}
	Page.BidiPage = BidiPage;
	function isConsoleLogEntry(event) {
	    return event.type === 'console';
	}
	function isJavaScriptLogEntry(event) {
	    return event.type === 'javascript';
	}
	function getStackTraceLocations(stackTrace) {
	    const stackTraceLocations = [];
	    if (stackTrace) {
	        for (const callFrame of stackTrace.callFrames) {
	            stackTraceLocations.push({
	                url: callFrame.url,
	                lineNumber: callFrame.lineNumber,
	                columnNumber: callFrame.columnNumber,
	            });
	        }
	    }
	    return stackTraceLocations;
	}
	function evaluationExpression(fun, ...args) {
	    return `() => {${(0, util_js_1.evaluationString)(fun, ...args)}}`;
	}
	
	return Page;
}

var hasRequiredTarget;

function requireTarget () {
	if (hasRequiredTarget) return Target;
	hasRequiredTarget = 1;
	/**
	 * Copyright 2023 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(Target, "__esModule", { value: true });
	Target.BiDiPageTarget = Target.BiDiBrowsingContextTarget = Target.BiDiBrowserTarget = Target.BidiTarget = void 0;
	const Target_js_1 = Target$3;
	const BrowsingContext_js_1 = requireBrowsingContext();
	const Page_js_1 = requirePage();
	class BidiTarget extends Target_js_1.Target {
	    _browserContext;
	    constructor(browserContext) {
	        super();
	        this._browserContext = browserContext;
	    }
	    async worker() {
	        return null;
	    }
	    browser() {
	        return this._browserContext.browser();
	    }
	    browserContext() {
	        return this._browserContext;
	    }
	    opener() {
	        throw new Error('Not implemented');
	    }
	    _setBrowserContext(browserContext) {
	        this._browserContext = browserContext;
	    }
	}
	Target.BidiTarget = BidiTarget;
	/**
	 * @internal
	 */
	class BiDiBrowserTarget extends BidiTarget {
	    url() {
	        return '';
	    }
	    type() {
	        return Target_js_1.TargetType.BROWSER;
	    }
	}
	Target.BiDiBrowserTarget = BiDiBrowserTarget;
	/**
	 * @internal
	 */
	class BiDiBrowsingContextTarget extends BidiTarget {
	    _browsingContext;
	    constructor(browserContext, browsingContext) {
	        super(browserContext);
	        this._browsingContext = browsingContext;
	    }
	    url() {
	        return this._browsingContext.url;
	    }
	    async createCDPSession() {
	        const { sessionId } = await this._browsingContext.cdpSession.send('Target.attachToTarget', {
	            targetId: this._browsingContext.id,
	            flatten: true,
	        });
	        return new BrowsingContext_js_1.CDPSessionWrapper(this._browsingContext, sessionId);
	    }
	    type() {
	        return Target_js_1.TargetType.PAGE;
	    }
	}
	Target.BiDiBrowsingContextTarget = BiDiBrowsingContextTarget;
	/**
	 * @internal
	 */
	class BiDiPageTarget extends BiDiBrowsingContextTarget {
	    #page;
	    constructor(browserContext, browsingContext) {
	        super(browserContext, browsingContext);
	        this.#page = new Page_js_1.BidiPage(browsingContext, browserContext);
	    }
	    async page() {
	        return this.#page;
	    }
	    _setBrowserContext(browserContext) {
	        super._setBrowserContext(browserContext);
	        this.#page._setBrowserContext(browserContext);
	    }
	}
	Target.BiDiPageTarget = BiDiPageTarget;
	
	return Target;
}

var hasRequiredBrowser;

function requireBrowser () {
	if (hasRequiredBrowser) return Browser;
	hasRequiredBrowser = 1;
	/**
	 * Copyright 2022 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(Browser, "__esModule", { value: true });
	Browser.BidiBrowser = void 0;
	const Browser_js_1 = Browser$3;
	const BrowserContext_js_1 = requireBrowserContext();
	const BrowsingContext_js_1 = requireBrowsingContext();
	const Target_js_1 = requireTarget();
	const utils_js_1 = requireUtils();
	/**
	 * @internal
	 */
	class BidiBrowser extends Browser_js_1.Browser {
	    // TODO: Update generator to include fully module
	    static subscribeModules = [
	        'browsingContext',
	        'network',
	        'log',
	        'script',
	    ];
	    static subscribeCdpEvents = [
	        // Coverage
	        'cdp.Debugger.scriptParsed',
	        'cdp.CSS.styleSheetAdded',
	        'cdp.Runtime.executionContextsCleared',
	        // Tracing
	        'cdp.Tracing.tracingComplete',
	        // TODO: subscribe to all CDP events in the future.
	        'cdp.Network.requestWillBeSent',
	        'cdp.Debugger.scriptParsed',
	    ];
	    static async create(opts) {
	        let browserName = '';
	        let browserVersion = '';
	        // TODO: await until the connection is established.
	        try {
	            const { result } = await opts.connection.send('session.new', {
	                capabilities: {
	                    alwaysMatch: {
	                        acceptInsecureCerts: opts.ignoreHTTPSErrors,
	                    },
	                },
	            });
	            browserName = result.capabilities.browserName ?? '';
	            browserVersion = result.capabilities.browserVersion ?? '';
	        }
	        catch (err) {
	            // Chrome does not support session.new.
	            (0, utils_js_1.debugError)(err);
	        }
	        await opts.connection.send('session.subscribe', {
	            events: browserName.toLocaleLowerCase().includes('firefox')
	                ? BidiBrowser.subscribeModules
	                : [...BidiBrowser.subscribeModules, ...BidiBrowser.subscribeCdpEvents],
	        });
	        const browser = new BidiBrowser({
	            ...opts,
	            browserName,
	            browserVersion,
	        });
	        await browser.#getTree();
	        return browser;
	    }
	    #browserName = '';
	    #browserVersion = '';
	    #process;
	    #closeCallback;
	    #connection;
	    #defaultViewport;
	    #defaultContext;
	    #targets = new Map();
	    #contexts = [];
	    #browserTarget;
	    #connectionEventHandlers = new Map([
	        ['browsingContext.contextCreated', this.#onContextCreated.bind(this)],
	        ['browsingContext.contextDestroyed', this.#onContextDestroyed.bind(this)],
	        ['browsingContext.domContentLoaded', this.#onContextDomLoaded.bind(this)],
	        ['browsingContext.fragmentNavigated', this.#onContextNavigation.bind(this)],
	        ['browsingContext.navigationStarted', this.#onContextNavigation.bind(this)],
	    ]);
	    constructor(opts) {
	        super();
	        this.#process = opts.process;
	        this.#closeCallback = opts.closeCallback;
	        this.#connection = opts.connection;
	        this.#defaultViewport = opts.defaultViewport;
	        this.#browserName = opts.browserName;
	        this.#browserVersion = opts.browserVersion;
	        this.#process?.once('close', () => {
	            this.#connection.dispose();
	            this.emit("disconnected" /* BrowserEmittedEvents.Disconnected */);
	        });
	        this.#defaultContext = new BrowserContext_js_1.BidiBrowserContext(this, {
	            defaultViewport: this.#defaultViewport,
	            isDefault: true,
	        });
	        this.#browserTarget = new Target_js_1.BiDiBrowserTarget(this.#defaultContext);
	        this.#contexts.push(this.#defaultContext);
	        for (const [eventName, handler] of this.#connectionEventHandlers) {
	            this.#connection.on(eventName, handler);
	        }
	    }
	    #onContextDomLoaded(event) {
	        const target = this.#targets.get(event.context);
	        if (target) {
	            this.emit("targetchanged" /* BrowserEmittedEvents.TargetChanged */, target);
	        }
	    }
	    #onContextNavigation(event) {
	        const target = this.#targets.get(event.context);
	        if (target) {
	            this.emit("targetchanged" /* BrowserEmittedEvents.TargetChanged */, target);
	            target
	                .browserContext()
	                .emit("targetchanged" /* BrowserContextEmittedEvents.TargetChanged */, target);
	        }
	    }
	    #onContextCreated(event) {
	        const context = new BrowsingContext_js_1.BrowsingContext(this.#connection, event, this.#browserName);
	        this.#connection.registerBrowsingContexts(context);
	        // TODO: once more browsing context types are supported, this should be
	        // updated to support those. Currently, all top-level contexts are treated
	        // as pages.
	        const browserContext = this.browserContexts().at(-1);
	        if (!browserContext) {
	            throw new Error('Missing browser contexts');
	        }
	        const target = !context.parent
	            ? new Target_js_1.BiDiPageTarget(browserContext, context)
	            : new Target_js_1.BiDiBrowsingContextTarget(browserContext, context);
	        this.#targets.set(event.context, target);
	        this.emit("targetcreated" /* BrowserEmittedEvents.TargetCreated */, target);
	        target
	            .browserContext()
	            .emit("targetcreated" /* BrowserContextEmittedEvents.TargetCreated */, target);
	        if (context.parent) {
	            const topLevel = this.#connection.getTopLevelContext(context.parent);
	            topLevel.emit(BrowsingContext_js_1.BrowsingContextEmittedEvents.Created, context);
	        }
	    }
	    async #getTree() {
	        const { result } = await this.#connection.send('browsingContext.getTree', {});
	        for (const context of result.contexts) {
	            this.#onContextCreated(context);
	        }
	    }
	    async #onContextDestroyed(event) {
	        const context = this.#connection.getBrowsingContext(event.context);
	        const topLevelContext = this.#connection.getTopLevelContext(event.context);
	        topLevelContext.emit(BrowsingContext_js_1.BrowsingContextEmittedEvents.Destroyed, context);
	        const target = this.#targets.get(event.context);
	        const page = await target?.page();
	        await page?.close().catch(utils_js_1.debugError);
	        this.#targets.delete(event.context);
	        if (target) {
	            this.emit("targetdestroyed" /* BrowserEmittedEvents.TargetDestroyed */, target);
	            target
	                .browserContext()
	                .emit("targetdestroyed" /* BrowserContextEmittedEvents.TargetDestroyed */, target);
	        }
	    }
	    get connection() {
	        return this.#connection;
	    }
	    wsEndpoint() {
	        return this.#connection.url;
	    }
	    async close() {
	        for (const [eventName, handler] of this.#connectionEventHandlers) {
	            this.#connection.off(eventName, handler);
	        }
	        if (this.#connection.closed) {
	            return;
	        }
	        // TODO: implement browser.close.
	        // await this.#connection.send('browser.close', {});
	        this.#connection.dispose();
	        await this.#closeCallback?.call(null);
	    }
	    isConnected() {
	        return !this.#connection.closed;
	    }
	    process() {
	        return this.#process ?? null;
	    }
	    async createIncognitoBrowserContext(_options) {
	        // TODO: implement incognito context https://github.com/w3c/webdriver-bidi/issues/289.
	        const context = new BrowserContext_js_1.BidiBrowserContext(this, {
	            defaultViewport: this.#defaultViewport,
	            isDefault: false,
	        });
	        this.#contexts.push(context);
	        return context;
	    }
	    async version() {
	        return `${this.#browserName}/${this.#browserVersion}`;
	    }
	    /**
	     * Returns an array of all open browser contexts. In a newly created browser, this will
	     * return a single instance of {@link BidiBrowserContext}.
	     */
	    browserContexts() {
	        // TODO: implement incognito context https://github.com/w3c/webdriver-bidi/issues/289.
	        return this.#contexts;
	    }
	    async _closeContext(browserContext) {
	        this.#contexts = this.#contexts.filter(c => {
	            return c !== browserContext;
	        });
	        for (const target of browserContext.targets()) {
	            const page = await target?.page();
	            await page?.close().catch(error => {
	                (0, utils_js_1.debugError)(error);
	            });
	        }
	    }
	    /**
	     * Returns the default browser context. The default browser context cannot be closed.
	     */
	    defaultBrowserContext() {
	        return this.#defaultContext;
	    }
	    newPage() {
	        return this.#defaultContext.newPage();
	    }
	    targets() {
	        return [this.#browserTarget, ...Array.from(this.#targets.values())];
	    }
	    _getTargetById(id) {
	        const target = this.#targets.get(id);
	        if (!target) {
	            throw new Error('Target not found');
	        }
	        return target;
	    }
	    target() {
	        return this.#browserTarget;
	    }
	}
	Browser.BidiBrowser = BidiBrowser;
	
	return Browser;
}

var hasRequiredBidi;

function requireBidi () {
	if (hasRequiredBidi) return bidi;
	hasRequiredBidi = 1;
	(function (exports) {
		/**
		 * Copyright 2022 Google Inc. All rights reserved.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *     http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		__exportStar(requireBidiOverCDP(), exports);
		__exportStar(requireBrowser(), exports);
		__exportStar(requireBrowserContext(), exports);
		__exportStar(requireConnection(), exports);
		__exportStar(requirePage(), exports);
		
	} (bidi));
	return bidi;
}

var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(ProductLauncher$1, "__esModule", { value: true });
ProductLauncher$1.ProductLauncher = void 0;
/**
 * Copyright 2017 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const fs_1$2 = require$$0$4;
const os_1$1 = require$$1$1;
const path_1$2 = require$$2;
const browsers_1$3 = require$$3;
const Browser_js_1 = Browser$1;
const Connection_js_1 = Connection$1;
const Errors_js_1 = Errors;
const NodeWebSocketTransport_js_1 = NodeWebSocketTransport$1;
const util_js_1$2 = requireUtil();
const PipeTransport_js_1 = PipeTransport$1;
/**
 * Describes a launcher - a class that is able to create and launch a browser instance.
 *
 * @public
 */
class ProductLauncher {
    #product;
    /**
     * @internal
     */
    puppeteer;
    /**
     * @internal
     */
    actualBrowserRevision;
    /**
     * @internal
     */
    constructor(puppeteer, product) {
        this.puppeteer = puppeteer;
        this.#product = product;
    }
    get product() {
        return this.#product;
    }
    async launch(options = {}) {
        const { dumpio = false, env = process.env, handleSIGINT = true, handleSIGTERM = true, handleSIGHUP = true, ignoreHTTPSErrors = false, defaultViewport = { width: 800, height: 600 }, slowMo = 0, timeout = 30000, waitForInitialPage = true, protocol, protocolTimeout, } = options;
        const launchArgs = await this.computeLaunchArguments(options);
        const usePipe = launchArgs.args.includes('--remote-debugging-pipe');
        const onProcessExit = async () => {
            await this.cleanUserDataDir(launchArgs.userDataDir, {
                isTemp: launchArgs.isTempUserDataDir,
            });
        };
        const browserProcess = (0, browsers_1$3.launch)({
            executablePath: launchArgs.executablePath,
            args: launchArgs.args,
            handleSIGHUP,
            handleSIGTERM,
            handleSIGINT,
            dumpio,
            env,
            pipe: usePipe,
            onExit: onProcessExit,
        });
        let browser;
        let connection;
        let closing = false;
        const browserCloseCallback = async () => {
            if (closing) {
                return;
            }
            closing = true;
            await this.closeBrowser(browserProcess, connection);
        };
        try {
            if (this.#product === 'firefox' && protocol === 'webDriverBiDi') {
                browser = await this.createBiDiBrowser(browserProcess, browserCloseCallback, {
                    timeout,
                    protocolTimeout,
                    slowMo,
                    defaultViewport,
                    ignoreHTTPSErrors,
                });
            }
            else {
                if (usePipe) {
                    connection = await this.createCDPPipeConnection(browserProcess, {
                        timeout,
                        protocolTimeout,
                        slowMo,
                    });
                }
                else {
                    connection = await this.createCDPSocketConnection(browserProcess, {
                        timeout,
                        protocolTimeout,
                        slowMo,
                    });
                }
                if (protocol === 'webDriverBiDi') {
                    browser = await this.createBiDiOverCDPBrowser(browserProcess, connection, browserCloseCallback, {
                        timeout,
                        protocolTimeout,
                        slowMo,
                        defaultViewport,
                        ignoreHTTPSErrors,
                    });
                }
                else {
                    browser = await Browser_js_1.CDPBrowser._create(this.product, connection, [], ignoreHTTPSErrors, defaultViewport, browserProcess.nodeProcess, browserCloseCallback, options.targetFilter);
                }
            }
        }
        catch (error) {
            void browserCloseCallback();
            if (error instanceof browsers_1$3.TimeoutError) {
                throw new Errors_js_1.TimeoutError(error.message);
            }
            throw error;
        }
        if (waitForInitialPage && protocol !== 'webDriverBiDi') {
            await this.waitForPageTarget(browser, timeout);
        }
        return browser;
    }
    executablePath() {
        throw new Error('Not implemented');
    }
    defaultArgs() {
        throw new Error('Not implemented');
    }
    /**
     * Set only for Firefox, after the launcher resolves the `latest` revision to
     * the actual revision.
     * @internal
     */
    getActualBrowserRevision() {
        return this.actualBrowserRevision;
    }
    async computeLaunchArguments() {
        throw new Error('Not implemented');
    }
    async cleanUserDataDir() {
        throw new Error('Not implemented');
    }
    /**
     * @internal
     */
    async closeBrowser(browserProcess, connection) {
        if (connection) {
            // Attempt to close the browser gracefully
            try {
                await connection.closeBrowser();
                await browserProcess.hasClosed();
            }
            catch (error) {
                (0, util_js_1$2.debugError)(error);
                await browserProcess.close();
            }
        }
        else {
            await browserProcess.close();
        }
    }
    /**
     * @internal
     */
    async waitForPageTarget(browser, timeout) {
        try {
            await browser.waitForTarget(t => {
                return t.type() === 'page';
            }, { timeout });
        }
        catch (error) {
            await browser.close();
            throw error;
        }
    }
    /**
     * @internal
     */
    async createCDPSocketConnection(browserProcess, opts) {
        const browserWSEndpoint = await browserProcess.waitForLineOutput(browsers_1$3.CDP_WEBSOCKET_ENDPOINT_REGEX, opts.timeout);
        const transport = await NodeWebSocketTransport_js_1.NodeWebSocketTransport.create(browserWSEndpoint);
        return new Connection_js_1.Connection(browserWSEndpoint, transport, opts.slowMo, opts.protocolTimeout);
    }
    /**
     * @internal
     */
    async createCDPPipeConnection(browserProcess, opts) {
        // stdio was assigned during start(), and the 'pipe' option there adds the
        // 4th and 5th items to stdio array
        const { 3: pipeWrite, 4: pipeRead } = browserProcess.nodeProcess.stdio;
        const transport = new PipeTransport_js_1.PipeTransport(pipeWrite, pipeRead);
        return new Connection_js_1.Connection('', transport, opts.slowMo, opts.protocolTimeout);
    }
    /**
     * @internal
     */
    async createBiDiOverCDPBrowser(browserProcess, connection, closeCallback, opts) {
        // TODO: use other options too.
        const BiDi = await Promise.resolve().then(() => __importStar(requireBidi()));
        const bidiConnection = await BiDi.connectBidiOverCDP(connection);
        return await BiDi.BidiBrowser.create({
            connection: bidiConnection,
            closeCallback,
            process: browserProcess.nodeProcess,
            defaultViewport: opts.defaultViewport,
            ignoreHTTPSErrors: opts.ignoreHTTPSErrors,
        });
    }
    /**
     * @internal
     */
    async createBiDiBrowser(browserProcess, closeCallback, opts) {
        const browserWSEndpoint = (await browserProcess.waitForLineOutput(browsers_1$3.WEBDRIVER_BIDI_WEBSOCKET_ENDPOINT_REGEX, opts.timeout)) + '/session';
        const transport = await NodeWebSocketTransport_js_1.NodeWebSocketTransport.create(browserWSEndpoint);
        const BiDi = await Promise.resolve().then(() => __importStar(requireBidi()));
        const bidiConnection = new BiDi.Connection(browserWSEndpoint, transport, opts.slowMo, opts.protocolTimeout);
        // TODO: use other options too.
        return await BiDi.BidiBrowser.create({
            connection: bidiConnection,
            closeCallback,
            process: browserProcess.nodeProcess,
            defaultViewport: opts.defaultViewport,
            ignoreHTTPSErrors: opts.ignoreHTTPSErrors,
        });
    }
    /**
     * @internal
     */
    getProfilePath() {
        return (0, path_1$2.join)(this.puppeteer.configuration.temporaryDirectory ?? (0, os_1$1.tmpdir)(), `puppeteer_dev_${this.product}_profile-`);
    }
    /**
     * @internal
     */
    resolveExecutablePath() {
        let executablePath = this.puppeteer.configuration.executablePath;
        if (executablePath) {
            if (!(0, fs_1$2.existsSync)(executablePath)) {
                throw new Error(`Tried to find the browser at the configured path (${executablePath}), but no executable was found.`);
            }
            return executablePath;
        }
        function productToBrowser(product) {
            switch (product) {
                case 'chrome':
                    return browsers_1$3.Browser.CHROME;
                case 'firefox':
                    return browsers_1$3.Browser.FIREFOX;
            }
            return browsers_1$3.Browser.CHROME;
        }
        executablePath = (0, browsers_1$3.computeExecutablePath)({
            cacheDir: this.puppeteer.defaultDownloadPath,
            browser: productToBrowser(this.product),
            buildId: this.puppeteer.browserRevision,
        });
        if (!(0, fs_1$2.existsSync)(executablePath)) {
            if (this.puppeteer.configuration.browserRevision) {
                throw new Error(`Tried to find the browser at the configured path (${executablePath}) for revision ${this.puppeteer.browserRevision}, but no executable was found.`);
            }
            switch (this.product) {
                case 'chrome':
                    throw new Error(`Could not find Chrome (ver. ${this.puppeteer.browserRevision}). This can occur if either\n` +
                        ' 1. you did not perform an installation before running the script (e.g. `npm install`) or\n' +
                        ` 2. your cache path is incorrectly configured (which is: ${this.puppeteer.configuration.cacheDirectory}).\n` +
                        'For (2), check out our guide on configuring puppeteer at https://pptr.dev/guides/configuration.');
                case 'firefox':
                    throw new Error(`Could not find Firefox (rev. ${this.puppeteer.browserRevision}). This can occur if either\n` +
                        ' 1. you did not perform an installation for Firefox before running the script (e.g. `PUPPETEER_PRODUCT=firefox npm install`) or\n' +
                        ` 2. your cache path is incorrectly configured (which is: ${this.puppeteer.configuration.cacheDirectory}).\n` +
                        'For (2), check out our guide on configuring puppeteer at https://pptr.dev/guides/configuration.');
            }
        }
        return executablePath;
    }
}
ProductLauncher$1.ProductLauncher = ProductLauncher;

var fs = {};

/**
 * Copyright 2023 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault$2 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(fs, "__esModule", { value: true });
fs.rmSync = fs.rm = void 0;
const fs_1$1 = __importDefault$2(require$$0$4);
const rmOptions = {
    force: true,
    recursive: true,
    maxRetries: 5,
};
/**
 * @internal
 */
async function rm(path) {
    await fs_1$1.default.promises.rm(path, rmOptions);
}
fs.rm = rm;
/**
 * @internal
 */
function rmSync(path) {
    fs_1$1.default.rmSync(path, rmOptions);
}
fs.rmSync = rmSync;

/**
 * Copyright 2023 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault$1 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(ChromeLauncher$1, "__esModule", { value: true });
ChromeLauncher$1.ChromeLauncher = void 0;
const promises_1$1 = require$$0$5;
const path_1$1 = __importDefault$1(require$$2);
const browsers_1$2 = require$$3;
const util_js_1$1 = requireUtil();
const environment_js_1$1 = environment;
const assert_js_1$1 = assert$1;
const ProductLauncher_js_1$1 = ProductLauncher$1;
const fs_js_1$1 = fs;
/**
 * @internal
 */
class ChromeLauncher extends ProductLauncher_js_1$1.ProductLauncher {
    constructor(puppeteer) {
        super(puppeteer, 'chrome');
    }
    launch(options = {}) {
        const headless = options.headless ?? true;
        if (headless === true &&
            this.puppeteer.configuration.logLevel === 'warn' &&
            !Boolean(process.env['PUPPETEER_DISABLE_HEADLESS_WARNING'])) {
            console.warn([
                '\x1B[1m\x1B[43m\x1B[30m',
                'Puppeteer old Headless deprecation warning:\x1B[0m\x1B[33m',
                '  In the near future `headless: true` will default to the new Headless mode',
                '  for Chrome instead of the old Headless implementation. For more',
                '  information, please see https://developer.chrome.com/articles/new-headless/.',
                '  Consider opting in early by passing `headless: "new"` to `puppeteer.launch()`',
                '  If you encounter any bugs, please report them to https://github.com/puppeteer/puppeteer/issues/new/choose.\x1B[0m\n',
            ].join('\n  '));
        }
        return super.launch(options);
    }
    /**
     * @internal
     */
    async computeLaunchArguments(options = {}) {
        const { ignoreDefaultArgs = false, args = [], pipe = false, debuggingPort, channel, executablePath, } = options;
        const chromeArguments = [];
        if (!ignoreDefaultArgs) {
            chromeArguments.push(...this.defaultArgs(options));
        }
        else if (Array.isArray(ignoreDefaultArgs)) {
            chromeArguments.push(...this.defaultArgs(options).filter(arg => {
                return !ignoreDefaultArgs.includes(arg);
            }));
        }
        else {
            chromeArguments.push(...args);
        }
        if (!chromeArguments.some(argument => {
            return argument.startsWith('--remote-debugging-');
        })) {
            if (pipe) {
                (0, assert_js_1$1.assert)(!debuggingPort, 'Browser should be launched with either pipe or debugging port - not both.');
                chromeArguments.push('--remote-debugging-pipe');
            }
            else {
                chromeArguments.push(`--remote-debugging-port=${debuggingPort || 0}`);
            }
        }
        let isTempUserDataDir = false;
        // Check for the user data dir argument, which will always be set even
        // with a custom directory specified via the userDataDir option.
        let userDataDirIndex = chromeArguments.findIndex(arg => {
            return arg.startsWith('--user-data-dir');
        });
        if (userDataDirIndex < 0) {
            isTempUserDataDir = true;
            chromeArguments.push(`--user-data-dir=${await (0, promises_1$1.mkdtemp)(this.getProfilePath())}`);
            userDataDirIndex = chromeArguments.length - 1;
        }
        const userDataDir = chromeArguments[userDataDirIndex].split('=', 2)[1];
        (0, assert_js_1$1.assert)(typeof userDataDir === 'string', '`--user-data-dir` is malformed');
        let chromeExecutable = executablePath;
        if (!chromeExecutable) {
            (0, assert_js_1$1.assert)(channel || !this.puppeteer._isPuppeteerCore, `An \`executablePath\` or \`channel\` must be specified for \`puppeteer-core\``);
            chromeExecutable = this.executablePath(channel);
        }
        return {
            executablePath: chromeExecutable,
            args: chromeArguments,
            isTempUserDataDir,
            userDataDir,
        };
    }
    /**
     * @internal
     */
    async cleanUserDataDir(path, opts) {
        if (opts.isTemp) {
            try {
                await (0, fs_js_1$1.rm)(path);
            }
            catch (error) {
                (0, util_js_1$1.debugError)(error);
                throw error;
            }
        }
    }
    defaultArgs(options = {}) {
        // See https://github.com/GoogleChrome/chrome-launcher/blob/main/docs/chrome-flags-for-tools.md
        const disabledFeatures = [
            'Translate',
            // AcceptCHFrame disabled because of crbug.com/1348106.
            'AcceptCHFrame',
            'MediaRouter',
            'OptimizationHints',
        ];
        if (!environment_js_1$1.USE_TAB_TARGET) {
            disabledFeatures.push('Prerender2');
            disabledFeatures.push('BackForwardCache');
        }
        const chromeArguments = [
            '--allow-pre-commit-input',
            '--disable-background-networking',
            '--disable-background-timer-throttling',
            '--disable-backgrounding-occluded-windows',
            '--disable-breakpad',
            '--disable-client-side-phishing-detection',
            '--disable-component-extensions-with-background-pages',
            '--disable-component-update',
            '--disable-default-apps',
            '--disable-dev-shm-usage',
            '--disable-extensions',
            `--disable-features=${disabledFeatures.join(',')}`,
            '--disable-hang-monitor',
            '--disable-ipc-flooding-protection',
            '--disable-popup-blocking',
            '--disable-prompt-on-repost',
            '--disable-renderer-backgrounding',
            '--disable-search-engine-choice-screen',
            '--disable-sync',
            '--enable-automation',
            // TODO(sadym): remove '--enable-blink-features=IdleDetection' once
            // IdleDetection is turned on by default.
            '--enable-blink-features=IdleDetection',
            '--enable-features=NetworkServiceInProcess2',
            '--export-tagged-pdf',
            '--force-color-profile=srgb',
            '--metrics-recording-only',
            '--no-first-run',
            '--password-store=basic',
            '--use-mock-keychain',
        ];
        const { devtools = false, headless = !devtools, args = [], userDataDir, } = options;
        if (userDataDir) {
            chromeArguments.push(`--user-data-dir=${path_1$1.default.resolve(userDataDir)}`);
        }
        if (devtools) {
            chromeArguments.push('--auto-open-devtools-for-tabs');
        }
        if (headless) {
            chromeArguments.push(headless === 'new' ? '--headless=new' : '--headless', '--hide-scrollbars', '--mute-audio');
        }
        if (args.every(arg => {
            return arg.startsWith('-');
        })) {
            chromeArguments.push('about:blank');
        }
        chromeArguments.push(...args);
        return chromeArguments;
    }
    executablePath(channel) {
        if (channel) {
            return (0, browsers_1$2.computeSystemExecutablePath)({
                browser: browsers_1$2.Browser.CHROME,
                channel: convertPuppeteerChannelToBrowsersChannel(channel),
            });
        }
        else {
            return this.resolveExecutablePath();
        }
    }
}
ChromeLauncher$1.ChromeLauncher = ChromeLauncher;
function convertPuppeteerChannelToBrowsersChannel(channel) {
    switch (channel) {
        case 'chrome':
            return browsers_1$2.ChromeReleaseChannel.STABLE;
        case 'chrome-dev':
            return browsers_1$2.ChromeReleaseChannel.DEV;
        case 'chrome-beta':
            return browsers_1$2.ChromeReleaseChannel.BETA;
        case 'chrome-canary':
            return browsers_1$2.ChromeReleaseChannel.CANARY;
    }
}

var FirefoxLauncher$1 = {};

/**
 * Copyright 2023 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(FirefoxLauncher$1, "__esModule", { value: true });
FirefoxLauncher$1.FirefoxLauncher = void 0;
const fs_1 = __importDefault(require$$0$4);
const promises_1 = require$$0$5;
const os_1 = __importDefault(require$$1$1);
const path_1 = __importDefault(require$$2);
const browsers_1$1 = require$$3;
const util_js_1 = requireUtil();
const assert_js_1 = assert$1;
const ProductLauncher_js_1 = ProductLauncher$1;
const fs_js_1 = fs;
/**
 * @internal
 */
class FirefoxLauncher extends ProductLauncher_js_1.ProductLauncher {
    constructor(puppeteer) {
        super(puppeteer, 'firefox');
    }
    /**
     * @internal
     */
    async computeLaunchArguments(options = {}) {
        const { ignoreDefaultArgs = false, args = [], executablePath, pipe = false, extraPrefsFirefox = {}, debuggingPort = null, } = options;
        const firefoxArguments = [];
        if (!ignoreDefaultArgs) {
            firefoxArguments.push(...this.defaultArgs(options));
        }
        else if (Array.isArray(ignoreDefaultArgs)) {
            firefoxArguments.push(...this.defaultArgs(options).filter(arg => {
                return !ignoreDefaultArgs.includes(arg);
            }));
        }
        else {
            firefoxArguments.push(...args);
        }
        if (!firefoxArguments.some(argument => {
            return argument.startsWith('--remote-debugging-');
        })) {
            if (pipe) {
                (0, assert_js_1.assert)(debuggingPort === null, 'Browser should be launched with either pipe or debugging port - not both.');
            }
            firefoxArguments.push(`--remote-debugging-port=${debuggingPort || 0}`);
        }
        let userDataDir;
        let isTempUserDataDir = true;
        // Check for the profile argument, which will always be set even
        // with a custom directory specified via the userDataDir option.
        const profileArgIndex = firefoxArguments.findIndex(arg => {
            return ['-profile', '--profile'].includes(arg);
        });
        if (profileArgIndex !== -1) {
            userDataDir = firefoxArguments[profileArgIndex + 1];
            if (!userDataDir || !fs_1.default.existsSync(userDataDir)) {
                throw new Error(`Firefox profile not found at '${userDataDir}'`);
            }
            // When using a custom Firefox profile it needs to be populated
            // with required preferences.
            isTempUserDataDir = false;
        }
        else {
            userDataDir = await (0, promises_1.mkdtemp)(this.getProfilePath());
            firefoxArguments.push('--profile');
            firefoxArguments.push(userDataDir);
        }
        await (0, browsers_1$1.createProfile)(browsers_1$1.Browser.FIREFOX, {
            path: userDataDir,
            preferences: extraPrefsFirefox,
        });
        let firefoxExecutable;
        if (this.puppeteer._isPuppeteerCore || executablePath) {
            (0, assert_js_1.assert)(executablePath, `An \`executablePath\` must be specified for \`puppeteer-core\``);
            firefoxExecutable = executablePath;
        }
        else {
            firefoxExecutable = this.executablePath();
        }
        return {
            isTempUserDataDir,
            userDataDir,
            args: firefoxArguments,
            executablePath: firefoxExecutable,
        };
    }
    /**
     * @internal
     */
    async cleanUserDataDir(userDataDir, opts) {
        if (opts.isTemp) {
            try {
                await (0, fs_js_1.rm)(userDataDir);
            }
            catch (error) {
                (0, util_js_1.debugError)(error);
                throw error;
            }
        }
        else {
            try {
                // When an existing user profile has been used remove the user
                // preferences file and restore possibly backuped preferences.
                await (0, promises_1.unlink)(path_1.default.join(userDataDir, 'user.js'));
                const prefsBackupPath = path_1.default.join(userDataDir, 'prefs.js.puppeteer');
                if (fs_1.default.existsSync(prefsBackupPath)) {
                    const prefsPath = path_1.default.join(userDataDir, 'prefs.js');
                    await (0, promises_1.unlink)(prefsPath);
                    await (0, promises_1.rename)(prefsBackupPath, prefsPath);
                }
            }
            catch (error) {
                (0, util_js_1.debugError)(error);
            }
        }
    }
    executablePath() {
        // replace 'latest' placeholder with actual downloaded revision
        if (this.puppeteer.browserRevision === 'latest') {
            const cache = new browsers_1$1.Cache(this.puppeteer.defaultDownloadPath);
            const installedFirefox = cache.getInstalledBrowsers().find(browser => {
                return (browser.platform === (0, browsers_1$1.detectBrowserPlatform)() &&
                    browser.browser === browsers_1$1.Browser.FIREFOX);
            });
            if (installedFirefox) {
                this.actualBrowserRevision = installedFirefox.buildId;
            }
        }
        return this.resolveExecutablePath();
    }
    defaultArgs(options = {}) {
        const { devtools = false, headless = !devtools, args = [], userDataDir = null, } = options;
        const firefoxArguments = ['--no-remote'];
        switch (os_1.default.platform()) {
            case 'darwin':
                firefoxArguments.push('--foreground');
                break;
            case 'win32':
                firefoxArguments.push('--wait-for-browser');
                break;
        }
        if (userDataDir) {
            firefoxArguments.push('--profile');
            firefoxArguments.push(userDataDir);
        }
        if (headless) {
            firefoxArguments.push('--headless');
        }
        if (devtools) {
            firefoxArguments.push('--devtools');
        }
        if (args.every(arg => {
            return arg.startsWith('-');
        })) {
            firefoxArguments.push('about:blank');
        }
        firefoxArguments.push(...args);
        return firefoxArguments;
    }
}
FirefoxLauncher$1.FirefoxLauncher = FirefoxLauncher;

var LaunchOptions = {};

/**
 * Copyright 2020 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(LaunchOptions, "__esModule", { value: true });

var PuppeteerNode$1 = {};

var revisions = {};

/**
 * Copyright 2020 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(revisions, "__esModule", { value: true });
revisions.PUPPETEER_REVISIONS = void 0;
/**
 * @internal
 */
revisions.PUPPETEER_REVISIONS = Object.freeze({
    chrome: '116.0.5845.96',
    firefox: 'latest',
});

/**
 * Copyright 2020 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(PuppeteerNode$1, "__esModule", { value: true });
PuppeteerNode$1.PuppeteerNode = void 0;
const browsers_1 = require$$3;
const Puppeteer_js_1 = Puppeteer$1;
const revisions_js_1 = revisions;
const ChromeLauncher_js_1 = ChromeLauncher$1;
const FirefoxLauncher_js_1 = FirefoxLauncher$1;
/**
 * Extends the main {@link Puppeteer} class with Node specific behaviour for
 * fetching and downloading browsers.
 *
 * If you're using Puppeteer in a Node environment, this is the class you'll get
 * when you run `require('puppeteer')` (or the equivalent ES `import`).
 *
 * @remarks
 * The most common method to use is {@link PuppeteerNode.launch | launch}, which
 * is used to launch and connect to a new browser instance.
 *
 * See {@link Puppeteer | the main Puppeteer class} for methods common to all
 * environments, such as {@link Puppeteer.connect}.
 *
 * @example
 * The following is a typical example of using Puppeteer to drive automation:
 *
 * ```ts
 * import puppeteer from 'puppeteer';
 *
 * (async () => {
 *   const browser = await puppeteer.launch();
 *   const page = await browser.newPage();
 *   await page.goto('https://www.google.com');
 *   // other actions...
 *   await browser.close();
 * })();
 * ```
 *
 * Once you have created a `page` you have access to a large API to interact
 * with the page, navigate, or find certain elements in that page.
 * The {@link Page | `page` documentation} lists all the available methods.
 *
 * @public
 */
class PuppeteerNode extends Puppeteer_js_1.Puppeteer {
    #_launcher;
    #lastLaunchedProduct;
    /**
     * @internal
     */
    defaultBrowserRevision;
    /**
     * @internal
     */
    configuration = {};
    /**
     * @internal
     */
    constructor(settings) {
        const { configuration, ...commonSettings } = settings;
        super(commonSettings);
        if (configuration) {
            this.configuration = configuration;
        }
        switch (this.configuration.defaultProduct) {
            case 'firefox':
                this.defaultBrowserRevision = revisions_js_1.PUPPETEER_REVISIONS.firefox;
                break;
            default:
                this.configuration.defaultProduct = 'chrome';
                this.defaultBrowserRevision = revisions_js_1.PUPPETEER_REVISIONS.chrome;
                break;
        }
        this.connect = this.connect.bind(this);
        this.launch = this.launch.bind(this);
        this.executablePath = this.executablePath.bind(this);
        this.defaultArgs = this.defaultArgs.bind(this);
        this.trimCache = this.trimCache.bind(this);
    }
    /**
     * This method attaches Puppeteer to an existing browser instance.
     *
     * @param options - Set of configurable options to set on the browser.
     * @returns Promise which resolves to browser instance.
     */
    connect(options) {
        return super.connect(options);
    }
    /**
     * Launches a browser instance with given arguments and options when
     * specified.
     *
     * When using with `puppeteer-core`,
     * {@link LaunchOptions | options.executablePath} or
     * {@link LaunchOptions | options.channel} must be provided.
     *
     * @example
     * You can use {@link LaunchOptions | options.ignoreDefaultArgs}
     * to filter out `--mute-audio` from default arguments:
     *
     * ```ts
     * const browser = await puppeteer.launch({
     *   ignoreDefaultArgs: ['--mute-audio'],
     * });
     * ```
     *
     * @remarks
     * Puppeteer can also be used to control the Chrome browser, but it works best
     * with the version of Chrome for Testing downloaded by default.
     * There is no guarantee it will work with any other version. If Google Chrome
     * (rather than Chrome for Testing) is preferred, a
     * {@link https://www.google.com/chrome/browser/canary.html | Chrome Canary}
     * or
     * {@link https://www.chromium.org/getting-involved/dev-channel | Dev Channel}
     * build is suggested. See
     * {@link https://www.howtogeek.com/202825/what%E2%80%99s-the-difference-between-chromium-and-chrome/ | this article}
     * for a description of the differences between Chromium and Chrome.
     * {@link https://chromium.googlesource.com/chromium/src/+/lkgr/docs/chromium_browser_vs_google_chrome.md | This article}
     * describes some differences for Linux users. See
     * {@link https://goo.gle/chrome-for-testing | this doc} for the description
     * of Chrome for Testing.
     *
     * @param options - Options to configure launching behavior.
     */
    launch(options = {}) {
        const { product = this.defaultProduct } = options;
        this.#lastLaunchedProduct = product;
        return this.#launcher.launch(options);
    }
    /**
     * @internal
     */
    get #launcher() {
        if (this.#_launcher &&
            this.#_launcher.product === this.lastLaunchedProduct) {
            return this.#_launcher;
        }
        switch (this.lastLaunchedProduct) {
            case 'chrome':
                this.defaultBrowserRevision = revisions_js_1.PUPPETEER_REVISIONS.chrome;
                this.#_launcher = new ChromeLauncher_js_1.ChromeLauncher(this);
                break;
            case 'firefox':
                this.defaultBrowserRevision = revisions_js_1.PUPPETEER_REVISIONS.firefox;
                this.#_launcher = new FirefoxLauncher_js_1.FirefoxLauncher(this);
                break;
            default:
                throw new Error(`Unknown product: ${this.#lastLaunchedProduct}`);
        }
        return this.#_launcher;
    }
    /**
     * The default executable path.
     */
    executablePath(channel) {
        return this.#launcher.executablePath(channel);
    }
    /**
     * @internal
     */
    get browserRevision() {
        return (this.#_launcher?.getActualBrowserRevision() ??
            this.configuration.browserRevision ??
            this.defaultBrowserRevision);
    }
    /**
     * The default download path for puppeteer. For puppeteer-core, this
     * code should never be called as it is never defined.
     *
     * @internal
     */
    get defaultDownloadPath() {
        return this.configuration.downloadPath ?? this.configuration.cacheDirectory;
    }
    /**
     * The name of the browser that was last launched.
     */
    get lastLaunchedProduct() {
        return this.#lastLaunchedProduct ?? this.defaultProduct;
    }
    /**
     * The name of the browser that will be launched by default. For
     * `puppeteer`, this is influenced by your configuration. Otherwise, it's
     * `chrome`.
     */
    get defaultProduct() {
        return this.configuration.defaultProduct ?? 'chrome';
    }
    /**
     * @deprecated Do not use as this field as it does not take into account
     * multiple browsers of different types. Use
     * {@link PuppeteerNode.defaultProduct | defaultProduct} or
     * {@link PuppeteerNode.lastLaunchedProduct | lastLaunchedProduct}.
     *
     * @returns The name of the browser that is under automation.
     */
    get product() {
        return this.#launcher.product;
    }
    /**
     * @param options - Set of configurable options to set on the browser.
     *
     * @returns The default flags that Chromium will be launched with.
     */
    defaultArgs(options = {}) {
        return this.#launcher.defaultArgs(options);
    }
    /**
     * Removes all non-current Firefox and Chrome binaries in the cache directory
     * identified by the provided Puppeteer configuration. The current browser
     * version is determined by resolving PUPPETEER_REVISIONS from Puppeteer
     * unless `configuration.browserRevision` is provided.
     *
     * @remarks
     *
     * Note that the method does not check if any other Puppeteer versions
     * installed on the host that use the same cache directory require the
     * non-current binaries.
     *
     * @public
     */
    async trimCache() {
        const platform = (0, browsers_1.detectBrowserPlatform)();
        if (!platform) {
            throw new Error('The current platform is not supported.');
        }
        const cacheDir = this.configuration.downloadPath ?? this.configuration.cacheDirectory;
        const installedBrowsers = await (0, browsers_1.getInstalledBrowsers)({
            cacheDir,
        });
        const product = this.configuration.defaultProduct;
        const puppeteerBrowsers = [
            {
                product: 'chrome',
                browser: browsers_1.Browser.CHROME,
                currentBuildId: '',
            },
            {
                product: 'firefox',
                browser: browsers_1.Browser.FIREFOX,
                currentBuildId: '',
            },
        ];
        // Resolve current buildIds.
        for (const item of puppeteerBrowsers) {
            item.currentBuildId = await (0, browsers_1.resolveBuildId)(item.browser, platform, (product === item.product
                ? this.configuration.browserRevision
                : null) || revisions_js_1.PUPPETEER_REVISIONS[item.product]);
        }
        const currentBrowserBuilds = new Set(puppeteerBrowsers.map(browser => {
            return `${browser.browser}_${browser.currentBuildId}`;
        }));
        const currentBrowsers = new Set(puppeteerBrowsers.map(browser => {
            return browser.browser;
        }));
        for (const installedBrowser of installedBrowsers) {
            // Don't uninstall browsers that are not managed by Puppeteer yet.
            if (!currentBrowsers.has(installedBrowser.browser)) {
                continue;
            }
            // Keep the browser build used by the current Puppeteer installation.
            if (currentBrowserBuilds.has(`${installedBrowser.browser}_${installedBrowser.buildId}`)) {
                continue;
            }
            await (0, browsers_1.uninstall)({
                browser: installedBrowser.browser,
                platform,
                cacheDir,
                buildId: installedBrowser.buildId,
            });
        }
    }
}
PuppeteerNode$1.PuppeteerNode = PuppeteerNode;

(function (exports) {
	/**
	 * Copyright 2022 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	__exportStar(ChromeLauncher$1, exports);
	__exportStar(FirefoxLauncher$1, exports);
	__exportStar(LaunchOptions, exports);
	__exportStar(PipeTransport$1, exports);
	__exportStar(ProductLauncher$1, exports);
	__exportStar(PuppeteerNode$1, exports);
	
} (node));

var util = {};

var DebuggableDeferred = {};

Object.defineProperty(DebuggableDeferred, "__esModule", { value: true });
DebuggableDeferred.createDebuggableDeferred = void 0;
const environment_js_1 = environment;
const Deferred_js_1 = Deferred$1;
/**
 * Creates and returns a deferred promise using DEFERRED_PROMISE_DEBUG_TIMEOUT
 * if it's specified or a normal deferred promise otherwise.
 *
 * @internal
 */
function createDebuggableDeferred(message) {
    if (environment_js_1.DEFERRED_PROMISE_DEBUG_TIMEOUT > 0) {
        return Deferred_js_1.Deferred.create({
            message,
            timeout: environment_js_1.DEFERRED_PROMISE_DEBUG_TIMEOUT,
        });
    }
    return Deferred_js_1.Deferred.create();
}
DebuggableDeferred.createDebuggableDeferred = createDebuggableDeferred;

(function (exports) {
	/**
	 * Copyright 2022 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	__exportStar(assert$1, exports);
	__exportStar(DebuggableDeferred, exports);
	__exportStar(Deferred$1, exports);
	__exportStar(ErrorLike, exports);
	__exportStar(AsyncIterableUtil$1, exports);
	
} (util));

(function (exports) {
	/**
	 * Copyright 2017 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __exportStar = (commonjsGlobal && commonjsGlobal.__exportStar) || function(m, exports) {
	    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.launch = exports.executablePath = exports.defaultArgs = exports.connect = void 0;
	__exportStar(api, exports);
	__exportStar(common, exports);
	__exportStar(node, exports);
	__exportStar(revisions, exports);
	__exportStar(util, exports);
	/**
	 * @deprecated Use the query handler API defined on {@link Puppeteer}
	 */
	__exportStar(requireCustomQueryHandler(), exports);
	const PuppeteerNode_js_1 = PuppeteerNode$1;
	/**
	 * @public
	 */
	const puppeteer = new PuppeteerNode_js_1.PuppeteerNode({
	    isPuppeteerCore: true,
	});
	/**
	 * @public
	 */
	exports.connect = puppeteer.connect, 
	/**
	 * @public
	 */
	exports.defaultArgs = puppeteer.defaultArgs, 
	/**
	 * @public
	 */
	exports.executablePath = puppeteer.executablePath, 
	/**
	 * @public
	 */
	exports.launch = puppeteer.launch;
	exports.default = puppeteer;
	
} (puppeteerCore$1));

var puppeteerCore = /*@__PURE__*/getDefaultExportFromCjs(puppeteerCore$1);

export { puppeteerCore as default };
